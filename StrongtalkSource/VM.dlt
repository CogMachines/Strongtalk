Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !

(Delta mirrorFor: #VM) revision: '$Revision: 1.5 $'!

(Delta mirrorFor: #VM) group: 'base'!

(Delta mirrorFor: #VM)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !


new: class

	^self allocate: [:tenured :failBlock| self new: class ifFail: failBlock]
			ifExpand: [self expand]!

new: indexableClass size: size

	^self allocate: [:tenured :failBlock|
								self new: indexableClass
										size: size
										ifFail: failBlock]
			ifExpand: [self expand: size * self oopSize]!

newBytes: byteClass size: size

	^self allocate: [:tenured :failBlock|
								self newBytes: byteClass
										size: size
										tenured: tenured
										ifFail: failBlock]
			ifExpand: [self expand: size]! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'boolean flags' !


compiledCodeOnly: value <True|False>
	self booleanAt: #CompiledCodeOnly put: value!

traceDoubleByteArrayPrimitives: value <True|False>
	self booleanAt: #TraceDoubleByteArrayPrims put: value!

traceProxyPrimitives: value <True|False>
	self booleanAt: #TraceProxyPrims put: value!

useInliningDatabase ^<Boolean>

	^VM booleanAt: #UseInliningDatabase!

useInliningDatabase: f <Boolean>

	VM booleanAt: #UseInliningDatabase put: f!

wizardMode ^<True|False>
	^self booleanAt: #WizardMode!

wizardMode: value <True|False>
	self booleanAt: #WizardMode put: value! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'debugging' !


invocationCounterLimit ^ <Int>

	^{{primitiveInterpreterInvocationCounterLimit}}!

invocationCounterLimit: limit <Int>

	{{primitiveSetInterpreterInvocationCounterLimitTo: limit
		ifFail: [ :err <Symbol> | self error: err ]}}!

printCompilation ^<Boolean>

	^self vmFlagAt: #PrintCompilation!

printCompilation: flag <Boolean>

	self vmFlagAt: #PrintCompilation put: flag!

printInlining ^<Boolean>

	^self vmFlagAt: #PrintInlining!

printInlining: flag <Boolean>

	flag
		ifTrue: [ self printCompilation: flag. ].
	self vmFlagAt: #PrintInlining put: flag!

printScavenge ^<Boolean>

	^self vmFlagAt: #PrintScavenge!

printScavenge: flag <Boolean>

	self vmFlagAt: #PrintScavenge put: flag!

printZone

	{{primitivePrintZone}}!

recompilation ^<Boolean>

	^self vmFlagAt: #UseRecompilation!

recompilation: flag <Boolean>

	self vmFlagAt: #UseRecompilation put: flag! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !


collectGarbage

	{{self primitiveGarbageCollect}}!

deferredGC

	GCSemaphore := Semaphore new.
	[self collectGarbage.
	GCSemaphore signal] fork!

initializeGCProcess

GCProcess := [| delay |
							delay := Delay forMilliseconds: 500.
							[delay wait.
							VM objectMemorySize > 0.95
								ifTrue: [VM collectGarbage]] repeat] fork!

isGCPending

	^GCSemaphore notNil!

needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]!

objectMemorySize

	^{{self primitiveObjectMemorySize}}!

scavengeGarbage
	"Collect very recent garbage.  This is fast, but does not collect all garbage.
		(i.e. it scavenges the object nursery) "

	{{self primitiveScavenge}}!

startGCProcess

	self needsNewGCProcess
		ifTrue: [self initializeGCProcess]!

stopGCProcess

	self needsNewGCProcess
		ifFalse: [GCProcess terminate]!

waitForGC

	GCSemaphore isNil
		ifTrue: [self deferredGC]
		ifFalse:[GCSemaphore wait.
					GCSemaphore := nil]! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer flags' !


numberOfBlockAllocations
	^self smallIntegerAt: #NumberOfBlockAllocations!

numberOfContextAllocations
	^self smallIntegerAt: #NumberOfContextAllocations!

survivorSpaceSize

	^(self smallIntegerAt: #SurvivorSize) * 1024! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer operations' !


numberOfMethodInvocations
	^{{primitiveNumberOfMethodInvocations}}!

numberOfNMethodInvocations
	^{{primitiveNumberOfNMethodInvocations}}! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'lookup' !


numberOfLookupCacheMisses
	"Number of lookups that missed both the primary and secondary lookup cache"
	^{{primitiveNumberOfLookupCacheMisses}}!

numberOfPrimaryLookupCacheHits
	"Number of lookups where the result were located in the primary cache"
	^{{primitiveNumberOfPrimaryLookupCacheHits}}!

numberOfSecondaryLookupCacheHits
	"Number of lookups where the result were located in the secondary cache"
	^{{primitiveNumberOfPrimaryLookupCacheHits}}! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !


booleanAt: name <Symbol> ^<SmallInteger>
	^{{primitiveBooleanFlagAt: name ifFail: [:err | self error: self]}}!

booleanAt: name <Symbol> put: value <True|False> ^<SmallInteger>
	^{{primitiveBooleanFlagAt: name put: value ifFail: [:err | self error: err]}}!

error: msg <Symbol> ^ <Boolean>
	"ignore flags that are not defined in product version"
	^ false!

smallIntegerAt: name <Symbol> ^<SmallInteger>
	^{{primitiveSmallIntegerFlagAt: name ifFail: [:err | self error: self]}}!

smallIntegerAt: name <Symbol> put: value <SmallInteger> ^<SmallInteger>
	^{{primitiveSmallIntegerFlagAt: name put: value  ifFail: [:err | self error: self]}}!

vmFlagAt: name <Symbol>  ^<Boolean>

	^{{primitiveBooleanFlagAt: name
			ifFail: [ :err <Symbol> | self error: err ]}}!

vmFlagAt: name <Symbol> put:  flag <Boolean>

	{{primitiveBooleanFlagAt: name put: flag
			ifFail: [ :err <Symbol> | self error: err ]}}! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'private - allocation' !


K

	^1024!

allocate: allocateBlock ifExpand: expansionBlock

	^allocateBlock
			value: false
			value: [:e| e == #FailedAllocation
									ifTrue: [self spaceToScavenge
														ifTrue: [self scavengeAndAllocate: allocateBlock
																				ifExpand: expansionBlock]
														ifFalse: [self collectAndAllocate: allocateBlock
																				ifExpand: expansionBlock]]
									ifFalse: [nil error: e]]!

collectAndAllocate: allocateBlock ifExpand: expansionBlock

	self collectGarbage.
	^[allocateBlock
			value: true
			value: [:e| 
						expansionBlock value.
						allocateBlock
							value: true
							value: [:e2| nil error: e2]]]
			ensure: [self shrinkIfPossible]!

expand

	|expansionSize|
	expansionSize := (self smallIntegerAt: #ObjectHeapExpandSize) * self K.
	self expand: expansionSize!

expand: expansionSize

	{{primitiveExpandMemory: expansionSize}}!

freeSpace

	^{{primitiveFreeSpace}}!

hasExpandedBlock
	|expansions|
	expansions := {{primitiveExpansions}}.
	^[expansions ~~ {{primitiveExpansions}}]!

new: class ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}!

new: class size: size ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}!

newBytes: class size: size tenured: tenured ifFail: failureBlock

	^{{primitiveIndexedByteNew: class
			size: size
			tenured: tenured
			ifFail: [:e| failureBlock value: e]}}!

oopSize

	^{{primitiveSizeOfOop}}!

scavengeAndAllocate: allocateBlock ifExpand: expansionBlock

	|hasExpandedBlock|
	hasExpandedBlock := self hasExpandedBlock.
	self scavengeGarbage.
	^hasExpandedBlock value
			ifTrue: [self collectAndAllocate: allocateBlock
								ifExpand: expansionBlock]
			ifFalse: [allocateBlock
								value: true
								value: [:e3| self collectAndAllocate: allocateBlock
															ifExpand: expansionBlock]]!

shrink: size

	{{primitiveShrinkMemory: size}}!

shrinkBarrier

	^(self smallIntegerAt: #ObjectHeapExpandSize) * 3 * VM K!

shrinkIfPossible

	self freeSpace > self shrinkBarrier
		ifTrue: [|amountToShrink|
						amountToShrink := self freeSpace - self shrinkBarrier.
						self shrink: amountToShrink]!

spaceToScavenge

	^self freeSpace > (2 * self survivorSpaceSize)	! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'system control' !


quit
	"Terminate the virtual machine"

	{{primitiveQuit}}.!

quitUI
	"Terminate the user interface"
	
	{{<user ExternalProxy PostQuitMessage> arg: 0}}.
! !

! (Delta mirrorFor: #VM) classSide methodsFor: 'wrappers' !


nmethodHistogram: blk
	{{primitiveClearNMethodCounters}}.
	blk value.
	{{primitivePrintNMethodCounterHistogram: 20 ifFail: [:err | self error: err]}}!

traceLookupMissesFor: blk <[]>
	|a b c| 
	a := VM numberOfPrimaryLookupCacheHits.
	b := VM numberOfSecondaryLookupCacheHits.
	c := VM numberOfLookupCacheMisses.

	blk  value.

	Transcript
					show:  (VM numberOfPrimaryLookupCacheHits - a) printString; tab
				;	show:  (VM numberOfSecondaryLookupCacheHits - b) printString; tab
				;	show:  (VM numberOfLookupCacheMisses - c) printString; cr.
! !

