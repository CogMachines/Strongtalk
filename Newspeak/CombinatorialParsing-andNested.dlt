Delta define: #CombinatorialParsing as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' CombinatorialParsing_WrappingParser_slot CombinatorialParsing_CollectingCommentParser_slot CombinatorialParsing_WhitespaceParser_slot CombinatorialParsing_EmptyParser_slot Error CombinatorialParsing_EOIParser_slot CombinatorialParsing_CommentParser_slot CombinatorialParsing_TokenizingParser_slot CombinatorialParsing_SymbolicTokenParser_slot CombinatorialParsing_NegatingParser_slot CombinatorialParsing_Token_slot CombinatorialParsing_ParserError_slot CombinatorialParsing_CharParser_slot CombinatorialParsing_ParserContext_slot CombinatorialParsing_StarParser_slot CombinatorialParsing_PredicateTokenParser_slot CombinatorialParsing_AlternatingParser_slot CombinatorialParsing_SequentialParser_slot OrderedCollection CombinatorialParsing_TokenParser_slot CombinatorialParsing_PlusParser_slot CombinatorialParsing_FailingParser_slot CombinatorialParsing_CombinatorialParser_slot')
	 classVariables: 'MixinMetadata_CombinatorialParsing EnclosingObjects_CombinatorialParsing')!
	(Delta mirrorFor: #CombinatorialParsing) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing) comment: #''!
	! (Delta mirrorFor: #CombinatorialParsing) methodsFor: 'unclassified'!
	FailingParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_FailingParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_FailingParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_FailingParser_slot := myNested.
		].
	^CombinatorialParsing_FailingParser_slot! 
EOIParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_EOIParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_EOIParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_EOIParser_slot := myNested.
		].
	^CombinatorialParsing_EOIParser_slot! 
TokenParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_TokenParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_TokenParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  PredicateTokenParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_TokenParser_slot := myNested.
		].
	^CombinatorialParsing_TokenParser_slot! 
CollectingCommentParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_CollectingCommentParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_CollectingCommentParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CommentParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_CollectingCommentParser_slot := myNested.
		].
	^CombinatorialParsing_CollectingCommentParser_slot! 
WrappingParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_WrappingParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_WrappingParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_WrappingParser_slot := myNested.
		].
	^CombinatorialParsing_WrappingParser_slot! 
NegatingParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_NegatingParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_NegatingParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_NegatingParser_slot := myNested.
		].
	^CombinatorialParsing_NegatingParser_slot! 
SequentialParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_SequentialParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_SequentialParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_SequentialParser_slot := myNested.
		].
	^CombinatorialParsing_SequentialParser_slot! 
TokenizingParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_TokenizingParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_TokenizingParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_TokenizingParser_slot := myNested.
		].
	^CombinatorialParsing_TokenizingParser_slot! 
ParserError
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_ParserError_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_ParserError.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  Error)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_ParserError_slot := myNested.
		].
	^CombinatorialParsing_ParserError_slot! 
Token
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_Token_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_Token.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self Object)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_Token_slot := myNested.
		].
	^CombinatorialParsing_Token_slot! 
CharParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_CharParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_CharParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  PredicateTokenParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_CharParser_slot := myNested.
		].
	^CombinatorialParsing_CharParser_slot! 
PlusParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_PlusParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_PlusParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_PlusParser_slot := myNested.
		].
	^CombinatorialParsing_PlusParser_slot! 
CombinatorialParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_CombinatorialParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_CombinatorialParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self Object)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_CombinatorialParser_slot := myNested.
		].
	^CombinatorialParsing_CombinatorialParser_slot! 
StarParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_StarParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_StarParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_StarParser_slot := myNested.
		].
	^CombinatorialParsing_StarParser_slot! 
EmptyParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_EmptyParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_EmptyParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_EmptyParser_slot := myNested.
		].
	^CombinatorialParsing_EmptyParser_slot! 
 CombinatorialParsing_1_init: platform 

 self OrderedCollection: platform Collections OrderedCollection.

 self Error: platform Exceptions Error.

^ self.



! 
ParserContext
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_ParserContext_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_ParserContext.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self Object)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_ParserContext_slot := myNested.
		].
	^CombinatorialParsing_ParserContext_slot! 
PredicateTokenParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_PredicateTokenParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_PredicateTokenParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_PredicateTokenParser_slot := myNested.
		].
	^CombinatorialParsing_PredicateTokenParser_slot! 
AlternatingParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_AlternatingParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_AlternatingParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_AlternatingParser_slot := myNested.
		].
	^CombinatorialParsing_AlternatingParser_slot! 
CommentParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_CommentParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_CommentParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_CommentParser_slot := myNested.
		].
	^CombinatorialParsing_CommentParser_slot! 
WhitespaceParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_WhitespaceParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_WhitespaceParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_WhitespaceParser_slot := myNested.
		].
	^CombinatorialParsing_WhitespaceParser_slot! 
Error: Error_val Error := Error_val! 
 usingLib: platform 

 self CombinatorialParsing_superInit_usingLib: platform.

 self CombinatorialParsing_1_init: platform.

^ self.



! 
SymbolicTokenParser
	| nestedClass enclosingObjectArray myNested depth |
	CombinatorialParsing_SymbolicTokenParser_slot isNil ifTrue:[ 
		nestedClass := 	MixinMetadata_CombinatorialParsing 
			nestedMixins at: #CombinatorialParsing_SymbolicTokenParser.
		myNested := (nestedClass mixin |>  (MixinMetadata_CombinatorialParsing Mirror on: self  CombinatorialParser)) reflectee.
		myNested mixinMetadata: nestedClass reflectee metadata.
		depth := EnclosingObjects_CombinatorialParsing size + 1.
		enclosingObjectArray :=  Array new: depth. 
		enclosingObjectArray at:1 put: self. 
		2 to: depth do:[:i | 
			enclosingObjectArray at:i put:(EnclosingObjects_CombinatorialParsing at: i - 1)
			].
		 myNested enclosingObjects: enclosingObjectArray.
		CombinatorialParsing_SymbolicTokenParser_slot := myNested.
		].
	^CombinatorialParsing_SymbolicTokenParser_slot! 
OrderedCollection ^OrderedCollection! 
 CombinatorialParsing_superInit_usingLib: platform 

super  new.

^ self.



! 
Error ^Error! 
OrderedCollection: OrderedCollection_val OrderedCollection := OrderedCollection_val! 
 !
	! (Delta mirrorFor: #CombinatorialParsing) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing := mmd !
	 usingLib: platform 

^ self basicNew usingLib: platform.



! 
		 !
	CombinatorialParsing enclosingObjects: (Array with: nil)!
		CombinatorialParsing metadata enclosingMixin: nil !
		CombinatorialParsing mixinMetadata: CombinatorialParsing metadata !
		Delta define: #CombinatorialParsing_CharParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:'')
	 classVariables: 'MixinMetadata_CombinatorialParsing_CharParser EnclosingObjects_CombinatorialParsing_CharParser')!
	(Delta mirrorFor: #CombinatorialParsing_CharParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_CharParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_CharParser) comment: #''!
	! (Delta mirrorFor: #CombinatorialParsing_CharParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_CharParser_1_init 

^ self.



! 
 CombinatorialParsing_CharParser_superInit_new 

super  new.

^ self.



! 
 for: token 

 self assert:[ 

 token isKindOf: self Character.

].

^ self  accept:[ : t | 

 t = token.

] errorMsg: token printString ,' expected'.



! 
 new 

 self CombinatorialParsing_CharParser_superInit_new.

 self CombinatorialParsing_CharParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_CharParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_CharParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_CharParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_CharParser. ! 
	CombinatorialParsing_CharParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_CollectingCommentParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' comment')
	 classVariables: 'MixinMetadata_CombinatorialParsing_CollectingCommentParser EnclosingObjects_CombinatorialParsing_CollectingCommentParser')!
	(Delta mirrorFor: #CombinatorialParsing_CollectingCommentParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_CollectingCommentParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_CollectingCommentParser) comment: 'A special parser used for inputs that need to be rapidly scanned over. It differs from its superclass in that it actually collects the characters it scans, in case they are needed (e.g., for pretty printers). 

Ideally,we should not have to do this, but until we do proper optimization by compiling combinators, this will have to suffice. It provides a marked improvement in performance, By using such parsers for comments, whitespace and strings, the overall performance of the Newqueak parser improved by a factor of 2 or so.'!
	! (Delta mirrorFor: #CombinatorialParsing_CollectingCommentParser) methodsFor: 'unclassified'!
	  parse: input inContext: context ifError: blk 

|  c |

 self  comment: (EnclosingObjects_CombinatorialParsing_CollectingCommentParser at: 1)  OrderedCollection new.

[ 

 self termBlock value: input.

] whileFalse:[ 

 c := input nextIfAbsent:[ 

 blk  value:'Premature end of input' value: input position - 1.

].

 self  comment add: c.

].

^ self  comment.



! 
comment: comment_val comment := comment_val! 
 CombinatorialParsing_CollectingCommentParser_1_init 

 self comment:nil.

^ self.



! 
 CombinatorialParsing_CollectingCommentParser_superInit_new 

super  new.

^ self.



! 
comment ^comment! 
 new 

 self CombinatorialParsing_CollectingCommentParser_superInit_new.

 self CombinatorialParsing_CollectingCommentParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_CollectingCommentParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_CollectingCommentParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_CollectingCommentParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_CollectingCommentParser. ! 
	CombinatorialParsing_CollectingCommentParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_WrappingParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' wrapperBlock parser')
	 classVariables: 'MixinMetadata_CombinatorialParsing_WrappingParser EnclosingObjects_CombinatorialParsing_WrappingParser')!
	(Delta mirrorFor: #CombinatorialParsing_WrappingParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_WrappingParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_WrappingParser) comment: 'Used to transform the output of another parser. A wrapping parser accepts exactly the same input as the wrapped
parser does, and performs the same error handling. The only differenceis that it takes the output of the wrapped
parser and passes it on to a wrapper block which uses it to produce a new result, which is the output of the wrapping
parser. A typical use is to build nodes of an abstract syntax tree.

The output type of the wrapped parser, S, is also the input to the wrapper. The output type of the wrapper is the output of this 
(the wrapping) parser.'!
	! (Delta mirrorFor: #CombinatorialParsing_WrappingParser) methodsFor: 'unclassified'!
	wrapperBlock ^wrapperBlock! 
parser: parser_val parser := parser_val! 
 CombinatorialParsing_WrappingParser_1_init 

 self parser:nil.

 self wrapperBlock:nil.

^ self.



! 
wrapperBlock: wrapperBlock_val wrapperBlock := wrapperBlock_val! 
 new 

 self CombinatorialParsing_WrappingParser_superInit_new.

 self CombinatorialParsing_WrappingParser_1_init.

^ self.



! 
parser ^parser! 
  parse: input inContext: context ifError: blk 

^ self  wrapperBlock value:( self  parser  parse: input inContext: context ifError: blk).



! 
  wrapParser: p withWrapper: blk 

 self  parser: p.

 self  wrapperBlock: blk.

^ self.



! 
 CombinatorialParsing_WrappingParser_superInit_new 

super  new.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_WrappingParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_WrappingParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_WrappingParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_WrappingParser. ! 
	CombinatorialParsing_WrappingParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_WhitespaceParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' comment')
	 classVariables: 'MixinMetadata_CombinatorialParsing_WhitespaceParser EnclosingObjects_CombinatorialParsing_WhitespaceParser')!
	(Delta mirrorFor: #CombinatorialParsing_WhitespaceParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_WhitespaceParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_WhitespaceParser) comment: 'A simple scanner to optimize the handling of whitespace. Should be equivalent to''
 aWhitespaceChar plus
Eventually, the framework should optimize well enough that this will be unnecessary.'!
	! (Delta mirrorFor: #CombinatorialParsing_WhitespaceParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_WhitespaceParser_superInit_new 

super  new.

^ self.



! 
  parse: input inContext: context ifError: blk 

|  pos |

 pos := input position.

 self  comment: (EnclosingObjects_CombinatorialParsing_WhitespaceParser at: 1)  OrderedCollection new.

[ 

|  c |

 c := input peekIfAbsent:[ 

nil.

].

 c isNil  ifTrue:[ 

false.

] ifFalse:[ 

 c isSeparator.

].

] whileTrue:[ 

 self  comment add: input next.

].

 self  comment isEmpty ifTrue:[ 

 blk  value:'Whitespace expected' value: pos.

].

^ self  comment.



! 
comment: comment_val comment := comment_val! 
comment ^comment! 
 CombinatorialParsing_WhitespaceParser_1_init 

 self comment:nil.

^ self.



! 
 new 

 self CombinatorialParsing_WhitespaceParser_superInit_new.

 self CombinatorialParsing_WhitespaceParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_WhitespaceParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_WhitespaceParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_WhitespaceParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_WhitespaceParser. ! 
	CombinatorialParsing_WhitespaceParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_SymbolicTokenParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' symbol')
	 classVariables: 'MixinMetadata_CombinatorialParsing_SymbolicTokenParser EnclosingObjects_CombinatorialParsing_SymbolicTokenParser')!
	(Delta mirrorFor: #CombinatorialParsing_SymbolicTokenParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_SymbolicTokenParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_SymbolicTokenParser) comment: 'Parses a given symbol.  One could derive this as an alternation of character parsers, but the derivation is more verbose than defining it directly, and less efficient, so why bother?'!
	! (Delta mirrorFor: #CombinatorialParsing_SymbolicTokenParser) methodsFor: 'unclassified'!
	 forSymbol: s 

 self  symbol: s.

^ self.



! 
symbol: symbol_val symbol := symbol_val! 
 CombinatorialParsing_SymbolicTokenParser_1_init 

 self symbol:nil.

^ self.



! 
symbol ^symbol! 
 CombinatorialParsing_SymbolicTokenParser_superInit_new 

super  new.

^ self.



! 
  parse: input inContext: context ifError: blk 

|  errMsg  pos |

 errMsg := self  symbol ,' expected'.

 pos := input position.

 self  symbol do:[ : c | 

 c =( input nextIfAbsent:[ 

 blk  value: errMsg value: pos.

]) ifFalse:[ 

 blk  value: errMsg value: pos.

].

].

^ self  symbol.



! 
 new 

 self CombinatorialParsing_SymbolicTokenParser_superInit_new.

 self CombinatorialParsing_SymbolicTokenParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_SymbolicTokenParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_SymbolicTokenParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_SymbolicTokenParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_SymbolicTokenParser. ! 
	CombinatorialParsing_SymbolicTokenParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_EmptyParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:'')
	 classVariables: 'MixinMetadata_CombinatorialParsing_EmptyParser EnclosingObjects_CombinatorialParsing_EmptyParser')!
	(Delta mirrorFor: #CombinatorialParsing_EmptyParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_EmptyParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_EmptyParser) comment: 'The parser that parses the empty input. It always succeeds. This class is a singleton.'!
	! (Delta mirrorFor: #CombinatorialParsing_EmptyParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_EmptyParser_superInit_new 

super  new.

^ self.



! 
 CombinatorialParsing_EmptyParser_1_init 

^ self.



! 
  parse: input inContext: context ifError: blk 

^nil.



! 
 new 

 self CombinatorialParsing_EmptyParser_superInit_new.

 self CombinatorialParsing_EmptyParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_EmptyParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_EmptyParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_EmptyParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_EmptyParser. ! 
	CombinatorialParsing_EmptyParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_NegatingParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' p')
	 classVariables: 'MixinMetadata_CombinatorialParsing_NegatingParser EnclosingObjects_CombinatorialParsing_NegatingParser')!
	(Delta mirrorFor: #CombinatorialParsing_NegatingParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_NegatingParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_NegatingParser) comment: 'A parser that implements the  ''not'' combinator, as in Ford''s PEGs. It contains a parser p, and succeeds if p fails and vice versa. It does not move the input forward if it succeeds.'!
	! (Delta mirrorFor: #CombinatorialParsing_NegatingParser) methodsFor: 'unclassified'!
	p ^p! 
 for: aParser 

 self CombinatorialParsing_NegatingParser_superInit_for: aParser.

 self CombinatorialParsing_NegatingParser_1_init: aParser.

^ self.



! 
p: p_val p := p_val! 
 CombinatorialParsing_NegatingParser_superInit_for: aParser 

super  new.

^ self.



! 
  parse: input inContext: ctxt ifError: blk 

|  position |

 position := input position.

 self  p  parse: input inContext: ctxt ifError:[ : msg : pos | 

 input position: pos.

^true.

].

 blk  value:'not combinator failed' value: position.

^ self.



! 
 CombinatorialParsing_NegatingParser_1_init: aParser 

 self p: aParser.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_NegatingParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_NegatingParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_NegatingParser := mmd !
	 for: aParser 

^ self basicNew for: aParser.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_NegatingParser. ! 
	CombinatorialParsing_NegatingParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_PlusParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' p')
	 classVariables: 'MixinMetadata_CombinatorialParsing_PlusParser EnclosingObjects_CombinatorialParsing_PlusParser')!
	(Delta mirrorFor: #CombinatorialParsing_PlusParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_PlusParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_PlusParser) comment: 'An attempt to optimize the + operator by having a dedicated parser for it.'!
	! (Delta mirrorFor: #CombinatorialParsing_PlusParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_PlusParser_1_init 

 self p:nil.

^ self.



! 
 CombinatorialParsing_PlusParser_superInit_new 

super  new.

^ self.



! 
p ^p! 
p: p_val p := p_val! 
  parse: input inContext: context ifError: blk 

|  currentPos  results  nextResult |

 results := (EnclosingObjects_CombinatorialParsing_PlusParser at: 1)  OrderedCollection new.

 results add:( self  p  parse: input inContext: context ifError: blk).

[ 

true.

] whileTrue:[ 

 currentPos := input position.

 nextResult := self  p  parse: input inContext: context ifError:[ : msg : pos | 

 input position: currentPos.

^ results.

].

 results add: nextResult.

].

^ self.



! 
 new 

 self CombinatorialParsing_PlusParser_superInit_new.

 self CombinatorialParsing_PlusParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_PlusParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_PlusParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_PlusParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_PlusParser. ! 
	CombinatorialParsing_PlusParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_TokenParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:'')
	 classVariables: 'MixinMetadata_CombinatorialParsing_TokenParser EnclosingObjects_CombinatorialParsing_TokenParser')!
	(Delta mirrorFor: #CombinatorialParsing_TokenParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_TokenParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_TokenParser) comment: 'A parser that accepts a single, specified token.
'!
	! (Delta mirrorFor: #CombinatorialParsing_TokenParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_TokenParser_1_init 

^ self.



! 
 CombinatorialParsing_TokenParser_superInit_new 

super  new.

^ self.



! 
 for: token 

^ self  accept:[ : t | 

 t = token.

] errorMsg: token printString ,' expected'.



! 
 new 

 self CombinatorialParsing_TokenParser_superInit_new.

 self CombinatorialParsing_TokenParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_TokenParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_TokenParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_TokenParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_TokenParser. ! 
	CombinatorialParsing_TokenParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_TokenizingParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' parser')
	 classVariables: 'MixinMetadata_CombinatorialParsing_TokenizingParser EnclosingObjects_CombinatorialParsing_TokenizingParser')!
	(Delta mirrorFor: #CombinatorialParsing_TokenizingParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_TokenizingParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_TokenizingParser) comment: #''!
	! (Delta mirrorFor: #CombinatorialParsing_TokenizingParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_TokenizingParser_1_init 

 self parser:nil.

^ self.



! 
 CombinatorialParsing_TokenizingParser_superInit_new 

super  new.

^ self.



! 
parser: parser_val parser := parser_val! 
parser ^parser! 
  parse: input inContext: context ifError: blk 

|  pos  res |

 pos := input position +1.

 res := self  parser  parse: input inContext: context ifError: blk.

^ (EnclosingObjects_CombinatorialParsing_TokenizingParser at: 1)  Token new  for: res start: pos end: input position.



! 
 new 

 self CombinatorialParsing_TokenizingParser_superInit_new.

 self CombinatorialParsing_TokenizingParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_TokenizingParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_TokenizingParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_TokenizingParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_TokenizingParser. ! 
	CombinatorialParsing_TokenizingParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_SequentialParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' parserFuns subparsers')
	 classVariables: 'MixinMetadata_CombinatorialParsing_SequentialParser EnclosingObjects_CombinatorialParsing_SequentialParser')!
	(Delta mirrorFor: #CombinatorialParsing_SequentialParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_SequentialParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_SequentialParser) comment: 'A parser that activates a sequence of subparsers (P1, ,Pn).

One might think that it would be sufficient to define a class that
combined two parsers in sequence, corresponding to the &
operator, just like AlternatingParser corresponds to the | operator.
However, grammar productions typically involve several elements, so
the typical sequencing operation is n-ary '!
	! (Delta mirrorFor: #CombinatorialParsing_SequentialParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_SequentialParser_superInit_new 

super  new.

^ self.



! 
parserFuns: parserFuns_val parserFuns := parserFuns_val! 
 parsers 

 self  subparsers isNil ifTrue:[ 

 self  subparsers:( self  parserFuns collect:[ : pf | 

 self assert:[ 

 pf isBlock.

].

 pf value.

]).

].

^ self  subparsers.



! 
 CombinatorialParsing_SequentialParser_1_init 

 self parserFuns:nil.

 self subparsers:nil.

^ self.



! 
 , p 

|  o |

 self assert:[ 

 p isBlock.

].

 o := (EnclosingObjects_CombinatorialParsing_SequentialParser at: 1)  OrderedCollection new addAll: self  parserFuns; 

 add: p; 

 yourself.

^ (EnclosingObjects_CombinatorialParsing_SequentialParser at: 1)  SequentialParser new on: o.



! 
subparsers: subparsers_val subparsers := subparsers_val! 
subparsers ^subparsers! 
  parse: input inContext: context ifError: blk 

^ self  parsers collect:[ : p | 

 p  parse: input inContext: context ifError: blk.

].



! 
 on: t 

 self  parserFuns: t.

^ self.



! 
parserFuns ^parserFuns! 
 wrapper: blk 

 self assert:[ 

 blk numArgs = self  parserFuns size.

].

^ self wrap:[ : rs | 

 blk valueWithArguments: rs asArray.

].



! 
 new 

 self CombinatorialParsing_SequentialParser_superInit_new.

 self CombinatorialParsing_SequentialParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_SequentialParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_SequentialParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_SequentialParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_SequentialParser. ! 
	CombinatorialParsing_SequentialParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_CombinatorialParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:'')
	 classVariables: 'MixinMetadata_CombinatorialParsing_CombinatorialParser EnclosingObjects_CombinatorialParsing_CombinatorialParser')!
	(Delta mirrorFor: #CombinatorialParsing_CombinatorialParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_CombinatorialParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_CombinatorialParser) comment: 'This class is intended to implement Parser
Combinators. A CombinatorialParser[T]
returns a value of type T after successful
parsing.

The class is abstract. It does not implement
 the parsing routine parse:ifError: .
 
If parsing fails, parse:ifError: should call the error handling block
passed to it.

Concrete subclasses should implement specific grammars.

Parsing is initiated by calling parse:ifError:. This routine takes a ReadStream[Object] as input.
If parsing fails, it is the caller''''s responsibility to set the input stream back to its original position
(Q: is this a good idea?).
If an error occurs, the error block passed in is called.'!
	! (Delta mirrorFor: #CombinatorialParsing_CombinatorialParser) methodsFor: 'unclassified'!
	  charBetween: c1 and: c2 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  PredicateTokenParser new  accept:[ : c | 

 c  between: c1 and: c2.

] errorMsg:'character between ' , c1 asString ,'and ' , c2 asString ,'expected'.



! 
 CombinatorialParsing_CombinatorialParser_superInit_new 

super  new.

^ self.



! 
 aWhitespaceChar 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  PredicateTokenParser new  accept:[ : c | 

 c asciiValue <=Character space asciiValue.

] errorMsg:'whitespace expected'.



! 
 , p 

^ self & p.



! 
  combineErrors: e1 and: e2 at: pos 

|  or  msg |

 or :=( e1 =#'' or:[ 

 e2 =#''.

])  ifTrue:[ 

#''.

] ifFalse:[ 

' or '.

].

 e1 = e2  ifTrue:[ 

 msg := e1.

] ifFalse:[ 

 msg := e1 , or , e2.

].

^( self Array new:2)  at:1 put: msg; 

  at:2 put: pos; 

 yourself.



! 
 wrap: blk 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  WrappingParser new  wrapParser: self withWrapper: blk.



! 
 empty 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  EmptyParser new.



! 
  parse: input ifError: blk 

|  context |

 context := (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  ParserContext new.

^ self   parse: input inContext: context ifError:[ : msg : pos | 

 context errorPosition = pos  ifTrue:[ 

 context recordFailure:( self   combineErrors: context errorMessage and: msg at: pos).

] ifFalse:[ 

 context recordFailure:(( self Array new:2)  at:1 put: msg; 

  at:2 put: pos; 

 yourself).

].

 blk  value: context errorMessage value: context errorPosition.

].



! 
 plus 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  PlusParser new p: self.



! 
  parse: input inContext: context ifError: blk 

 self subclassResponsibility.

^ self.



! 
 wrapper: blk 

^ self  wrap:[ : rs | 

 blk valueWithArguments:( rs isCollection  ifTrue:[ 

 rs asArray.

] ifFalse:[ 

 self Array with: rs.

]).

].



! 
 not 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  NegatingParser for: self.



! 
 new 

 self CombinatorialParsing_CombinatorialParser_superInit_new.

 self CombinatorialParsing_CombinatorialParser_1_init.

^ self.



! 
 CombinatorialParsing_CombinatorialParser_1_init 

^ self.



! 
 & p 

|  o |

 self assert:[ 

 p isBlock.

].

 o := (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  OrderedCollection new add:[ 

 self.

]; 

 add: p; 

 yourself.

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  SequentialParser new on: o.



! 
 char: c 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  CharParser new for: c.



! 
 whitespace 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  WhitespaceParser new.



! 
 comment 

^ self  fail.



! 
 opt 

^ self |[ 

 self empty.

].



! 
 plusSeparatedOrTerminatedBy: separator 

^( self  plusSeparatedBy: separator) ,[ 

 separator value opt.

] wrapper:[ : lst : end | 

 lst.

].



! 
 starSeparatedOrTerminatedBy: separator 

^( self  plusSeparatedOrTerminatedBy: separator) opt wrap:[ : rs | 

 rs isNil  ifTrue:[ 

 (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  OrderedCollection new.

] ifFalse:[ 

 rs.

].

].



! 
 parse: input 

^ self  parse: input ifError:[ : msg : pos | 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  ParserError new message: msg; 

 position: pos; 

 signal.

].



! 
 tokenFor: p 

|  posParser |

 posParser := (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  TokenizingParser new parser: p.

^( self  whitespace |[ 

 self  comment.

]) star ,[ 

 posParser.

] wrapper:[ : dontCare : t | 

 t.

].



! 
 star 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  StarParser new p: self.



! 
 fail 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  FailingParser new.



! 
 eoi 

^ self  tokenFor: (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  EOIParser new.



! 
 tokenFromChar: c 

^ self  tokenFor:( self  char: c).



! 
 | p 

^ (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  AlternatingParser new  either:[ 

 self.

] or: p.



! 
 plusSeparatedBy: separator 

^ self &[ 

( separator value &[ 

 self.

] wrapper:[ : s : v | 

 v.

]) star.

] wrapper:[ : fst : rst | 

|  results |

 (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  OrderedCollection new addFirst: fst; 

 addAll: rst; 

 yourself.

].



! 
 starSeparatedBy: separator 

^( self  plusSeparatedBy: separator) opt wrap:[ : rs | 

 rs isNil  ifTrue:[ 

 (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  OrderedCollection new.

] ifFalse:[ 

 rs.

].

].



! 
 tokenFromSymbol: s 

^ self  tokenFor:( (EnclosingObjects_CombinatorialParsing_CombinatorialParser at: 1)  SymbolicTokenParser new forSymbol: s).



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_CombinatorialParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_CombinatorialParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_CombinatorialParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_CombinatorialParser. ! 
	CombinatorialParsing_CombinatorialParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_EOIParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:'')
	 classVariables: 'MixinMetadata_CombinatorialParsing_EOIParser EnclosingObjects_CombinatorialParsing_EOIParser')!
	(Delta mirrorFor: #CombinatorialParsing_EOIParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_EOIParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_EOIParser) comment: 'A parser that only succeeds at the end of the input. This addresses a common problem with combinator parsers. If there is garbage at the end of the input, no production matches it. Consequently, the parsers backtrack to the point where the legal input was consumed, without giving an error message about the junk at the end.'!
	! (Delta mirrorFor: #CombinatorialParsing_EOIParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_EOIParser_1_init 

^ self.



! 
  parse: input inContext: context ifError: blk 

 input atEnd  ifTrue:[ 

^true.

] ifFalse:[ 

 blk  value:'Unexpected input' value: input position +1.

].

^ self.



! 
 CombinatorialParsing_EOIParser_superInit_new 

super  new.

^ self.



! 
 new 

 self CombinatorialParsing_EOIParser_superInit_new.

 self CombinatorialParsing_EOIParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_EOIParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_EOIParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_EOIParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_EOIParser. ! 
	CombinatorialParsing_EOIParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_FailingParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:'')
	 classVariables: 'MixinMetadata_CombinatorialParsing_FailingParser EnclosingObjects_CombinatorialParsing_FailingParser')!
	(Delta mirrorFor: #CombinatorialParsing_FailingParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_FailingParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_FailingParser) comment: 'The parser that always fails. It never parses anything. This class is a singleton.'!
	! (Delta mirrorFor: #CombinatorialParsing_FailingParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_FailingParser_superInit_new 

super  new.

^ self.



! 
  parse: input inContext: context ifError: blk 

^ blk  value:'Failing Parser invoked' value: input position.



! 
 new 

 self CombinatorialParsing_FailingParser_superInit_new.

 self CombinatorialParsing_FailingParser_1_init.

^ self.



! 
 CombinatorialParsing_FailingParser_1_init 

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_FailingParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_FailingParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_FailingParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_FailingParser. ! 
	CombinatorialParsing_FailingParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_PredicateTokenParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' errMsg predicate')
	 classVariables: 'MixinMetadata_CombinatorialParsing_PredicateTokenParser EnclosingObjects_CombinatorialParsing_PredicateTokenParser')!
	(Delta mirrorFor: #CombinatorialParsing_PredicateTokenParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_PredicateTokenParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_PredicateTokenParser) comment: 'Parses a single token matching a given
predicate.'!
	! (Delta mirrorFor: #CombinatorialParsing_PredicateTokenParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_PredicateTokenParser_superInit_new 

super  new.

^ self.



! 
errMsg: errMsg_val errMsg := errMsg_val! 
  parse: input inContext: context ifError: blk 

|  token |

 token := input nextIfAbsent:[ 

 blk  value: self  errMsg value: input position - 1.

].

( self  predicate value: token) ifFalse:[ 

 blk  value: self  errMsg value: input position - 1.

].

^ token.



! 
errMsg ^errMsg! 
predicate ^predicate! 
  accept: pred errorMsg: err 

 self  predicate: pred.

 self  errMsg: err.

^ self.



! 
predicate: predicate_val predicate := predicate_val! 
 CombinatorialParsing_PredicateTokenParser_1_init 

 self predicate:nil.

 self errMsg:nil.

^ self.



! 
 new 

 self CombinatorialParsing_PredicateTokenParser_superInit_new.

 self CombinatorialParsing_PredicateTokenParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_PredicateTokenParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_PredicateTokenParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_PredicateTokenParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_PredicateTokenParser. ! 
	CombinatorialParsing_PredicateTokenParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_AlternatingParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' q0 p0 pfun qfun')
	 classVariables: 'MixinMetadata_CombinatorialParsing_AlternatingParser EnclosingObjects_CombinatorialParsing_AlternatingParser')!
	(Delta mirrorFor: #CombinatorialParsing_AlternatingParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_AlternatingParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_AlternatingParser) comment: 'A parser that parses either P or Q.'!
	! (Delta mirrorFor: #CombinatorialParsing_AlternatingParser) methodsFor: 'unclassified'!
	q0: q0_val q0 := q0_val! 
qfun: qfun_val qfun := qfun_val! 
pfun ^pfun! 
  combineErrors: e1 and: e2 at: pos with: blk 

|  or  msg |

 or :=( e1 =#'' or:[ 

 e2 =#''.

])  ifTrue:[ 

#''.

] ifFalse:[ 

' or '.

].

 e1 = e2  ifTrue:[ 

 msg := e1.

] ifFalse:[ 

 msg := e1 , or , e2.

].

^ blk  value: msg value: pos.



! 
 CombinatorialParsing_AlternatingParser_1_init 

 self p0:nil.

 self q0:nil.

 self pfun:nil.

 self qfun:nil.

^ self.



! 
p0: p0_val p0 := p0_val! 
pfun: pfun_val pfun := pfun_val! 
  either: pf1 or: pf2 

 self assert:[ 

 pf1 isBlock and:[ 

 pf2 isBlock.

].

].

 self  pfun: pf1.

 self  qfun: pf2.

^ self.



! 
qfun ^qfun! 
 p 

 self  p0 isNil ifTrue:[ 

 self  p0: self  pfun value.

].

^ self  p0.



! 
 q 

 self  q0 isNil ifTrue:[ 

 self  q0: self  qfun value.

].

^ self  q0.



! 
p0 ^p0! 
 CombinatorialParsing_AlternatingParser_superInit_new 

super  new.

^ self.



! 
q0 ^q0! 
  parse: input inContext: context ifError: blk 

|  pos |

 pos := input position.

^ self  p  parse: input inContext: context ifError:[ : msg1 : pos1 | 

|  result |

 input position: pos.

 context recordFailure:(( self Array new:2)  at:1 put: msg1; 

  at:2 put: pos1; 

 yourself).

 result := self  q  parse: input inContext: context ifError:[ : msg2 : pos2 | 

 context recordFailure:(( self Array new:2)  at:1 put: msg2; 

  at:2 put: pos2; 

 yourself).

 pos1 > pos2 ifTrue:[ 

^ blk  value: msg1 value: pos1.

].

 pos2 > pos1 ifTrue:[ 

^ blk  value: msg2 value: pos2.

].

^ self   combineErrors: msg1 and: msg2 at: pos1 with: blk.

].

^ result.

].



! 
 new 

 self CombinatorialParsing_AlternatingParser_superInit_new.

 self CombinatorialParsing_AlternatingParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_AlternatingParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_AlternatingParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_AlternatingParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_AlternatingParser. ! 
	CombinatorialParsing_AlternatingParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_CommentParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' termBlock')
	 classVariables: 'MixinMetadata_CombinatorialParsing_CommentParser EnclosingObjects_CombinatorialParsing_CommentParser')!
	(Delta mirrorFor: #CombinatorialParsing_CommentParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_CommentParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_CommentParser) comment: #''!
	! (Delta mirrorFor: #CombinatorialParsing_CommentParser) methodsFor: 'unclassified'!
	termBlock: termBlock_val termBlock := termBlock_val! 
 CombinatorialParsing_CommentParser_1_init 

 self termBlock:nil.

^ self.



! 
termBlock ^termBlock! 
 CombinatorialParsing_CommentParser_superInit_new 

super  new.

^ self.



! 
  parse: input inContext: context ifError: blk 

[ 

 self  termBlock value: input.

] whileFalse:[ 

 input nextIfAbsent:[ 

 blk  value:'Premature end of input' value: input position - 1.

].

].

^ self.



! 
 new 

 self CombinatorialParsing_CommentParser_superInit_new.

 self CombinatorialParsing_CommentParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_CommentParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_CommentParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_CommentParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_CommentParser. ! 
	CombinatorialParsing_CommentParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_ParserError as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' position message')
	 classVariables: 'MixinMetadata_CombinatorialParsing_ParserError EnclosingObjects_CombinatorialParsing_ParserError')!
	(Delta mirrorFor: #CombinatorialParsing_ParserError) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_ParserError) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_ParserError) comment: #''!
	! (Delta mirrorFor: #CombinatorialParsing_ParserError) methodsFor: 'unclassified'!
	 CombinatorialParsing_ParserError_1_init 

 self message:nil.

 self position:nil.

^ self.



! 
position ^position! 
position: position_val position := position_val! 
 CombinatorialParsing_ParserError_superInit_new 

super  new.

^ self.



! 
message ^message! 
message: message_val message := message_val! 
 new 

 self CombinatorialParsing_ParserError_superInit_new.

 self CombinatorialParsing_ParserError_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_ParserError) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_ParserError := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_ParserError := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_ParserError. ! 
	CombinatorialParsing_ParserError metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_StarParser as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' p')
	 classVariables: 'MixinMetadata_CombinatorialParsing_StarParser EnclosingObjects_CombinatorialParsing_StarParser')!
	(Delta mirrorFor: #CombinatorialParsing_StarParser) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_StarParser) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_StarParser) comment: 'An attempt to optimize the * operator by having a dedicated parser for it.'!
	! (Delta mirrorFor: #CombinatorialParsing_StarParser) methodsFor: 'unclassified'!
	 CombinatorialParsing_StarParser_1_init 

 self p:nil.

^ self.



! 
p ^p! 
p: p_val p := p_val! 
  parse: input inContext: context ifError: blk 

|  currentPos  results  nextResult |

 results := (EnclosingObjects_CombinatorialParsing_StarParser at: 1)  OrderedCollection new.

[ 

true.

] whileTrue:[ 

 currentPos := input position.

 nextResult := self  p  parse: input inContext: context ifError:[ : msg : pos | 

 input position: currentPos.

^ results.

].

 results add: nextResult.

].

^ self.



! 
 CombinatorialParsing_StarParser_superInit_new 

super  new.

^ self.



! 
 new 

 self CombinatorialParsing_StarParser_superInit_new.

 self CombinatorialParsing_StarParser_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_StarParser) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_StarParser := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_StarParser := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_StarParser. ! 
	CombinatorialParsing_StarParser metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_Token as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' end start token')
	 classVariables: 'MixinMetadata_CombinatorialParsing_Token EnclosingObjects_CombinatorialParsing_Token')!
	(Delta mirrorFor: #CombinatorialParsing_Token) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_Token) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_Token) comment: 'Represents a token of input. Basically, it attaches a start position
to the token''s value. Indeally, we''d use a tuple for this, which is why this class
implements the tuple protocol. We could use an array, but that would not be 
typesafe. Until we have tuples, we''ll use this class.

It''s not yet clear if we should bother adding token codes or values here.'!
	! (Delta mirrorFor: #CombinatorialParsing_Token) methodsFor: 'unclassified'!
	 at: n 

 self assert:[ 

 n <=2.

].

 n =1 ifTrue:[ 

^ self  token.

].

^ self  start.



! 
 CombinatorialParsing_Token_1_init 

 self token:nil.

 self start:nil.

 self end:nil.

^ self.



! 
 at1 

^ self  token.



! 
 CombinatorialParsing_Token_superInit_new 

super  new.

^ self.



! 
end ^end! 
start ^start! 
  for: t start: p end: e 

 self  token: t.

 self  start: p.

 self  end: e.

^ self.



! 
 at2 

^ self  start.



! 
 new 

 self CombinatorialParsing_Token_superInit_new.

 self CombinatorialParsing_Token_1_init.

^ self.



! 
start: start_val start := start_val! 
 fst 

^ self  start.



! 
 concreteStart 

^ self  start.



! 
end: end_val end := end_val! 
 snd 

^ self  token.



! 
token: token_val token := token_val! 
token ^token! 
 concreteEnd 

^ self  end.



! 
  for: t start: p 

 self  token: t.

 self  start: p.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_Token) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_Token := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_Token := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_Token. ! 
	CombinatorialParsing_Token metadata enclosingMixin: CombinatorialParsing !
	Delta define: #CombinatorialParsing_ParserContext as: (
	(Class subclassOf: 'NewspeakObject' instanceVariables:' failures')
	 classVariables: 'MixinMetadata_CombinatorialParsing_ParserContext EnclosingObjects_CombinatorialParsing_ParserContext')!
	(Delta mirrorFor: #CombinatorialParsing_ParserContext) revision: '$Revision: 0.0 $'!
	(Delta mirrorFor: #CombinatorialParsing_ParserContext) group: 'newspeak'!
	(Delta mirrorFor: #CombinatorialParsing_ParserContext) comment: 'This class defines a context that is shared among a set of combinatorial parsers during a parse. The context can be used to manage information on parsing errors: rather than always report the latest failure that occurred, we can report the one that occurred deepest in the input stream, or implement some other policy - as long as we can record what failures took place.

In addition, this class could be used to support context-sensitive parsing. 
'!
	! (Delta mirrorFor: #CombinatorialParsing_ParserContext) methodsFor: 'unclassified'!
	 errorPosition 

 self  failures isEmpty ifTrue:[ 

^-1.

].

^ self  failures last last.



! 
 CombinatorialParsing_ParserContext_superInit_new 

super  new.

^ self.



! 
 recordFailure: f 

( self  failures isEmpty or:[ 

 self  failures last last <= f last.

]) ifTrue:[ 

 self  failures addLast: f.

].

^ self.



! 
 CombinatorialParsing_ParserContext_1_init 

 self failures: (EnclosingObjects_CombinatorialParsing_ParserContext at: 1)  OrderedCollection new.

^ self.



! 
failures: failures_val failures := failures_val! 
 errorMessage 

 self  failures isEmpty ifTrue:[ 

^#''.

].

^ self  failures last first.



! 
failures ^failures! 
 new 

 self CombinatorialParsing_ParserContext_superInit_new.

 self CombinatorialParsing_ParserContext_1_init.

^ self.



! 
 !
	! (Delta mirrorFor: #CombinatorialParsing_ParserContext) classSide methodsFor: 'unclassified'!
	enclosingObjects: eos EnclosingObjects_CombinatorialParsing_ParserContext := eos !
	mixinMetadata: mmd MixinMetadata_CombinatorialParsing_ParserContext := mmd !
	 new 

^ self basicNew new.



! 
		 !
	CombinatorialParsing metadata addNestedClass: CombinatorialParsing_ParserContext. ! 
	CombinatorialParsing_ParserContext metadata enclosingMixin: CombinatorialParsing !
	