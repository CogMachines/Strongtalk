/* Copyright 1994, 1995 LongView Technologies L.L.C. $Revision: 1.7 $ */

class weakArrayKlass: public objArrayKlass {
 public:   
  friend void set_weakArrayKlass_vtbl(Klass* k);

  char* name() const { return "weakArray"; }

  // creates invocation
  klassOop create_subclass(mixinOop mixin, Format format);

  static klassOop create_class(klassOop super_class, mixinOop mixin);

  // Format
  Format format() { return weakArray_klass; }

  // ALL FUNCTIONS BELOW THIS POINT ARE DISPATCHED FROM AN OOP 

  // memory operations
  int  oop_scavenge_contents(oop obj);
  int  oop_scavenge_tenured_contents(oop obj);
  void oop_follow_contents(oop obj);

  // testers
  bool oop_is_weakArray() const { return true; }

  // iterators
  void oop_oop_iterate(oop obj, OopClosure* blk);
  void oop_layout_iterate(oop obj, ObjectLayoutClosure* blk);

  // Sizing
  int oop_header_size() const { return weakArrayOopDesc::header_size(); }
};

// The weak array register is used during memory management to
// split the object scanning into two parts:
//   1. Transively traverse all object except the indexable part
//      of weakArrays. Then a weakArray is encountered it is registered
//   2. Using the registered weakArrays continue the transitive traverse.
// Inbetween we can easily compute the set of object with a
// near death experience.
//
// Scavenge and Mark Sweep use to disjunct parts of the interface.

// Implementation note:
//  During phase1 of Mark Sweep pointers are reversed and a objects 
//  structure cannot be used (the klass pointer is gone). This makes
//  it necessary to register weakArrays along with their non indexable sizes.
//  'nis' contains the non indexable sizes.

// Interface for weak array support
class WeakArrayRegister : AllStatic {
 public:
  // Scavenge interface
  static void begin_scavenge();
  static bool scavenge_register(weakArrayOop obj);
  static void check_and_scavenge_contents();

  // Mark sweep interface
  static void begin_mark_sweep();
  static bool mark_sweep_register(weakArrayOop obj, int non_indexable_size);
  static void check_and_follow_contents();

 private:
  // Variables
  static bool                         during_registration;
  static GrowableArray<weakArrayOop>* weakArrays;
  static GrowableArray<int>*          nis;

  // Scavenge operations
  static void scavenge_contents();
  static inline bool scavenge_is_near_death(oop obj);
  static void scavenge_check_for_dying_objects();

  // Mark sweep operations
  static void follow_contents();
  static inline bool mark_sweep_is_near_death(oop obj);
  static void mark_sweep_check_for_dying_objects();
};

// The NotificationQueue holds references to weakArrays
// containing object with a near death experience.
class NotificationQueue : AllStatic {
 public:
  // Queue operations
  static void mark_elements();   // Marks all elements as queued (by using the sentinel bit)
  static void clear_elements();  // Reset the sentinel bit

  static bool is_empty();
  static oop  get();
  static void put(oop obj);
  static void put_if_absent(oop obj);

  // Memory management
  static void oops_do(void f(oop*));
 private:
  static oop* array;
  static int size;  
  static int first;
  static int last;
  static int succ(int index);
};
