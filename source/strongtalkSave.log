
"October 17, 2006 -> 14:36:48"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutBodyOn: stream <WriteStream> ^ <Int>

	| pos <Int> sortedCategories <Cltn[Str]> |
	pos := stream position.
	sortedCategories := self mirror sourceInfo categories asSortedCollection: 
			[ :s <Str> :s2 <Str> | s  <= s2  ]
	 do: [ :cat <Str> | 
		self fileOutCategory: cat on: stream ].
	^pos! !

"October 17, 2006 -> 14:37:7"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutBodyOn: stream <WriteStream> ^ <Int>

	| pos <Int> sortedCategories <Cltn[Str]> |
	pos := stream position.
	sortedCategories := self mirror sourceInfo categories asSortedCollection: 
			[ :s <Str> :s2 <Str> | s  <= s2  ].
	sortedCategories do: [ :cat <Str> | 
		self fileOutCategory: cat on: stream ].
	^pos! !

"October 17, 2006 -> 14:40:57"!

"System saved" !
"June 2, 2007 -> 20:46:56"!

"System saved" !
"June 4, 2007 -> 1:26:52"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

Delta define: #InstanceVariableOutliner as: (
(Class subclassOf: 'DefinitionItemOutliner' instanceVariables: '')) !


"June 4, 2007 -> 1:26:54"!

(Delta mirrorFor: #InstanceVariableOutliner)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 4, 2007 -> 1:26:55"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
aspectForUpdate ^ <Symbol>

	^#instanceVariables
! !

"June 4, 2007 -> 1:26:56"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
header ^ <Str>

	^'Instance variables'! !

"June 4, 2007 -> 1:26:57"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
modelAsCharGlyphs ^ <CharGlyphs>

	| tool <ASTtoRichTextTool[CharGlyph]> pts <Cltn[ParseTree]> |
	self useRichTextForSources
		ifTrue: [
			pts := DeltaParser new
							parseInstVarList: self mirror instanceVariableString 
							within: (DeltaScope within: nil)
							ifError: [ :msg <Str> :pos <Int> | self shouldNotHappen ].
			^pts isEmpty
				ifTrue: [ 		OrderedCollection[CharGlyphs] new ]
				ifFalse: [ 	self richTextForParseTrees: pts ] ]
		ifFalse: [
			^self standardTextForString: self mirror instanceVariableString painter: self codePainter ]

! !

"June 4, 2007 -> 1:26:58"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'private' !
storeAndOnSuccess: blk <[]>

	"The right way to do this is to have a #instanceVariables:ifFail: in ClassMirror and MixinDeclMirror
		that will parse and	update accordingly.
		
		In the meantime, we parse an extra time here to check for errors and call #instanceVariables: afterwards.
		This should be changed shortly."
		
	| ivs <Str> eval <Str> constructor <Mirror> |
	self deltaHack.
	ivs := self charGlyphModelAsString: self codeView.
	DeltaParser new 
		parseInstVarList: ivs
		within: (DeltaScope within: nil)
		ifError: [ :msg <Str> :pos <Int> | ^self showParseError: msg at: pos in: self codeView ].
	self mirror instanceVariables: ivs.
	blk value.
! !

"June 4, 2007 -> 1:26:59"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'typechecking' !
typecheck

self typecheckAction:[self mirror typecheckInstVars]
		title: 'Typechecking ', self mirror name, ' instance variables'.! !

"June 4, 2007 -> 1:27:0"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'accessing' !
locator ^ <ClassVarLocator>

^InstVarLocator ofDefinition: self mirror basicLocator! !

"June 4, 2007 -> 1:27:1"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
hasMenu ^<Boolean>

	^true! !

"June 4, 2007 -> 1:27:2"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'menus' !
menuBar ^<Menu>

	^Menu new
		add: (MenuAction new
					name: 'References...';
					action: [ self referencesToInstVar ])
! !

"June 4, 2007 -> 1:27:3"!

! (Delta mirrorFor: #InstanceVariableOutliner) methodsFor: 'control' !
referencesToInstVar
! !

"June 4, 2007 -> 1:28:33"!

"System saved" !
"June 4, 2007 -> 1:31:2"!

"System saved" !
"June 4, 2007 -> 1:37:50"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 4, 2007 -> 1:37:50"!

(Delta mirrorFor: #Win32Platform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 4, 2007 -> 1:37:52"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 4, 2007 -> 1:37:53"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 4, 2007 -> 1:37:54"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 4, 2007 -> 1:37:55"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 4, 2007 -> 1:37:55"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 4, 2007 -> 1:37:56"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 4, 2007 -> 1:37:57"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    | line <Str> args <VarOrdCltn[Str]> strm <CharInputStream> |
    line := self getCommandLine.
    args := OrderedCollection[Str] new.
    strm := line readStream.

    [   "skip whitespace"
        [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
        strm atEnd ] whileFalse: [
            args addLast: (self parseArgFrom: strm).        ].
    ^args! !

"June 4, 2007 -> 1:37:58"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
getCommandLine
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 4, 2007 -> 1:37:59"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 4, 2007 -> 1:38:0"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 4, 2007 -> 1:38:1"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 4, 2007 -> 1:38:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 4, 2007 -> 1:38:3"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 4, 2007 -> 1:38:4"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 4, 2007 -> 1:38:5"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 4, 2007 -> 1:38:6"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 4, 2007 -> 1:38:7"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 4, 2007 -> 1:38:8"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 1:38:9"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 1:38:10"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 1:38:11"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 1:38:12"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 4, 2007 -> 1:48:31"!

"System saved" !
"June 4, 2007 -> 2:36:39"!

Delta define: #UnixPlatform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 4, 2007 -> 2:36:39"!

(Delta mirrorFor: #UnixPlatform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 4, 2007 -> 2:36:40"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 4, 2007 -> 2:36:41"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 4, 2007 -> 2:36:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 4, 2007 -> 2:36:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 4, 2007 -> 2:36:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 4, 2007 -> 2:36:44"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 4, 2007 -> 2:36:45"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    | line <Str> args <VarOrdCltn[Str]> strm <CharInputStream> |
    line := self getCommandLine.
    args := OrderedCollection[Str] new.
    strm := line readStream.

    [   "skip whitespace"
        [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
        strm atEnd ] whileFalse: [
            args addLast: (self parseArgFrom: strm).        ].
    ^args! !

"June 4, 2007 -> 2:36:46"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 4, 2007 -> 2:36:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 4, 2007 -> 2:36:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 4, 2007 -> 2:36:48"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 4, 2007 -> 2:36:49"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 4, 2007 -> 2:36:50"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 4, 2007 -> 2:36:51"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 4, 2007 -> 2:36:52"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 4, 2007 -> 2:36:53"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 4, 2007 -> 2:36:54"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 4, 2007 -> 2:36:55"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 2:36:55"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 4, 2007 -> 2:36:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 2:36:58"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 4, 2007 -> 2:36:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>

    ^strm peek = $"
        ifTrue: [       strm next.
                        strm upTo: $"   ]
        ifFalse: [  strm upTo: Character space ]! !

"June 4, 2007 -> 2:38:38"!

"System saved" !
"June 4, 2007 -> 19:11:14"!

"System saved" !
"June 5, 2007 -> 2:15:5"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }}! !

"June 5, 2007 -> 2:16:16"!

"System saved" !
"June 5, 2007 -> 2:21:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getArguments ^<OrdCltn[Str]>

    ^ {{ primitiveCommandLineArgs }} asOrderedCollection
    	collect: [:bytes| bytes asString]! !

"June 5, 2007 -> 2:25:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := WriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg]
    	separatedBy: [stream nextPut: $ ].
    ^stream contents! !

"June 5, 2007 -> 2:33:27"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg]
    	separatedBy: [stream nextPut: $ ].
    ^stream contents! !

"June 5, 2007 -> 2:41:14"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to stream size - 1! !

"June 5, 2007 -> 2:42:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
getCommandLine
    | stream |
    stream := CharacterReadWriteStream on: ''.
    self getArguments do: [:arg| stream nextPutAll: arg; space].
    stream isEmpty ifTrue: [^''].
    ^stream copyFrom: 1 to: stream size - 1! !

"June 5, 2007 -> 2:44:40"!

"System saved" !
"June 5, 2007 -> 21:6:39"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:6:39"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 5, 2007 -> 21:6:40"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 5, 2007 -> 21:6:41"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 5, 2007 -> 21:6:42"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 5, 2007 -> 21:6:42"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 5, 2007 -> 21:6:43"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 5, 2007 -> 21:6:44"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 5, 2007 -> 21:6:45"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 5, 2007 -> 21:6:46"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 5, 2007 -> 21:7:0"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:2"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:7:3"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:7:3"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:4"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:5"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:7:6"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 5, 2007 -> 21:7:6"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 5, 2007 -> 21:7:7"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 5, 2007 -> 21:7:8"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 5, 2007 -> 21:7:9"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 5, 2007 -> 21:7:10"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 5, 2007 -> 21:7:25"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:28"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:29"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:29"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:30"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:30"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:31"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:7:32"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 5, 2007 -> 21:7:34"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 5, 2007 -> 21:7:35"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 5, 2007 -> 21:7:36"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:7:37"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 5, 2007 -> 21:7:38"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 5, 2007 -> 21:7:39"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 5, 2007 -> 21:7:40"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 5, 2007 -> 21:7:41"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 5, 2007 -> 21:7:42"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 5, 2007 -> 21:7:43"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 5, 2007 -> 21:7:44"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 5, 2007 -> 21:7:44"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 5, 2007 -> 21:7:45"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 5, 2007 -> 21:7:46"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 5, 2007 -> 21:7:47"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 5, 2007 -> 21:7:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 5, 2007 -> 21:7:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 21:7:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 21:7:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 5, 2007 -> 21:7:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 21:7:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 5, 2007 -> 21:7:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 5, 2007 -> 21:7:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 21:7:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 21:7:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 5, 2007 -> 21:7:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 5, 2007 -> 21:7:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 5, 2007 -> 21:8:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 5, 2007 -> 21:8:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 21:8:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 5, 2007 -> 21:8:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 21:8:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 5, 2007 -> 21:8:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 5, 2007 -> 21:8:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 21:8:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 21:8:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 21:8:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 21:8:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 21:8:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:8:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 5, 2007 -> 21:8:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 5, 2007 -> 21:8:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 21:8:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 21:8:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 5, 2007 -> 21:8:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 21:8:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 21:8:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 21:8:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 21:8:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 21:8:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 5, 2007 -> 21:8:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 21:8:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 21:8:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 21:8:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 21:8:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 21:8:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 21:8:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 21:8:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 5, 2007 -> 21:8:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 21:8:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 21:8:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 21:8:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 21:8:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 21:8:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 21:8:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 21:8:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 21:8:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 5, 2007 -> 21:8:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 5, 2007 -> 21:8:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 5, 2007 -> 21:8:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 5, 2007 -> 21:8:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 5, 2007 -> 21:8:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:8:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 5, 2007 -> 21:8:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:8:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 5, 2007 -> 21:8:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 5, 2007 -> 21:8:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 5, 2007 -> 21:8:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 5, 2007 -> 21:8:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 5, 2007 -> 21:8:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 5, 2007 -> 21:9:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 5, 2007 -> 21:9:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 5, 2007 -> 21:9:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 5, 2007 -> 21:9:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 5, 2007 -> 21:9:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 5, 2007 -> 21:9:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 5, 2007 -> 21:9:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 21:9:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 5, 2007 -> 21:10:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 5, 2007 -> 21:10:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 5, 2007 -> 21:10:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 5, 2007 -> 21:10:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 5, 2007 -> 21:10:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 5, 2007 -> 21:10:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 5, 2007 -> 21:10:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 21:10:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 5, 2007 -> 21:10:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 5, 2007 -> 21:10:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 5, 2007 -> 21:10:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 5, 2007 -> 21:10:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 5, 2007 -> 21:10:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 5, 2007 -> 21:10:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 5, 2007 -> 21:10:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 5, 2007 -> 21:10:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 5, 2007 -> 21:10:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 5, 2007 -> 21:10:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 5, 2007 -> 21:10:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 21:10:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 5, 2007 -> 21:10:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 21:10:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 21:10:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 5, 2007 -> 21:10:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 21:10:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 21:10:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 5, 2007 -> 21:10:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 5, 2007 -> 21:14:43"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:45"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:46"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:46"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:47"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:48"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:49"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:49"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:50"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:50"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:51"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 21:14:52"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 5, 2007 -> 21:14:54"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 5, 2007 -> 21:14:55"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 5, 2007 -> 21:14:56"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 5, 2007 -> 21:14:57"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 5, 2007 -> 21:14:58"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 5, 2007 -> 21:14:59"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 5, 2007 -> 21:15:0"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 5, 2007 -> 21:15:1"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 5, 2007 -> 21:15:2"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 5, 2007 -> 21:15:3"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 5, 2007 -> 21:15:4"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 5, 2007 -> 21:15:5"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 5, 2007 -> 21:15:6"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 5, 2007 -> 21:15:7"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 5, 2007 -> 21:15:9"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 5, 2007 -> 21:15:10"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 5, 2007 -> 21:15:11"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 21:15:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 5, 2007 -> 21:15:13"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 5, 2007 -> 21:15:15"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 5, 2007 -> 21:15:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 5, 2007 -> 21:15:17"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 5, 2007 -> 21:15:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 5, 2007 -> 21:15:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 5, 2007 -> 21:15:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 5, 2007 -> 21:15:21"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 5, 2007 -> 21:15:23"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 5, 2007 -> 21:15:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 5, 2007 -> 21:15:25"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 5, 2007 -> 21:15:27"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 5, 2007 -> 21:15:28"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 5, 2007 -> 21:15:29"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 21:15:30"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 21:15:31"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 5, 2007 -> 21:15:32"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 21:15:34"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 21:15:35"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 5, 2007 -> 21:15:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 5, 2007 -> 21:15:37"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 5, 2007 -> 21:15:38"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 21:15:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 5, 2007 -> 21:15:41"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 5, 2007 -> 21:15:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 5, 2007 -> 21:15:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 5, 2007 -> 21:15:44"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 5, 2007 -> 21:15:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 5, 2007 -> 21:15:47"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 5, 2007 -> 21:15:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 5, 2007 -> 21:15:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 5, 2007 -> 21:15:50"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 5, 2007 -> 21:15:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 5, 2007 -> 21:15:52"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 5, 2007 -> 21:15:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 21:15:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 21:15:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 5, 2007 -> 21:15:58"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 5, 2007 -> 21:15:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 21:16:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 21:16:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 5, 2007 -> 21:16:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 21:16:3"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 5, 2007 -> 21:16:5"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 5, 2007 -> 21:16:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 21:16:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 21:16:8"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 5, 2007 -> 21:16:10"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 5, 2007 -> 21:16:11"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 21:16:12"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 5, 2007 -> 21:16:13"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 5, 2007 -> 21:16:14"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 5, 2007 -> 21:16:16"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 5, 2007 -> 21:16:17"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 5, 2007 -> 21:16:18"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 5, 2007 -> 21:16:19"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 5, 2007 -> 21:16:20"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 5, 2007 -> 21:16:22"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 5, 2007 -> 21:16:23"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 5, 2007 -> 21:16:24"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 5, 2007 -> 21:16:26"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 5, 2007 -> 21:16:27"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 5, 2007 -> 21:16:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 5, 2007 -> 21:16:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 5, 2007 -> 21:16:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 5, 2007 -> 21:16:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 21:16:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 5, 2007 -> 21:16:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 21:16:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 21:16:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 5, 2007 -> 21:16:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 21:16:43"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 21:16:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 5, 2007 -> 21:16:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 5, 2007 -> 21:16:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 5, 2007 -> 21:16:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 21:16:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 21:16:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 5, 2007 -> 21:16:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 5, 2007 -> 21:16:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 21:17:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 5, 2007 -> 21:17:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 5, 2007 -> 21:17:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 5, 2007 -> 21:17:17"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 5, 2007 -> 21:17:18"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:17:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 5, 2007 -> 21:17:21"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 5, 2007 -> 21:17:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 5, 2007 -> 21:17:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 5, 2007 -> 21:17:24"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 5, 2007 -> 21:17:26"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 5, 2007 -> 21:17:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 5, 2007 -> 21:17:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 5, 2007 -> 21:17:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 21:17:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 5, 2007 -> 21:17:33"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 21:17:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 21:17:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 5, 2007 -> 21:17:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 21:17:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 21:17:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 5, 2007 -> 21:17:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 21:17:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 5, 2007 -> 21:17:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 5, 2007 -> 21:17:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 5, 2007 -> 21:17:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 5, 2007 -> 21:17:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 21:17:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 5, 2007 -> 21:17:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 5, 2007 -> 21:17:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 5, 2007 -> 21:17:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 21:17:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 5, 2007 -> 21:17:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 5, 2007 -> 21:17:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 5, 2007 -> 21:17:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 5, 2007 -> 21:17:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 21:17:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 5, 2007 -> 21:17:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 5, 2007 -> 21:18:0"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 5, 2007 -> 21:18:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 5, 2007 -> 21:18:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 5, 2007 -> 21:18:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 5, 2007 -> 21:18:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 5, 2007 -> 21:18:7"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 5, 2007 -> 21:18:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 21:18:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 21:18:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 21:18:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 21:18:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 5, 2007 -> 21:18:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 21:18:16"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 21:18:17"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 5, 2007 -> 21:18:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 5, 2007 -> 21:18:20"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 21:18:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 5, 2007 -> 21:18:23"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 5, 2007 -> 21:18:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 5, 2007 -> 21:18:25"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 5, 2007 -> 21:18:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 5, 2007 -> 21:18:28"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 5, 2007 -> 21:18:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 5, 2007 -> 21:18:30"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 5, 2007 -> 21:18:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 5, 2007 -> 21:18:32"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 21:18:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 21:18:35"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 5, 2007 -> 21:18:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 21:18:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 5, 2007 -> 21:18:38"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 21:18:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 21:18:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 5, 2007 -> 21:18:42"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:43"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 5, 2007 -> 21:18:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 5, 2007 -> 21:18:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 5, 2007 -> 21:18:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:18:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 5, 2007 -> 21:18:50"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 21:18:52"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 5, 2007 -> 21:18:53"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 5, 2007 -> 21:18:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 5, 2007 -> 21:18:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 5, 2007 -> 21:18:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:18:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 5, 2007 -> 21:19:0"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 5, 2007 -> 21:19:1"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 5, 2007 -> 21:19:3"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 5, 2007 -> 21:19:4"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:19:5"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 5, 2007 -> 21:19:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 5, 2007 -> 21:19:8"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 5, 2007 -> 21:19:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 21:19:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:19:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 5, 2007 -> 21:19:49"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 5, 2007 -> 21:27:17"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:19"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 21:27:20"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:27:23"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 5, 2007 -> 21:27:24"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 5, 2007 -> 21:27:25"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 5, 2007 -> 21:27:26"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 5, 2007 -> 21:27:27"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 5, 2007 -> 21:27:28"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 5, 2007 -> 21:27:29"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 5, 2007 -> 21:27:30"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 5, 2007 -> 21:27:31"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 5, 2007 -> 21:27:32"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 5, 2007 -> 21:27:33"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 5, 2007 -> 21:41:46"!

"System saved" !
"June 5, 2007 -> 21:58:16"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:16"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 5, 2007 -> 21:58:18"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 5, 2007 -> 21:58:18"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 5, 2007 -> 21:58:19"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 5, 2007 -> 21:58:20"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 5, 2007 -> 21:58:21"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 5, 2007 -> 21:58:22"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 5, 2007 -> 21:58:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 5, 2007 -> 21:58:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 5, 2007 -> 21:58:49"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:51"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 5, 2007 -> 21:58:52"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 21:58:52"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:53"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:54"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 5, 2007 -> 21:58:55"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 5, 2007 -> 21:58:55"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 5, 2007 -> 21:58:56"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 5, 2007 -> 21:58:57"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 5, 2007 -> 21:58:58"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 5, 2007 -> 21:58:59"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 5, 2007 -> 21:59:46"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:48"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:49"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:50"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:50"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:51"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:52"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 5, 2007 -> 21:59:53"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 5, 2007 -> 21:59:55"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 5, 2007 -> 21:59:56"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 5, 2007 -> 21:59:57"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 21:59:58"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 5, 2007 -> 21:59:59"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 5, 2007 -> 22:0:0"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 5, 2007 -> 22:0:1"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 5, 2007 -> 22:0:2"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 5, 2007 -> 22:0:3"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 5, 2007 -> 22:0:6"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 5, 2007 -> 22:0:9"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 5, 2007 -> 22:0:10"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 5, 2007 -> 22:0:12"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 5, 2007 -> 22:0:14"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 5, 2007 -> 22:0:15"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 5, 2007 -> 22:0:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 5, 2007 -> 22:0:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 22:0:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 22:0:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 5, 2007 -> 22:0:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 22:0:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 5, 2007 -> 22:0:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 5, 2007 -> 22:0:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 22:0:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 22:0:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 5, 2007 -> 22:0:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 5, 2007 -> 22:0:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 5, 2007 -> 22:0:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 5, 2007 -> 22:0:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 5, 2007 -> 22:0:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 5, 2007 -> 22:0:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 5, 2007 -> 22:0:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 5, 2007 -> 22:0:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 5, 2007 -> 22:0:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 22:1:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 22:1:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 22:1:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 22:1:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 22:1:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:1:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 5, 2007 -> 22:1:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 5, 2007 -> 22:1:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 22:1:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 22:1:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 5, 2007 -> 22:1:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 22:1:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 22:1:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 22:1:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 22:1:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 22:1:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 5, 2007 -> 22:1:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 22:1:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 22:1:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 22:1:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 22:1:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 22:1:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 22:1:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 22:1:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 5, 2007 -> 22:1:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 22:1:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 22:1:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 22:1:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 22:1:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 22:1:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 22:1:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 22:1:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 22:1:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 5, 2007 -> 22:1:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 5, 2007 -> 22:1:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 5, 2007 -> 22:1:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 5, 2007 -> 22:1:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 5, 2007 -> 22:1:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:1:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 5, 2007 -> 22:1:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:1:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 5, 2007 -> 22:1:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 5, 2007 -> 22:1:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 5, 2007 -> 22:1:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 5, 2007 -> 22:1:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 5, 2007 -> 22:1:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 5, 2007 -> 22:1:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 5, 2007 -> 22:2:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 5, 2007 -> 22:2:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 5, 2007 -> 22:2:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 5, 2007 -> 22:2:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 5, 2007 -> 22:2:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 5, 2007 -> 22:2:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 22:2:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 5, 2007 -> 22:2:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 5, 2007 -> 22:2:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 5, 2007 -> 22:2:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 5, 2007 -> 22:2:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 5, 2007 -> 22:2:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 5, 2007 -> 22:2:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 5, 2007 -> 22:2:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 22:2:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 5, 2007 -> 22:2:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 5, 2007 -> 22:2:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 5, 2007 -> 22:2:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 5, 2007 -> 22:2:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 5, 2007 -> 22:2:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 5, 2007 -> 22:2:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 5, 2007 -> 22:2:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 5, 2007 -> 22:2:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 5, 2007 -> 22:2:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 5, 2007 -> 22:2:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 5, 2007 -> 22:2:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 22:2:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 5, 2007 -> 22:2:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 5, 2007 -> 22:2:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 5, 2007 -> 22:2:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 5, 2007 -> 22:2:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 22:2:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 22:2:35"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 5, 2007 -> 22:2:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 5, 2007 -> 22:2:51"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:53"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:54"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:56"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:2:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 5, 2007 -> 22:3:0"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 5, 2007 -> 22:3:2"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 5, 2007 -> 22:3:3"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 5, 2007 -> 22:3:4"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 5, 2007 -> 22:3:5"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 5, 2007 -> 22:3:6"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 5, 2007 -> 22:3:7"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 5, 2007 -> 22:3:8"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 5, 2007 -> 22:3:9"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 5, 2007 -> 22:3:10"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 5, 2007 -> 22:3:11"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 5, 2007 -> 22:3:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 5, 2007 -> 22:3:13"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 5, 2007 -> 22:3:14"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 5, 2007 -> 22:3:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 5, 2007 -> 22:3:17"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 5, 2007 -> 22:3:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 5, 2007 -> 22:3:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 5, 2007 -> 22:3:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 5, 2007 -> 22:3:22"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 5, 2007 -> 22:3:23"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 5, 2007 -> 22:3:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 5, 2007 -> 22:3:25"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 5, 2007 -> 22:3:26"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 5, 2007 -> 22:3:28"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 5, 2007 -> 22:3:29"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 5, 2007 -> 22:3:30"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 5, 2007 -> 22:3:31"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 5, 2007 -> 22:3:32"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 5, 2007 -> 22:3:34"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 5, 2007 -> 22:3:35"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 5, 2007 -> 22:3:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 5, 2007 -> 22:3:37"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 5, 2007 -> 22:3:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 5, 2007 -> 22:3:40"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 5, 2007 -> 22:3:41"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 5, 2007 -> 22:3:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 5, 2007 -> 22:3:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 5, 2007 -> 22:3:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 5, 2007 -> 22:3:46"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 5, 2007 -> 22:3:47"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 5, 2007 -> 22:3:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 5, 2007 -> 22:3:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 5, 2007 -> 22:3:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 5, 2007 -> 22:3:52"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 5, 2007 -> 22:3:53"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 5, 2007 -> 22:3:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 5, 2007 -> 22:3:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 5, 2007 -> 22:3:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 5, 2007 -> 22:3:57"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 5, 2007 -> 22:3:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 5, 2007 -> 22:4:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 5, 2007 -> 22:4:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 5, 2007 -> 22:4:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 5, 2007 -> 22:4:3"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 5, 2007 -> 22:4:4"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 5, 2007 -> 22:4:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 5, 2007 -> 22:4:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 5, 2007 -> 22:4:8"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 5, 2007 -> 22:4:10"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 5, 2007 -> 22:4:11"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 5, 2007 -> 22:4:12"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 5, 2007 -> 22:4:13"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 5, 2007 -> 22:4:14"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 5, 2007 -> 22:4:15"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 5, 2007 -> 22:4:17"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 5, 2007 -> 22:4:18"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 5, 2007 -> 22:4:19"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 5, 2007 -> 22:4:21"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 5, 2007 -> 22:4:22"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 5, 2007 -> 22:4:23"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 5, 2007 -> 22:4:24"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 5, 2007 -> 22:4:25"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 5, 2007 -> 22:4:27"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 5, 2007 -> 22:4:28"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 5, 2007 -> 22:4:29"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 5, 2007 -> 22:4:31"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 5, 2007 -> 22:4:32"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 5, 2007 -> 22:4:33"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 5, 2007 -> 22:4:34"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 5, 2007 -> 22:4:36"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 5, 2007 -> 22:4:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 5, 2007 -> 22:4:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 5, 2007 -> 22:4:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 5, 2007 -> 22:4:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 22:4:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 5, 2007 -> 22:4:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 22:4:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 5, 2007 -> 22:4:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 5, 2007 -> 22:4:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 5, 2007 -> 22:4:48"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 5, 2007 -> 22:4:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 5, 2007 -> 22:4:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 5, 2007 -> 22:4:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 5, 2007 -> 22:4:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 22:4:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 5, 2007 -> 22:4:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 5, 2007 -> 22:4:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 5, 2007 -> 22:4:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 5, 2007 -> 22:4:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 5, 2007 -> 22:5:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 5, 2007 -> 22:5:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 5, 2007 -> 22:5:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 5, 2007 -> 22:5:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:5:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 5, 2007 -> 22:5:7"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 5, 2007 -> 22:5:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 5, 2007 -> 22:5:10"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 5, 2007 -> 22:5:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 5, 2007 -> 22:5:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 5, 2007 -> 22:5:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 5, 2007 -> 22:5:16"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 5, 2007 -> 22:5:18"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 5, 2007 -> 22:5:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 5, 2007 -> 22:5:20"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 22:5:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 5, 2007 -> 22:5:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 5, 2007 -> 22:5:24"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 5, 2007 -> 22:5:25"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 5, 2007 -> 22:5:27"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 5, 2007 -> 22:5:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 5, 2007 -> 22:5:29"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 5, 2007 -> 22:5:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 5, 2007 -> 22:5:31"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 5, 2007 -> 22:5:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 5, 2007 -> 22:5:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 5, 2007 -> 22:5:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 5, 2007 -> 22:5:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 5, 2007 -> 22:5:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 5, 2007 -> 22:5:39"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 5, 2007 -> 22:5:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 5, 2007 -> 22:5:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 5, 2007 -> 22:5:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 5, 2007 -> 22:5:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 5, 2007 -> 22:5:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 5, 2007 -> 22:5:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 5, 2007 -> 22:5:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 5, 2007 -> 22:5:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 5, 2007 -> 22:5:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 5, 2007 -> 22:5:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 5, 2007 -> 22:5:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 5, 2007 -> 22:5:54"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 5, 2007 -> 22:5:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 5, 2007 -> 22:5:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 5, 2007 -> 22:5:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 5, 2007 -> 22:5:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 5, 2007 -> 22:6:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 5, 2007 -> 22:6:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 5, 2007 -> 22:6:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 5, 2007 -> 22:6:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 5, 2007 -> 22:6:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 5, 2007 -> 22:6:8"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 5, 2007 -> 22:6:9"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 5, 2007 -> 22:6:11"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 5, 2007 -> 22:6:12"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 5, 2007 -> 22:6:13"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 5, 2007 -> 22:6:14"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 5, 2007 -> 22:6:15"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 5, 2007 -> 22:6:17"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 5, 2007 -> 22:6:18"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 5, 2007 -> 22:6:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 5, 2007 -> 22:6:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 5, 2007 -> 22:6:22"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 5, 2007 -> 22:6:23"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 5, 2007 -> 22:6:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 5, 2007 -> 22:6:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 5, 2007 -> 22:6:27"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 5, 2007 -> 22:6:28"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 5, 2007 -> 22:6:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 5, 2007 -> 22:6:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 5, 2007 -> 22:6:32"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:33"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 5, 2007 -> 22:6:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 5, 2007 -> 22:6:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 5, 2007 -> 22:6:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:38"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 5, 2007 -> 22:6:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 5, 2007 -> 22:6:42"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 5, 2007 -> 22:6:44"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 5, 2007 -> 22:6:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 5, 2007 -> 22:6:46"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 5, 2007 -> 22:6:47"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 5, 2007 -> 22:6:50"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 5, 2007 -> 22:6:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 5, 2007 -> 22:6:53"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 5, 2007 -> 22:6:54"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:6:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 5, 2007 -> 22:6:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 5, 2007 -> 22:6:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 5, 2007 -> 22:6:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 5, 2007 -> 22:7:0"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 5, 2007 -> 22:7:2"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 5, 2007 -> 22:7:3"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 5, 2007 -> 22:7:46"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:48"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 5, 2007 -> 22:7:49"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 5, 2007 -> 22:7:51"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 5, 2007 -> 22:7:53"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 5, 2007 -> 22:7:54"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 5, 2007 -> 22:7:55"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 5, 2007 -> 22:7:56"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 5, 2007 -> 22:7:57"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 5, 2007 -> 22:7:58"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 5, 2007 -> 22:7:59"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 5, 2007 -> 22:8:0"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 5, 2007 -> 22:8:1"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 5, 2007 -> 22:8:2"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 5, 2007 -> 22:9:22"!

"System saved" !
"June 6, 2007 -> 1:38:20"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:22"!

Delta define: #Win32Platform as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'ErrorStream <CharOutputStream>') !


"June 6, 2007 -> 1:38:23"!

(Delta mirrorFor: #Win32Platform)
comment: 
'The class side holds platform dependent constants and utilities.  Is also used
to get command line args, and other things like that.

Keywords: %machdep  %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"June 6, 2007 -> 1:38:23"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLInitialize
    DLLDict := Dictionary new.
    {{primitiveDLLSetupLookup: self selector: #DLLLookup:in: ifFail: [:err | self error: err]}}! !

"June 6, 2007 -> 1:38:24"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLibrary: name
    ^DLLDict at: name ifAbsent: [
        DLLDict at: name put: (self DLLLoad: name)
    ]! !

"June 6, 2007 -> 1:38:25"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLoad: name
    | r n |
    r := ExternalProxy new.
    n := (self DLLMapName: name) asSymbol.
    ^{{primitiveDLLLoad: n result: r ifFail: [ :err | self error: err]}}! !

"June 6, 2007 -> 1:38:26"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLLookup: name <Str> in: library <Str>
    "Convert library into proxy"
    | p r |
    p := self DLLLibrary: library.
    r := ExternalProxy new.
    {{primitiveDLLLookup: name asSymbol in: p result: r ifFail: [:err | self error: err]}}.
    ^r! !

"June 6, 2007 -> 1:38:27"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'user'       ifTrue: [^'USER32.DLL'].
    name = 'gdi'            ifTrue: [^'GDI32.DLL'].
    name = 'kernel'     ifTrue: [^'KERNEL32.DLL'].
    name = 'comdlg'     ifTrue: [^'COMDLG32.DLL'].
    self error: 'Mapping ', name, ' not found'! !

"June 6, 2007 -> 1:38:28"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardText: str <Str>

    self openClipboard.
    [   | glob <HGLOBAL> strm <ReadWriteStream[Character]> xstr <Str> |
        self emptyClipboard.

        "transform string into a form with lfs inserted"
        strm := (String new: str size) readWriteStream.
        str do:
            [ :c <Character> |
                strm put: c.
                c = Character cr
                    ifTrue: [ strm put: Character lf ].
            ].
        xstr := String withAll: strm contentsWritten.

        glob := HGLOBAL new
                        allocate: xstr size + 1
                        attributes: (Win32 GMEM_MOVEABLE
                                            externalBitOr: Win32 GMEM_DDESHARE).
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs value: xstr   ].

        {{<user ExternalProxy SetClipboardData>
                format: Win32 CF_TEXT
                data: glob
        }} isNull
            ifTrue: [ Win32 handleError ].
    ] ensure:
        [ self closeClipboard ]! !

"June 6, 2007 -> 1:38:29"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'clipboard access' !
clipboardTextIfAbsent: blk <[^X def]> ^<Str | X>

    self openClipboard.
    [   | glob <HGLOBAL> strm <CharWriteStream> |

        {{<user ExternalProxy IsClipboardFormatAvailable> format: Win32 CF_TEXT}} asBoolean
            ifFalse: [ ^blk value ].
        glob := {{<user HGLOBAL GetClipboardData> format: Win32 CF_TEXT}}.
        glob isNull
            ifTrue: [ Win32 handleError ].
        strm := (String new: 100) writeStream.
        glob withPointer: CString new
                do: [ :cs <CString> |
                            cs asString do:
                                [ :c <Character> |
                                    c = Character lf
                                        ifFalse: [ strm put: c ]
                                ].
                            ^strm contentsWritten
                      ].
    ] ensure:
        [ self closeClipboard ]! !

"June 6, 2007 -> 1:38:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 1:38:31"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 6, 2007 -> 1:38:32"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
multipleMatchWildcardCharacter ^<Character>

    ^$*! !

"June 6, 2007 -> 1:38:33"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
singleMatchWildcardCharacter ^<Character>

    ^$?! !

"June 6, 2007 -> 1:38:34"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'constants' !
wordSize ^<Int>
    ^4! !

"June 6, 2007 -> 1:38:35"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> size <Int> cSize <ExternalProxy> result <Str> done <Boolean> found <Boolean> |
    size := 1024.
    cKey := CString for: key.
    done := false.
    [ done ] whileFalse: [
        cValue := CString for: (String new: size).
        cSize := {{<kernel ExternalProxy GetEnvironmentVariableA> key: cKey buffer: cValue bufSize: size}}.
        cSize asSmallInteger > size
            ifTrue: [   cValue free.                                                    "Buffer size too small for value of variable"
                            size := cSize asSmallInteger ]
            ifFalse: [  done := true.                                                   "Buffer size ok, check if variable was found"
                            (found := cSize asSmallInteger ~= 0)
                                ifTrue: [ result := cValue asString ] ] ].
    cKey free. 
    cValue free.
    ^found
        ifTrue: [ result ]
        ifFalse: blk ! !

"June 6, 2007 -> 1:38:36"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'initialization' !
initialize

    self DLLInitialize! !

"June 6, 2007 -> 1:38:37"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os streams' !
errorStream ^<CharOutputStream>

    ErrorStream isNil
        ifTrue: [   ErrorStream := TempTranscript new ].
    ^ErrorStream! !

"June 6, 2007 -> 1:38:38"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^Win32FilePath! !

"June 6, 2007 -> 1:38:38"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^Win32FilePattern! !

"June 6, 2007 -> 1:38:40"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
parseArgFrom: strm <CharInputStream>  ^<Str>
    "Parse an argument token from the strm.  Leading whitespace is assumed to have been removed already.
      Any whitespace following the token is consumed."

    | arg <Str> |
    (strm peekFor: $")
        ifTrue: [       | c <Character> buf <CharWriteStream> |
                        buf := String new writeStream.
                        [   c := strm next.
                            c ~= $" or: [ (strm peekIfAbsent: [ self skipSpacesIn: strm.  ^buf contentsWritten ]) = $" ]
                        ] whileTrue: 
                            [   c = $" ifTrue: [ strm next ].
                                buf put: c ].
                        arg := buf contentsWritten  ]
        ifFalse: [  arg := strm upTo: Character space ].
    self skipSpacesIn: strm.
    ^arg! !

"June 6, 2007 -> 1:38:41"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 6, 2007 -> 1:38:42"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
closeClipboard

    {{<user ExternalProxy CloseClipboard> call}}! !

"June 6, 2007 -> 1:38:42"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
emptyClipboard

    {{<user ExternalProxy EmptyClipboard> call}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 6, 2007 -> 1:38:43"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'private-clipboard access' !
openClipboard

    {{<user ExternalProxy OpenClipboard> hnd: Win32 NULL}} asBoolean
        ifFalse: [ Win32 handleError ].
! !

"June 6, 2007 -> 1:38:44"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^true! !

"June 6, 2007 -> 1:39:6"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:8"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:9"!

Delta define: #Launcher as: (
(Class subclassOf: 'ClassCritical |> Application' instanceVariables: 'menuBar <Menu>
sourceConsistencyHasBeenChecked <Boolean>
') classVariables: 'MenuRegistry <OrdCltn[LookupKey[Object,Menu]]>
Launchers <IdentitySet[Launcher]>
	"All unclosed instances of launcher, so that we
		can notify them when their menus change"') !


"June 6, 2007 -> 1:39:10"!

(Delta mirrorFor: #Launcher)
comment: 
'The launcher is the entry point application for the programming environment.
(c) 1996-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license. '!


"June 6, 2007 -> 1:39:11"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'accessing' !
launchers ^<IdentitySet[Launcher]>
	"call only from a critical region"

	Launchers isNil
		ifTrue: [ Launchers := IdentitySet[Launcher] new ].
	^Launchers! !

"June 6, 2007 -> 1:39:12"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
createUITranscript

	"Make sure the UI isn't already running"
	self assert: [ Transcript class ~~ Workspace ].
	
	Transcript := Workspace new.! !

"June 6, 2007 -> 1:39:14"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'control' !
startProgEnv ^<Instance>

	| launcher <Instance> |
	self createUITranscript.
	
	"Register stophandler for process scheduler"
	Processor stopHandler: [ :p <Process> | (StackTraceInspector on: p) launch ].

	launcher := (self new) launch; yourself.

	"Don't launch start page if system is inconsistent so that it won't
		obscure the error messages in the transcript"
	SourceHandler systemIsConsistent
		ifTrue: [ [ launcher browseStartPage ] fork. ]. 

	^launcher
! !

"June 6, 2007 -> 1:39:14"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
menuRegistry ^<OrdCltn[LookupKey[Object,Menu]]>
	"call only from a critical region"

	MenuRegistry isNil
		ifTrue: [ MenuRegistry := OrderedCollection[LookupKey[Object,Menu]] new ].
	^MenuRegistry! !

"June 6, 2007 -> 1:39:16"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
mergedMenu ^<Menu>
	"Call only from critical region"

	| newMenu <Menu> |
	newMenu := Menu new.
	self menuRegistry do:
		[ :entry <LookupKey[Object,Menu]> |
			newMenu merge: entry value copy.	].
	^newMenu! !

"June 6, 2007 -> 1:39:16"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
rebuildMenus
	"rebuild all the menus and notify the launchers.  Must
		be in a critical region on self"

	| newMenu <Menu> |
	newMenu := self mergedMenu.
	self launchers do:
		[ :l <Launcher> |
			l menuBar: newMenu copy	].! !

"June 6, 2007 -> 1:39:17"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'private' !
registerLauncher: l <Launcher>

	self critical:
		[ self launchers include: l ]! !

"June 6, 2007 -> 1:39:18"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'registering menus' !
registerMenu: m <Menu> for: owner <Object>
	"Merge m into the launcher menu.  It can be unregistered later.
		Any displayed launchers will update their menus dynamically."

	self critical:
		[	self menuRegistry addLast:
						(LookupKey[Object,Menu] key: owner value: m).
			self rebuildMenus	]! !

"June 6, 2007 -> 1:39:19"!

! (Delta mirrorFor: #Launcher) classSide methodsFor: 'registering menus' !
unregisterMenuFor: owner <Object>
	"Unmerge m from the launcher menu. "

	self critical:
		[	self menuRegistry remove: (LookupKey[Object,Menu] key: owner value: nil). "value doesn't matter"
			self rebuildMenus	]! !

"June 6, 2007 -> 1:39:20"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
docPath ^<FilePath>

	^FilePath currentDirectory, (FilePath for: 'documentation\index.html')! !

"June 6, 2007 -> 1:39:21"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
windowTitle ^ <Str>

	^'Strongtalk Launcher'! !

"June 6, 2007 -> 1:39:22"!

! (Delta mirrorFor: #Launcher) methodsFor: 'accessing' !
workspace ^<Workspace>

	^Workspace coerce: Transcript! !

"June 6, 2007 -> 1:39:23"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
browseStartPage

	self startPagePath exists
		ifFalse: [  self visual promptOk: 'Can''t open ',self startPagePath name
								title: 'Error'
								type: #exclamation
								action: [].
							^self
						].

	(HTMLView new model: (URL forFilePath: self startPagePath)) launch! !

"June 6, 2007 -> 1:39:24"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findDefinition
	
	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Open definition'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchDefinitionsMatching: s ]
! !

"June 6, 2007 -> 1:39:25"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findGlobalReferences

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find references'
		caption: 'Name of global' 
		default: ''
		action: [ :s <Str> | self launchReferencesToGlobalName: s asSymbol ]
! !

"June 6, 2007 -> 1:39:26"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findImplementors

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find implementors'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchImplementorsMatching: s ]

! !

"June 6, 2007 -> 1:39:27"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
findSenders

	self 
		launchSingleLineTextDialogWithPainter: Painter default
		title: 'Find senders'
		caption: 'Matching expression' 
		default: '*'
		action: [ :s <Str> | self launchSendersMatching: s ]
! !

"June 6, 2007 -> 1:39:28"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchDefinitionsMatching: s <Str>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"
	
	| definitions <AddableSequenceableCollection[Symbol]> mirror <Mirror> |
	definitions := OrderedCollection[Symbol] new.
	Smalltalk keysDo: [ :key <Symbol> | 
		(s platformMatch: key)
			ifTrue: [	definitions add: key ]
	].
	definitions isEmpty
		ifTrue: [	| pattern <Str> |
					pattern := s, Platform multipleMatchWildcardCharacter asString.
					Smalltalk keysDo: [ :key <Symbol> | 
						(pattern platformMatch: key)
							ifTrue: [	definitions add: key ]
					]
	].
	definitions := definitions asSortedCollection: [ :a <Symbol> :b <Symbol> | a <= b ].
	definitions isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No definitions matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ].
	definitions size = 1
		ifTrue: [		mirror := Smalltalk mirrorFor: (definitions at: 1) ifAbsent: [ ^self ].
						(DefOutliner on: mirror) launch ]
		ifFalse: [	self 
								launchListDialogWithPainter: Painter default
								title: 'Definitions matching ', s
								modal: false
								contents: definitions
								multi: true
								action: [ :indices <Cltn[Int]> |
												indices do:
													[ :index <Int> |
														mirror := Smalltalk mirrorFor: (definitions at: index)
																			ifAbsent: [ ^self ].
														(DefOutliner on: mirror) launch 	]	].
							]! !

"June 6, 2007 -> 1:39:29"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchDoc

	(HTMLView new model: (URL forFilePath: self docPath)) launch! !

"June 6, 2007 -> 1:39:30"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchImplementorsMatching: s <Str>

	| implementors <SeqCltn[Tuple[Mirror, Symbol]]> |
	(implementors := Smalltalk implementorsMatching: s) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No implementors matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'Implementors matching ''', s,	 '''' 
								contents: implementors ]
! !

"June 6, 2007 -> 1:39:31"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchListDialogWithPainter: p <Painter>
title: t <Str>
contents: strs <SeqCltn[Str]>
multi: b <Boolean>
action: blk <[Cltn[Int]]>

	self	launchListDialogWithPainter: p 
			title: t 
			modal: true
			contents: strs
			multi: b 
			action: blk 
! !

"June 6, 2007 -> 1:39:32"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchListDialogWithPainter: p <Painter>
title: t <Str>
modal: modal <Boolean>
contents: strs <SeqCltn[Str]>
multi: b <Boolean>
action: blk <[Cltn[Int]]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

		| listBox <ListBox> editor <TextView[Str]> glue <Visual> dialog <Window> |
	strs size > 0
		ifFalse: [ ^self ].
	listBox := b
		ifTrue: [	ListBox forMultipleSelections
						simpleMultiple: false ]
		ifFalse: [	ListBox forSingleSelection ].
	listBox
		stringList: strs;
		selections: #(1);
		onDoubleClick: [ :lb <ListBox> | dialog close. blk value: lb selections ].
	dialog := (Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (listBox withBorder: (Border standard3DWithColor: Paint gray raised: false))
		showApply: true
		modal: modal
		toValidate: [ :continue <[]> | continue value ]
		action: [ blk value: listBox selections ].
! !

"June 6, 2007 -> 1:39:33"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchReferencesToGlobalName: name <Symbol>

	| refs <SeqCltn[Tuple[Mirror, Symbol]]> |
	(refs := Smalltalk referencesToGlobalName: name) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No references to global ''', name, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'References to global ''', name,	 '''' 
								contents: refs ]
! !

"June 6, 2007 -> 1:39:35"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSelectorListWithPainter: p <Painter> title: t <Str> contents: list <SeqCltn[Tuple[Mirror, Symbol]]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

	| listBox <ListBox> action <[ListBox]> win <Window> |
	list size > 0
		ifFalse: [ ^self ].
	list size = 1
		ifTrue: [	| mirror <Mirror> sel <Symbol> |
					mirror := (list at: 1) at1.
					sel := (list at: 1) at2.
					(DefWithMsgOutliner on: mirror instanceSide) launchOpenSide: mirror isMeta selector: sel.
					^self ].
	action := [ 	:lb <ListBox> |
						| index <Int> mirror <Mirror> sel <Symbol> |
						index := lb selections anElement.				"We use single selection"
						mirror := (list at: index) at1.
						sel := (list at: index) at2.
						(DefWithMsgOutliner on: mirror instanceSide) launchOpenSide: mirror isMeta selector: sel.
						].
	listBox := ListBox forSingleSelection.
	listBox
		stringList: (list collect: [ :t <Tuple[Mirror, Symbol]> | t at1 name, '>>', t at2 ]);
		selections: #(1);
		onDoubleClick: [ :lb <ListBox> | action value: lb ].
	win := (Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (listBox withBorder: (Border standard3DWithColor: Paint gray raised: false))
		showApply: true
		modal: false
		toValidate: [ :continue <[]> | continue value ]
		action: [ 	action value: listBox ].
! !

"June 6, 2007 -> 1:39:36"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSendersMatching: s <Str>

	| senders <SeqCltn[Tuple[Mirror, Symbol]]> |
	(senders := Smalltalk sendersMatching: s) isEmpty
		ifTrue: [		(Workspace coerce: Transcript) visual
								promptOk: 'No senders matching ''', s, ''''
								title: 'Information'
								type: #info
								action: [] ]
		ifFalse: [	self 
								launchSelectorListWithPainter: Painter default 
								title: 'Senders matching ''', s,	 '''' 
								contents: senders ]
! !

"June 6, 2007 -> 1:39:37"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
launchSingleLineTextDialogWithPainter: p <Painter> title: t <Str> caption: c <Str> default: d <Str> action: blk <[Str]>

	"THIS IS JUST A QUICK HACK!!!!!! REMOVE LATER!!!!!!"

	| caption <Visual> editor <TextView[Str]> glue <Visual> |
	caption := (StringGlyph for: c painter: p) asVisual.
	glue := Glue xRigid: 10.
	editor := CommonProgEnvOutliner new buildSingleLineTextViewWithPainter: p getModel: [ d ] setModelOnSuccess: [ :blk <[]> | blk value ].
	editor desiredColumns: (c size max: d size).
	(Workspace coerce: Transcript) visual
		launchCustomDialog: t
		for: (Row[Visual] holding: (OrderedCollection[Visual] with: caption with: glue with: (CommonProgEnvOutliner new editorBorderFor: editor)))
		showApply: false
		modal: true
		toValidate: [ :continue <[]> | continue value ]
		action: [ blk value: editor model ].
! !

"June 6, 2007 -> 1:39:38"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openClassHierarchyOutliner

	(ClassHierarchyOutliner for: (ClassMirror on: Object))
		launch.! !

"June 6, 2007 -> 1:39:39"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openGlobalVariableListOutliner

	GlobalVariableListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:40"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openMixinListOutliner

	MixinListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:41"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openProtocolListOutliner

	ProtocolListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:41"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openTypeAliasListOutliner

	TypeAliasListOutliner forWorld launch! !

"June 6, 2007 -> 1:39:42"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
openUserClassHierarchyOutliner

	(ClassHierarchyOutliner for: (ClassMirror on: Object))
		filterOnUserClasses
		launch.! !

"June 6, 2007 -> 1:39:43"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
showUnsavedChanges
	"Launch a read-only text view on the unsaved changes that have been made
	 during this session"

	SourceHandler unsavedChangesHaveBeenMade
		ifTrue: [	| tv <TextView[InputStream[Character]]> |
					tv := TextView[InputStream[Character]]  forCharStream.
					tv scrollable: true.
					tv model: (SourceHandler currentUnsavedChanges);
						doneBlock:
							[ :saveFlag <Boolean> :action <[]> |
								self visual
									promptOk: 'You can''t change the changes here!!'
									title: 'Error'
									type: #stop
									action: [  ]	 ].
					(tv bareVisualTop: false) launchWithTitle: 'Unsaved Changes'.		]
		ifFalse: [ self visual
						promptOk: 'There are no unsaved changes.'
						title: 'System Change Status'
						type: #info
						action: [ ]		]! !

"June 6, 2007 -> 1:39:44"!

! (Delta mirrorFor: #Launcher) methodsFor: 'browsing' !
startPagePath ^<FilePath>

	^FilePath currentDirectory, (FilePath for: 'startPage.html')! !

"June 6, 2007 -> 1:39:45"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
closeRequest: toClose <[]>

	SourceHandler unsavedChangesHaveBeenMade
		ifTrue: [ self promptForSave: toClose ]
		ifFalse: [ self promptForQuit: toClose ]! !

"June 6, 2007 -> 1:39:46"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
recompileWorld

	(Workspace coerce: Transcript) visual
		promptOkCancel: 'Recompile all methods in the system?'
		title: 'Please confirm'
		type: #question
		default: 2
		action: [ : b <Boolean> | b ifTrue: [ [ Smalltalk recompileAllMethods ] fork ] ]! !

"June 6, 2007 -> 1:39:47"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
saveSystem

	self visual promptOkCancel: 'Save System?'
				title: 'Save System'
				type: #exclamation
				default: 1
				action: [ :ok <Boolean> |
								ok ifTrue: [	Dumper saveSystem.
														self visual
																promptOk: 'System Saved.'
																title: 'Save System'
																type: #info
																action: [ ]
													]
							]
! !

"June 6, 2007 -> 1:39:49"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control' !
typecheckWorld
 
	| vis <Visual> |
	vis := 	(Workspace coerce: Transcript) visual.
	vis	promptYesNo: 'Do you really want to typecheck all the source code in the system?'
		title: 'Typecheck world'
		type: #question
		default: 2
		action:	[: b <Boolean> |
							b ifTrue: [ Smalltalk typecheckWorld ].
						]
! !

"June 6, 2007 -> 1:39:50"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
doClose: toClose <[]>

	toClose value.
	VM quit.! !

"June 6, 2007 -> 1:39:51"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
promptForQuit: toClose <[]>

	self visual
				promptYesNo: 'Are you sure you want to quit?'
				title: 'Quit'
				type: #exclamation
				default: 2
				action: [ :ok <Boolean> |
								ok = true
									ifTrue: [ self doClose: toClose ]
								]! !

"June 6, 2007 -> 1:39:52"!

! (Delta mirrorFor: #Launcher) methodsFor: 'control-private' !
promptForSave: toClose <[]>

	self visual
				promptYesNoCancel: 'The system has been changed.  Save system before exiting? (''No'' will erase any changes and add them to the restore log)'
				title: 'Quit'
				type: #exclamation
				default: 3
				action: [ :ok <Boolean | Nil> |
								ok = nil
									ifFalse: [	ok
														ifTrue: [ Dumper saveSystem ]
														ifFalse: [ SourceHandler checkSystemConsistency at1
																		ifTrue: [ SourceHandler restoreBackup ]. ].
													self doClose: toClose		]
								]! !

"June 6, 2007 -> 1:39:53"!

! (Delta mirrorFor: #Launcher) methodsFor: 'filing in/out' !
fileIn

	(Workspace coerce: Transcript) visual
		userPickOpenFileWithAction: [ :file< FilePath> :readOnly <Boolean> | [ Smalltalk fileInFromFile: file ] fork ]
		fileTypes: (Array[Tuple[Str,Str]] with: 'Delta files (*.dlt)' ,, '*.dlt' with: 'All files (*.*)' ,, '*.*')
		defaultFile: nil
		defaultDir: nil
		title: 'Install file-in into image'
		allowReadOnly: false
		mustExist: true
! !

"June 6, 2007 -> 1:39:54"!

! (Delta mirrorFor: #Launcher) methodsFor: 'filing in/out' !
fileOutWorld

	(Workspace coerce: Transcript) visual
		userPickSaveFileWithAction: [ :file< FilePath> | [ Smalltalk fileOutWorldToFile: file ] fork ]
		fileTypes: (Array[Tuple[Str,Str]] with: 'Group files (*.gr)' ,, '*.gr' with: 'All files (*.*)' ,, '*.*')
		defaultFile: (FilePath for: 'world.gr')
		defaultDir: nil
		title: 'File out world and corresponding world group file'
! !

"June 6, 2007 -> 1:39:55"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
docMenu ^<Menu>

	^Menu new name: '&Documentation';
				add: (MenuAction new
							name: '&Browse';
							action: [ self launchDoc ])! !

"June 6, 2007 -> 1:39:56"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
fileMenu ^<Menu>

	^Menu new name: '&File';
		add: (MenuAction new
					name: '&Save System';
					action: [ self saveSystem ] );
		addSeparator;
		add: (MenuAction new
					name: 'File &in...';
					action: [ self fileIn ] );
		add: (MenuAction new
					name: 'File &out world...';
					action: [ self fileOutWorld ] );
		add: (MenuAction new
					name: '&Recompile world...';
					action: [ self recompileWorld ] );
		add: (MenuAction new
					name: 'Typecheck world...';
					action: [ self typecheckWorld ] );
		 addSeparator;
		 add: (MenuAction new
		            name:'Meta';
		            action:[Inspector launchOn: self]);
		addSeparator;
		add: (MenuAction new
					name: 'E&xit';
					action: [ self closeRequest: []  ] )! !

"June 6, 2007 -> 1:39:57"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
hasMenu ^<Boolean>

	^true! !

"June 6, 2007 -> 1:39:58"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus' !
menuBar ^<Menu>

	menuBar isNil
		ifTrue: [ menuBar := Menu new 
															add: self fileMenu;
															add: self browsingMenu;
															merge: self class mergedMenu;
															add: self docMenu
					 ].
	^menuBar! !

"June 6, 2007 -> 1:39:59"!

! (Delta mirrorFor: #Launcher) methodsFor: 'menus to move elsewhere' !
browsingMenu ^<Menu>

	^Menu new name: '&Browse';
			add: (MenuAction new
					name: 'My &Start Page';
					action: [ self browseStartPage ] );
			addSeparator;
			add: (MenuAction new
					name: '&Definition...';
					action: [ self findDefinition] );
			add: (MenuAction new
					name: '&User Classes (i.e. classes useful to users)';
					action: [ self openUserClassHierarchyOutliner ] );
			add: (MenuAction new
					name: 'All &Classes';
					action: [ self openClassHierarchyOutliner ] );
			add: (MenuAction new
					name: '&Mixins';
					action: [ self openMixinListOutliner ] );
			add: (MenuAction new
					name: '&Protocols';
					action: [ self openProtocolListOutliner ] );
			add: (MenuAction new
					name: '&Type Aliases';
					action: [ self openTypeAliasListOutliner ] );
			add: (MenuAction new
					name: '&Global Variables';
					action: [ self openGlobalVariableListOutliner ] );
			addSeparator;
			add: (MenuAction new
					name: 'Message Implementors ...';
					action: [ self findImplementors ] );
			add: (MenuAction new
					name: 'Message Senders ...';
					action: [ self findSenders ] );
			add: (MenuAction new
					name: 'Global References ...';
					action: [ self findGlobalReferences ] );
			addSeparator;
			add: (MenuAction new
					name: 'Unsaved Changes From This Session';
					active: [ SourceHandler unsavedChangesHaveBeenMade ];
					action: [ self showUnsavedChanges ] );
			add: (MenuAction new
					name: 'Restore Log';
					active: [ (FilePath forElements: #('source' 'strongtalkrestore.log')) exists ];
					action: [ (CodeEditor on: (FilePath forElements: #('source' 'strongtalkrestore.log'))) launch ] );
			add: (MenuAction new
					name: 'Save Log';
					active: [ (FilePath forElements: #('source' 'strongtalkSave.log')) exists ];
					action: [ (CodeEditor on: (FilePath forElements: #('source' 'strongtalkSave.log'))) launch ] )
! !

"June 6, 2007 -> 1:40:0"!

! (Delta mirrorFor: #Launcher) methodsFor: 'notification' !
visualAllocated

	sourceConsistencyHasBeenChecked
		ifFalse: [	sourceConsistencyHasBeenChecked := true.
						"This is a gross %hack to make sure that the launcher
							window has appeared by the time we try to print
							any warning messages.  This is because I'm using
							fancy doitButtons in the warning message, and there
							is some kind of timing problem that hangs the system
							if the message arrives too soon, and I don't have time
							to find it."
						[	(Delay forMilliseconds: 250) wait.
							SourceHandler checkSystemConsistencyAndPrintMessagesIfNeeded.
							] fork.	].
! !

"June 6, 2007 -> 1:40:1"!

! (Delta mirrorFor: #Launcher) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	^ApplicationInterceptor
			for: self workspace imbeddedVisual with3DBorder
			application: self! !

"June 6, 2007 -> 1:40:2"!

! (Delta mirrorFor: #Launcher) methodsFor: 'private-initialization' !
initialize

	super initialize.
	self actualClass registerLauncher: self.
	sourceConsistencyHasBeenChecked := false.
! !

"June 6, 2007 -> 1:40:3"!

! (Delta mirrorFor: #Launcher) methodsFor: 'restricted' !
menuBar: m <Menu>
	"Set or change the merged application menu.  We don't actually
		store this menu, since we have to change the window's menu
		in place; we simply replace all of the current menus elements
		with m's"

	self inSessionProcessDo: [ self menuBar 
																	removeAll;
																	add: self fileMenu;
																	add: self browsingMenu;
																	merge: m
														].! !

"June 6, 2007 -> 1:40:4"!

! (Delta mirrorFor: #Launcher) methodsFor: 'toolbar' !
hasToolBar ^<Boolean>

	^true! !

"June 6, 2007 -> 1:40:5"!

! (Delta mirrorFor: #Launcher) methodsFor: 'toolbar' !
toolBar ^<ToolBar>

	^ToolBar new
			addButtonWithImageFrom: 'resources/smallHome.bmp'
					action: [ :b <Button> |	self browseStartPage ];
			addSpace;
			addButtonWithImageFrom: 'resources/open.bmp'
					action: [ :b <Button> |	self findDefinition ];
			addButtonWithImageFrom: 'resources/implementors.bmp'
					action: [ :b <Button> |	self findImplementors ];
			addButtonWithImageFrom: 'resources/senders.bmp'
					action: [ :b <Button> |	self findSenders ];
			addSpace;
			addButtonWithImageFrom: 'resources/userHierarchy.bmp'
					action: [ :b <Button> |	self openUserClassHierarchyOutliner ];
			addButtonWithImageFrom: 'resources/hierarchy.bmp'
					action: [ :b <Button> |	self openClassHierarchyOutliner ];
			addButtonWithImageFrom: 'resources/blankSheet.bmp'
					action: [ :b <Button> |	Workspace new launch ];
			addSpace;
			addButtonWithImageFrom: 'resources/texteditor.bmp'
					action: [ :b <Button> |	CodeEditor new launch ];
			addButtonWithImageFrom: 'resources/documentation.bmp'
					action: [ :b <Button> |	self launchDoc ];
			yourself! !

"June 6, 2007 -> 1:44:24"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:25"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:26"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:27"!

Delta define: #SourceHandler as: (
(Class subclassOf: 'NotifyingObject mixin |> Object' instanceVariables: 'mirror dualHandler indexFile indexDict isNewIndex ') classVariables: 'ActiveHandlers ChangeLog <CharWriteStream> RawChangeLog <ExternalReadWriteStream> SourceDirectory InitialChangeLogSize <Int>') !


"June 6, 2007 -> 1:44:28"!

(Delta mirrorFor: #SourceHandler)
comment: 
'This class manages the source code database. 
Subclasses are specialized for specific source constructs.
An instance of such a subclass manages the source code for a particular definition. For example,
a MixinSourceHandler handles source code for a partiular mixin.

The database usually resides in the subdirectory ''source'' of the strongtalk directory. If you wish to have
it elsewhere, set the environment variable StrongtalkSourceDir.

The database contains an identification file, strongtalksource.id. This file consists of two "chunks"
in file in format. The first chunk is a path, that specifies what binary the source database is
associated with. The second chunk is the size of the file strongtalkchange.log, which contains the
entire source code history of the system from last creation.

The source DB also includes files for every class and metaclass in the system. If the class is named X, then its
instance side is represented in the file X in the source directory, and its class side is represented in the file X.class.

Whenever a change is made to the
source code, several things happen:

0. The binary representation IN MEMORY is modified to match the changed source.
1. If this is a new definition X, then a file X.new is created in the source directory.
2. Otherwise, if this is the first change to this definition  in the current session, then:
a. The original source file for the definition X being modified is backed up as X.bak.
b.  The original source code, in file in format, is appended to the restore log, strongtalkrestore.log.
3. The source file for X is modified accordingly.
4. The change is appended to the change log, strongtalkchange.log.

When the system is saved, the binary on disk is rewritten to reflect the memory image of the program.
All the .bak files are removed, and all the .new files have their .new suffix removed, making the new source 
permanent. In addition, a save comment is written to the change log, and the restore log is deleted. 
Finally, the id file is regenerated: it will now contain the path
of the binary that was used in this session, and the size of the change log just after the save.

Using this information, the system can detect if the change log size is greater than the size listed in the id file. This 
indicates unsaved source changes. The system then generates a warning that the source DB is inconsistent with 
the binary. The user is then asked to resync the two. This is accomplished by :

a. Rolling back the change log to the index
indicated by the id file.  
b. For all files X.bak, remove the file X and then rename X.bak to X.
c. Remove all .new files.

Any lost changes can be filed in from the restore log.

Other than the logs and id file, the source DB consists of files representing the code in individual classes and
metaclasses. These rely heavily on indices into the change log, and are known as index files. Every instance
of a source handler has its own index file. The index files are represented in file in format, using chunks.

For every construct, the appropriate source handler defines a series of attributes. The index file then encodes
these attributes. Some attributes are listed directly in the index file, while others point at an index in the change
log. As a rule, if an attribute needs to be available quickly, it is encoded directly into the index file. For example,
category names and type signatures are needed by browsers that have to display this information, even if
no method bodies are being viewed. Type information is also needed by the type checker. Therefore, this
data is directly available in the index file. On the other hand, method bodies are only needed when a browser
opens a view on a method. In that case, we can afford to look it up in the change log, so the index file contains
only a number, which is a character offser into the change log where the method body can be found.

 (c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:44:30"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
activeHandlers ^ <IdentityDictionary>

	"Contains all currently active source handlers. These are canonicalized.
	The implementation should be changed to use a weak dictionary so that unused
	source handlers can be garbage collected."

	ActiveHandlers isNil
		ifTrue: [	ActiveHandlers := IdentityDictionary[Object, SourceHandler] new ].
	^ActiveHandlers
! !

"June 6, 2007 -> 1:44:31"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
addSectionToChangeLog: blk <[WriteStream,^Int]> ^ <Int>

	| pos <Int> |
	self changeLog
		setToEnd;
		cr;
		nextPut: $";
		nextPutAll: Date dateAndTimeNow printString;
		nextPut: $";
		nextPut: $!!;        
		cr; cr.
	pos := blk value: self changeLog.
	self changeLog flush.
	^pos
! !

"June 6, 2007 -> 1:44:32"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLog ^ <CharWriteStream>

	ChangeLog isNil ifTrue: [
		RawChangeLog := self changeLogFile readWriteStream.
		InitialChangeLogSize isNil
			ifTrue: [ InitialChangeLogSize := RawChangeLog size ].
		ChangeLog := BootStrapping
							ifTrue: [		CharacterInputOutputConverter on: RawChangeLog ]
							ifFalse: [ 	self changeLogFile writeStream ] ].
	^ChangeLog
! !

"June 6, 2007 -> 1:44:33"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLogFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self changeLogFileName) ]
		ifFalse: [ 	File open: self changeLogFileName in: self sourceDirectory ]! !

"June 6, 2007 -> 1:44:34"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
changeLogFileName ^ <Str>

    ^'strongtalkchange.log'! !

"June 6, 2007 -> 1:44:35"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
checkSystemConsistency ^<Tuple[Boolean,Boolean]>
	"Check  source database consistency, and move any orphaned code to the
	  restore log, but otherwise do not restore the db to a consistent state.  A pair of booleans
	  is returned. The first indicates whether a restore is needed, and the second
	  indicates whether there was orphaned code (and thus that a the restore option
	  message should be printed."

	| 	shouldRestore <Boolean>
		hadOrphanedCode <Boolean>
		oldID <Str> 
		newID <Str> 
		oldLogSize <Int> 
		idStream <CharInputStream>
		restoreStream <CharInputStream> |

	self identificationFile exists ifTrue: [
		BootStrapping
			ifTrue: [	idStream := self identificationFile charInputStream.
							newID := Platform commandLineTokens next ]
			ifFalse: [	idStream := self identificationFile readStream.
							newID := SessionModel current commandLineTokens next ].
		[	
			oldID := idStream nextChunk.
			oldLogSize := Integer readFrom: idStream.
		] ensure: [
			idStream close
		].
		"		newID = oldID
			ifFalse: [	self printImageChangeWarningFrom: oldID to: newID ]"
			"The intent is that when the system is run, it checks to see if the current binary is the same 
			as the one listed in the source identification file and issues a warning if this is not the case. 
			This provides a crude consistency check.  However, it may issue false warnings,if the entire 
			strongtalk directory is moved to a new location. It even gets  confused if the system is run from the 
			command line or from the windows GUI, because the pathnames are not literally identical."

			"12/6/01: commented out code above; otherwise everyone downloading the system will get
			an annoying message they will not readily understand. If you've downloaded this
			code, feel free to uncomment this part."
			 ].

	shouldRestore := false.
	hadOrphanedCode := false.
	
	BootStrapping
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				shouldRestore := true ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				shouldRestore := true ] ]
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename) 
					ifTrue: [ shouldRestore := true ].
				('*.new' match: filename) 
					ifTrue: [ shouldRestore := true ] ] ].

	shouldRestore
		ifTrue: [	 oldLogSize notNil 
							ifTrue: [	self changeLog setToEnd.
											(oldLogSize > 0 and: [ oldLogSize < self changeLog position ]) 
												ifTrue: [	self changeLog position: oldLogSize.
																restoreStream := BootStrapping
																	ifTrue: [ 	self restoreFile charOutputStream ]
																	ifFalse: [	self restoreFile writeStream ].
																[
																	[ self changeLog atEnd ]
																		whileFalse: [	restoreStream nextPut: self changeLog next ]
																] ensure: [
																	restoreStream close
																].
																hadOrphanedCode := true. ] ] ].
	^shouldRestore,, hadOrphanedCode! !

"June 6, 2007 -> 1:44:36"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
checkSystemConsistencyAndPrintMessagesIfNeeded

	| status <Tuple[Boolean,Boolean]> |
	status := self checkSystemConsistency.
	status at1
		ifTrue: [ self printRestoreWarning ].
	status at2
		ifTrue: [ self printRestoreOption ].! !

"June 6, 2007 -> 1:44:37"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
currentChangeLogSize ^<Int>

	^self rawChangeLog size! !

"June 6, 2007 -> 1:44:38"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
currentUnsavedChanges ^<CharInputStream>
	"Return a stream over the unsaved changes that have been made, in fileout format.  This is
	 a snapshot as of when this method is called and won't reflect future changes"

	| strm <CharInputStream> logPos <Int> |
	self changeLog flush.
	logPos := self changeLog position.  "remember starting position"

	self changeLog position: self initialChangeLogSize.
	strm := self changeLog contentsRemaining readStream.
	
	"restore change log position"
	self changeLog position: logPos.
	^strm! !

"June 6, 2007 -> 1:44:39"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
dualHandlerFor: h <Instance> ^ <Instance> 

	^h isMeta
		ifTrue: [ self for: h instanceSide ]
		ifFalse: [ self for: h classSide ]
! !

"June 6, 2007 -> 1:44:40"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
errorStreams ^ <Cltn[CharOutputStream]>

	^BootStrapping
		ifTrue: [	Array[CharOutputStream] with: Transcript with: Platform errorStream ]
		ifFalse: [	Array[CharOutputStream] with: Transcript ]
! !

"June 6, 2007 -> 1:44:41"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
flush

	ChangeLog notNil
		ifTrue: [	ChangeLog close.
						ChangeLog := nil ].
	SourceDirectory := nil.
	self activeHandlers do: 
		[ :h <SourceHandler> | h flush ].

! !

"June 6, 2007 -> 1:44:42"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
for: m <Mirror> ^ <Instance> 

	| newHandler <Instance> |
	^self activeHandlers at: m reflectee ifAbsent: [ 
		newHandler := self new mirror: m.
		self activeHandlers at: m reflectee put: newHandler.
		newHandler ].
! !

"June 6, 2007 -> 1:44:43"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
identificationFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self identificationFileName) ]
		ifFalse: [ 	self sourceDirectory fileNamed: self identificationFileName ]! !

"June 6, 2007 -> 1:44:43"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
identificationFileName ^ <Str>

	^'strongtalksource.id'! !

"June 6, 2007 -> 1:44:44"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
initialChangeLogSize ^<Int>

	^InitialChangeLogSize! !

"June 6, 2007 -> 1:44:45"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printImageChangeWarningFrom: old <Str> to: new <Str>

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'WARNING !!!!!! WARNING !!!!!! WARNING !!!!!!'; cr; cr;
			show: 'The source database was last used from '; cr;
			show: '  ', old; cr;
			show: 'and is now being used from '; cr;
			show: '  ', new; cr ]! !

"June 6, 2007 -> 1:44:46"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printRestoreOption

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'Changes made since the last save can be found by executing'; cr;
			tab; showDoIt: '"Edit Restore File"                (CodeEditor on: (FilePath for: ''', 
										self restoreFile name,
										''')) launch'; show: '.'; cr.
			 ]! !

"June 6, 2007 -> 1:44:47"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
printRestoreWarning

	self errorStreams do: [ :stream <CharOutputStream> |
		stream
			cr;
			show: 'WARNING !!!!!! WARNING !!!!!! WARNING !!!!!!'; cr; cr;
			show: 'The source database is in an inconsistent state. This can'; cr;
			show: 'be caused by exiting without saving changes. Please execute '; cr;
			tab; showDoIt: 'SourceHandler restoreBackup'; cr;
			show: 'to restore the source database to the state when it was'; cr;
			show: 'last saved.'; cr ]
! !

"June 6, 2007 -> 1:44:48"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
rawChangeLog ^ <ExternalReadWriteStream>

	RawChangeLog isNil
		ifTrue: [	self changeLog ].
	^RawChangeLog! !

"June 6, 2007 -> 1:44:50"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreBackup

	| newName <Str> newFile <FilePath> |
	self flush.
	BootStrapping
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.new' match: filename) 
					ifTrue: [ (self sourceDirectory fileNamed: filename) remove ] ].
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename)
					ifTrue: [ 	newName := filename copyFrom: 1 to: filename size - 4.
									newFile := self sourceDirectory fileNamed: newName.
									newFile exists
										ifTrue: [	newFile remove ].
									(self sourceDirectory fileNamed: filename)  renameAs: newName ] ] ]
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				file delete ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				newName := file name copyFrom: 1 to: file name size - 4.
				newFile := FilePath for: newName.
				newFile exists
					ifTrue: [	newFile delete ].
				file moveAs: newFile ].
			Transcript show: 'Source Database backup restored.';cr.	 ].		

! !

"June 6, 2007 -> 1:44:51"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreFile ^ <FilePath>

	^BootStrapping
		ifTrue: [ 	self sourceDirectory, (FilePath for: self restoreFileName) ]
		ifFalse: [ 	self sourceDirectory fileNamed: self restoreFileName ]! !

"June 6, 2007 -> 1:44:52"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
restoreFileName ^ <Str>

	^'strongtalkrestore.log'! !

"June 6, 2007 -> 1:44:53"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
saveLogFile ^ <FilePath>

	^self sourceDirectory, (FilePath for: 'strongtalkSave.log')! !

"June 6, 2007 -> 1:44:54"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
sourceDirectory ^ <FilePath>

	| path <FilePath> len <Int> |
	SourceDirectory isNil ifTrue: [
		BootStrapping
			ifTrue: [ 
				path := FilePath for: 
								(Platform 
									environmentVariableAt: self sourceDirectoryEnvVar 
									ifAbsent: [ 'source' ]).		
									"Use 'source'  in current directory as default"
				path exists ifFalse: [
					path createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ] ] ]
			ifFalse: [ 
				path := String new: 1024.
				len := KernelLibrary getEnvironmentVariable: self sourceDirectoryEnvVar buffer: path length: path size.
				(len = 0 or: [ len > 1024])
					ifTrue: [ self error: 'Environment variable ', self sourceDirectoryEnvVar,' undefined' ].
				path := Directory fromPath: (path copyFrom: 1 to: len).
				path exists ifFalse: [
					path create ] ].
		SourceDirectory := path ].
	^SourceDirectory
! !

"June 6, 2007 -> 1:44:55"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
sourceDirectoryEnvVar ^ <Str>

	^'StrongtalkSourceDir'! !

"June 6, 2007 -> 1:44:56"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
systemBeingSaved

	| identification <Str> idStream <CharOutputStream> logSize <Int> newName <Str> newFile <FilePath> |
	self flush.
	BootStrapping
		ifTrue: [	
			"Rename .new files and remove .bak files"
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				newName := file name copyFrom: 1 to: file name size - 4.
				newFile := FilePath for: newName.
				newFile exists
					ifTrue: [	self shouldNotHappen ].
				file moveAs: newFile ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				file delete ] ]
		ifFalse: [	
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.new' match: filename) 
					ifTrue: [	newName := filename copyFrom: 1 to: filename size - 4.
									newFile := self sourceDirectory fileNamed: newName.
									newFile exists
										ifTrue: [	self shouldNotHappen ].
									(self sourceDirectory fileNamed: filename)  renameAs: newName ] ].
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename)
					ifTrue: [ (self sourceDirectory fileNamed: filename) remove ] ] ].

	"Stamp change log"
	self addSectionToChangeLog: [ :log <WriteStream> |
		log nextPutAll: '"System saved" !!' ].
	logSize := self changeLog position.

	"Write new identification file"
	BootStrapping
		ifTrue: [
			identification := Platform commandLineTokens next.
			idStream := self identificationFile charOutputStream ]
		ifFalse: [
			identification := SessionModel current commandLineTokens next.
			idStream := self identificationFile writeStream ].
	[ 	idStream 
			deltaNextChunkPut: identification; cr; 
			deltaNextChunkPut: logSize printString; cr
	] ensure: [
		idStream close
	].

	self flush.
	
	self updateSaveLogFile
! !

"June 6, 2007 -> 1:44:58"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
systemIsConsistent ^<Boolean>

	| 	oldID <Str> 
		newID <Str> 
		oldLogSize <Int> 
		idStream <CharInputStream>
		restoreStream <CharInputStream> |

	self identificationFile exists ifTrue: [
		BootStrapping
			ifTrue: [	idStream := self identificationFile charInputStream.
							newID := Platform commandLineTokens next ]
			ifFalse: [	idStream := self identificationFile readStream.
							newID := SessionModel current commandLineTokens next ].
		[	
			oldID := idStream nextChunk.
			oldLogSize := Integer readFrom: idStream.
		] ensure: [
			idStream close
		].
		"		newID = oldID
			ifFalse: [	self printImageChangeWarningFrom: oldID to: newID ]"
			"The intent is that when the system is run, it checks to see if the current binary is the same 
			as the one listed in the source identification file and issues a warning if this is not the case. 
			This provides a crude consistency check.  However, it may issue false warnings,if the entire 
			strongtalk directory is moved to a new location. It even gets  confused if the system is run from the 
			command line or from the windows GUI, because the pathnames are not literally identical."

			"12/6/01: commented out code above; otherwise everyone downloading the system will get
			an annoying message they will not readily understand. If you've downloaded this
			code, feel free to uncomment this part."
			 ].

	BootStrapping
		ifTrue: [
			(self sourceDirectory, (FilePattern for: '*.new')) pathsDo: [ :file <FilePath> |
				^false ].
			(self sourceDirectory, (FilePattern for: '*.bak')) pathsDo: [ :file <FilePath> |
				^false ] ]
		ifFalse: [
			self sourceDirectory fileNamesDo: [ :filename <Str> |
				('*.bak' match: filename) 
					ifTrue: [ ^false ].
				('*.new' match: filename) 
					ifTrue: [ ^false ] ] ].
	^true! !

"June 6, 2007 -> 1:44:58"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
test

	MixinSourceHandler test.! !

"June 6, 2007 -> 1:44:59"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
unsavedChangesHaveBeenMade ^<Boolean>

	"make sure the change log etc. has been initialized"
	self changeLog.
	
	^self initialChangeLogSize ~= self currentChangeLogSize! !

"June 6, 2007 -> 1:45:1"!

! (Delta mirrorFor: #SourceHandler) classSide methodsFor: 'Unclassified' !
updateSaveLogFile
	"Update the save log, if there is one.  This is done during a system save ONLY.  
		%bootstrapping: WARNING: there must not be a save file during the interval between when
		this save file change handling code is filed in, and when the system is restarted after 
		saving it "
	self saveLogFile exists
		ifTrue: [	| ss <ExternalReadWriteStream> logSize <Int> |
					"copy everything written to the change log in this session to the save log"
					
					ss := self saveLogFile readWriteStream.
					ss setToEnd.
					self changeLog flush.
					logSize := self changeLog position.  "remember starting position"
				
					self changeLog position: self initialChangeLogSize.
					[ self rawChangeLog atEnd ]
						whileFalse: 
								[	| byte <Int> |
									ss put: self rawChangeLog next.
									InitialChangeLogSize := InitialChangeLogSize + 1.  ].
					ss close.
					
					"restore the change log position."
					self changeLog position: logSize.	].! !

"June 6, 2007 -> 1:45:2"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
addSectionToChangeLog: blk <[WriteStream,^Int]> ^ <Int>

	^self class addSectionToChangeLog: blk! !

"June 6, 2007 -> 1:45:3"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
attributeAt: k <Str> ^ <OrdCltn[Str]>

	^self indexDict at: k ifAbsent: [ ^OrderedCollection with: String new ]! !

"June 6, 2007 -> 1:45:4"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
attributeAt: k <Str> put: e <OrdCltn[Str]>

	| removeAttribute <Boolean> |
	removeAttribute := BootStrapping
		ifTrue: [ (e isEmpty or: [ e size = 1 and: [ (e at: 1) = '' ] ] ) ]
		ifFalse: [ (e isEmpty or: [ e size = 1 and: [ (e at: 1) trimBlanks = '' ] ] ) ].
	removeAttribute
		ifTrue: [
			self indexDict removeKey: k ifAbsent: [] ]
		ifFalse: [
			self indexDict at: k put: e ].
	self isPersistent ifTrue: [ self storeIndexFile ].! !

"June 6, 2007 -> 1:45:5"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
backupExtension ^ <Str>

	^'.bak'! !

"June 6, 2007 -> 1:45:6"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
booleanAttributeAt: k <Str> ^ <Boolean>

	| list <OrdCltn[Str]> |
	list := self attributeAt: k.
	list size ~= 1 ifTrue: [ self shouldNotHappen ].
	^list first = 'true'
! !

"June 6, 2007 -> 1:45:7"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
booleanAttributeAt: k <Str> put: b <Boolean>

	self attributeAt: k put: (OrderedCollection with: b printString).
! !

"June 6, 2007 -> 1:45:7"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
changeLog ^ <FilePath>

	^self class changeLog! !

"June 6, 2007 -> 1:45:9"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
convertFromFilename: src <Str> ^ <Str>

	"Convert a file name into a Smalltalk toplevel definition by mapping the following:

		$A maps from '_a'       (uppercase letters)
		$_ maps from $_$_	"

	| rs <ReadStream> ws <WriteStream> c <Character> |
	rs := src readStream.
	ws := String new writeStream.
	[ rs atEnd ] whileFalse: [
		(c := rs next) = $_
			ifTrue: [
				rs peek = $_
					ifTrue: [
						rs next.
						ws nextPut: $_ ]
					ifFalse: [
						c := rs next.
						ws nextPut: c asUppercase ] ]
			ifFalse: [
				ws nextPut: c ] ].
	^ws contents
! !

"June 6, 2007 -> 1:45:10"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
convertToFilename: src <Str> ^ <Str>

	"Convert a Smalltalk toplevel definition name into a valid file name by mapping the following:

		$A maps to '_a'       (uppercase letters)
		$_ maps to $_$_	"

	| ws <WriteStream> |
	ws := (String new: src size * 2) writeStream.
	src do: [ :c <Character> | 
		c = $_
			ifTrue: [
				ws nextPut: $_.
				ws nextPut: $_ ]
			ifFalse: [
				c isUppercase ifTrue: [ ws nextPut: $_ ].
				ws nextPut: c asLowercase ] ].
	^ws contents
! !

"June 6, 2007 -> 1:45:11"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
dualHandler ^ <Self>

	self hasDualHandler
		ifFalse: 	[ ^nil ].
	dualHandler isNil ifTrue: [ 
		self dualHandler: (self class dualHandlerFor: self mirror).
		self dualHandler dualHandler: self ].
	^dualHandler! !

"June 6, 2007 -> 1:45:12"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
dualHandler: h ^ <Self>

	dualHandler := h! !

"June 6, 2007 -> 1:45:13"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
flush

	"Flush cached information. No store operation is needed since this is currently done eagerly."

	self indexDict: nil.
	self indexFile: nil.
	self isNewIndex: nil.
	(dualHandler notNil and: [self mirror notNil and: [self isMeta not]]) 
		ifTrue: [ self dualHandler flush ].! !

"June 6, 2007 -> 1:45:14"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
handlerId ^ <Str>

	self subclassResponsibility! !

"June 6, 2007 -> 1:45:15"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
hasDualHandler ^ <Boolean>

	^true! !

"June 6, 2007 -> 1:45:16"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexDict ^ <Dictionary[Symbol,Cltn[Str]]>

	indexDict isNil ifTrue: [ 
		self indexDict: Dictionary[Symbol,Cltn[String]] new.
		self isPersistent ifTrue: [
			self parseIndexFile ] ].
	^indexDict! !

"June 6, 2007 -> 1:45:17"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexDict: i <Dictionary[Symbol,Cltn[Str]]>

	indexDict := i! !

"June 6, 2007 -> 1:45:18"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFile ^ <FilePath>

	| name <Str> |
	indexFile isNil ifTrue: [
		indexFile := BootStrapping
							ifTrue: [ 	self sourceDirectory, (FilePath for: self indexFileName) ]
							ifFalse: [ 	self sourceDirectory fileNamed: self indexFileName ].
		self isNewIndex: indexFile exists not.
		self isNewIndex
			ifTrue: [
				indexFile := BootStrapping
									ifTrue: [ 	self sourceDirectory, (FilePath for: self indexFileName, self newExtension) ]
									ifFalse: [ 	self sourceDirectory fileNamed: self indexFileName, self newExtension ] ] ].
	^indexFile
! !

"June 6, 2007 -> 1:45:19"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFile: fp <FilePath>

	indexFile := fp! !

"June 6, 2007 -> 1:45:20"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
indexFileName ^ <Str>

	| s <Str> |
	s := self convertToFilename: (self mirror name readStream upTo: $ ).	"Strip meta extension"
	^self isMeta
		ifTrue: [ s, self metaExtension ]
		ifFalse: [ s ]
! !

"June 6, 2007 -> 1:45:21"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isMeta ^ <Boolean>

	^self mirror isMeta! !

"June 6, 2007 -> 1:45:22"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isNewIndex ^ <Boolean>

	isNewIndex isNil
		ifTrue: [	self indexFile ].		"Sets flag depending on whether index existed or not"
	^isNewIndex
! !

"June 6, 2007 -> 1:45:23"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isNewIndex: b <Boolean>

	isNewIndex := b! !

"June 6, 2007 -> 1:45:24"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
isPersistent ^ <Boolean>

	^self mirror name notNil! !

"June 6, 2007 -> 1:45:25"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
makeBackupIndex

	| backupIndexFile <FilePath> |
	self isNewIndex ifFalse: [ 
		BootStrapping
		ifTrue: [ 	
			backupIndexFile  :=self sourceDirectory, (FilePath for: self indexFileName, self backupExtension).
			backupIndexFile exists 
				ifFalse: [ self indexFile copyAs: backupIndexFile ] ]
		ifFalse: [ 	
			(self sourceDirectory fileNamed: self indexFileName, self backupExtension) exists
				ifFalse: [ self indexFile copyTo: self sourceDirectory as: self indexFileName, self backupExtension ] ] ]
! !

"June 6, 2007 -> 1:45:26"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
metaExtension ^ <Str>

	^'.class'! !

"June 6, 2007 -> 1:45:27"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
mirror ^ <Mirror>

	^mirror! !

"June 6, 2007 -> 1:45:28"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
mirror: m <Mirror>

	mirror := m! !

"June 6, 2007 -> 1:45:28"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
newExtension ^ <Str>

	^'.new'! !

"June 6, 2007 -> 1:45:30"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
parseIndexFile

	| file <FilePath> rs <ReadStream> attr <Symbol> s <Str> value <OrdCltn[Str]> id <Str> |

	(file := self indexFile) exists ifTrue: [ 
		BootStrapping
			ifTrue: [ rs :=file charInputStream ]
			ifFalse: [ rs :=file readStream ].
		[
			rs atEnd ifFalse: [
				BootStrapping
					ifTrue: [ id := rs upTo: Character cr ]
					ifFalse: [ id := rs nextLine trimBlanks ].
				id = self handlerId
					ifFalse: [ self error: 'Source database inconsistency: Attemping to have a ', self handlerId, ' hold source for a ', id ] ].
			[ rs atEnd ] whileFalse: [
				s := rs nextChunk.
				BootStrapping ifFalse: [ s := s trimBlanks ].
				self assert: [ s size > 0].
				attr := s asSymbol.
				value := OrderedCollection [Str] new.
				[ (s := rs nextChunk) isEmpty ] whileFalse: [ 
					value add: s ].
				self indexDict at: attr put: value ].
		] ensure: [
			rs close 
		]
	]! !

"June 6, 2007 -> 1:45:31"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
printOn: aStream  <Stream> 
	aStream 
		nextPutAll: self class name;
		nextPutAll: ' on ';
		nextPutAll: self mirror name! !

"June 6, 2007 -> 1:45:32"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeAttributeAt: k <Str> ifAbsent: blk <[]> ^ <Cltn[Str]>

	self indexDict removeKey: k ifAbsent: blk.
	self storeIndexFile.! !

"June 6, 2007 -> 1:45:33"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeIndex

	self flush.
	self removeIndexFile.
	(self hasDualHandler and: [self isMeta not]) 
		ifTrue: [	self dualHandler removeIndexFile ].
	
	(self hasDualHandler and: [self isMeta]) 
		ifTrue: [ self dualHandler logRemoveDefinition ]
		ifFalse: [ self logRemoveDefinition ].

	"Done, nil out remaining entries"
	(self hasDualHandler and: [self isMeta not]) 
		ifTrue: [	self dualHandler mirror: nil.
						self dualHandler dualHandler: nil ].
	self mirror: nil.
	self dualHandler: nil
! !

"June 6, 2007 -> 1:45:34"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
removeIndexFile

	self makeBackupIndex.
	BootStrapping
		ifTrue: [ self indexFile deleteIfFail: [ :err <Symbol> | Win32 handleError ] ]
		ifFalse: [ self indexFile exists ifTrue: [ self indexFile close; remove ] ]! !

"June 6, 2007 -> 1:45:35"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
setName: n <Str>

	self storeIndexFile.
	(self hasDualHandler and: [ dualHandler notNil ])
		ifTrue: [	self dualHandler storeIndexFile ].
! !

"June 6, 2007 -> 1:45:36"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
sourceDirectory ^ <FilePath>

	^self class sourceDirectory
! !

"June 6, 2007 -> 1:45:37"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
storeIndexFile

	| ws <CharOutputStream> |
	self makeBackupIndex.
	BootStrapping
		ifTrue: [ ws := self indexFile charOutputStream ]
		ifFalse: [  ws := self indexFile writeStream ].
	[
		ws nextPutAll: self handlerId; cr.
		self indexDict associationsDo: [ :a <Association[Symbol, Cltn[Str]]> |
	 		ws deltaNextChunkPut: a key.
			a value do: [ :e <Str> | 
				ws cr; deltaNextChunkPut: e ].
			ws nextPut: $ ; nextPut: $!!; cr ].
		BootStrapping ifFalse: [ ws truncate ]
	] ensure: [
		ws close
	]
! !

"June 6, 2007 -> 1:45:38"!

! (Delta mirrorFor: #SourceHandler) methodsFor: 'Unclassified' !
uniqueAttributeAt: k <Str> ^ <Str>

	| list <OrdCltn[Str]> |
	list := self attributeAt: k.
	list size ~= 1 ifTrue: [ self shouldNotHappen ].
	^list first
! !

"June 6, 2007 -> 1:46:19"!

Delta define: #WinPOINT as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:46:19"!

(Delta mirrorFor: #WinPOINT)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.1 $
'!


"June 6, 2007 -> 1:46:21"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
asPoint ^<Point>
	^self x @ self y! !

"June 6, 2007 -> 1:46:22"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
structureSize ^<Int>
	^8! !

"June 6, 2007 -> 1:46:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x ^<SmallInteger>

	^self smallIntegerAt: self xOffset! !

"June 6, 2007 -> 1:46:23"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
x: v <SmallInteger>

	self smallIntegerAt: self xOffset put: v! !

"June 6, 2007 -> 1:46:24"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y ^<SmallInteger>

	^self smallIntegerAt: self yOffset! !

"June 6, 2007 -> 1:46:25"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'accessing' !
y: v <SmallInteger>

	self smallIntegerAt: self yOffset put: v! !

"June 6, 2007 -> 1:46:26"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
xOffset ^<Int>
	^0! !

"June 6, 2007 -> 1:46:27"!

! (Delta mirrorFor: #WinPOINT) methodsFor: 'offsets' !
yOffset ^<Int>
	^4! !

"June 6, 2007 -> 1:48:29"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:30"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:30"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

Delta define: #MINMAXINFO as: (
(Class subclassOf: 'Win32Structure' instanceVariables: '')) !


"June 6, 2007 -> 1:48:31"!

(Delta mirrorFor: #MINMAXINFO)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:48:32"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxSize ^<WinPOINT>

	^self subProxyAt: self ptMaxSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:33"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMaxTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMaxTrackSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:33"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
ptMinTrackSize ^<WinPOINT>

	^self subProxyAt: self ptMinTrackSizeOffset result: WinPOINT new! !

"June 6, 2007 -> 1:48:34"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'accessing' !
structureSize ^<Int>

	^40! !

"June 6, 2007 -> 1:48:35"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxPositionOffset ^<Int>

	^16! !

"June 6, 2007 -> 1:48:36"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxSizeOffset ^<Int>

	^8! !

"June 6, 2007 -> 1:48:37"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMaxTrackSizeOffset ^<Int>

	^32! !

"June 6, 2007 -> 1:48:38"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptMinTrackSizeOffset ^<Int>

	^24! !

"June 6, 2007 -> 1:48:38"!

! (Delta mirrorFor: #MINMAXINFO) methodsFor: 'offsets' !
ptReservedOffset ^<Int>

	^0! !

"June 6, 2007 -> 1:49:13"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:15"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:15"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:16"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:17"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:17"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:18"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:18"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:19"!

Delta define: #Win32Control as: (
(Class subclassOf: 'InstanceCritical |> (ClassCritical |> Visual)' instanceVariables: 'win32Handle <HWND>
controlId <Int>
originalWndProc <HWND>
			"The windows procedure that we overrode using so-called Windows subclassing"
enabled <Boolean>
			"Indicates whether the control is enabled/disabled"
redraw <Boolean>
			"If false, then redrawing is disabled"
backgroundPainter <Painter>
isFocus <Boolean>
ignoreNextFocusSet <Boolean>
			"if this is true, the we have asked to acquire or release the win32 focus,
				in which case the set/killFocus message is ignored, since
				any processing has already been done.  This must be
				done since if something we contain is getting the
				input focus, we set the containing native window
				to be the focus even though it is not the actual
				visual that has the focus."

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
nativePosition <Point>
			"Position of native window in containing native window"
controls <Extensible[Win32Control]>
palette <Palette>
cursor <Cursor>
		') classVariables: 'Controls <VarDict[Int, Win32Control]>
CustomWndProc <APICallback>
MaxControlId <Int>
			"We assign numbers to controls sequentially (%bug breaks after 1 billion created)"
	') !


"June 6, 2007 -> 1:49:19"!

(Delta mirrorFor: #Win32Control)
comment: 
'A Visual that has a corresponding native Win32 window.

%optional #commandWith: - should override to process any WM_COMMAND messages needed

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.5 $
'!


"June 6, 2007 -> 1:49:21"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controlForHandle: hwnd <ExternalProxy> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^self controlFor: (self controlIdFor: hwnd) ifAbsent: b! !

"June 6, 2007 -> 1:49:22"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
controls ^<VarDict[Int, Win32Control]>

	"Assumption: allers must be in a critical region for self"

	Controls isNil
		ifTrue: [ Controls := Dictionary[Int, Win32Control] new ].
	^Controls! !

"June 6, 2007 -> 1:49:23"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'private' !
dispatchMsgFor: hwnd <ExternalProxy>
msg: msg <SmallInteger>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(self controlForHandle: hwnd ifAbsent: [ ^0 ])
		message: msg for: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:49:24"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
assignId ^<Int>
	"Assign and return a unique control id number.  It is assumed that we are already in a
		critical region on the Win32Control."

	MaxControlId isNil
				ifTrue: [ MaxControlId := 1 ]
				ifFalse: [ MaxControlId := MaxControlId + 1].
	^MaxControlId! !

"June 6, 2007 -> 1:49:25"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
buttonColorMsg: hdc <ExternalProxy> for: control <Int> ^<ExternalData>

	^(self controlFor: control  ifAbsent: [ ^0 ]) buttonColorMsg: hdc! !

"June 6, 2007 -> 1:49:27"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlFor: id <Int> ifAbsent: b <[^X def]> ^<Win32Control | X>

	^Win32Control
		critical: [	self controls at: id ifAbsent: b ]! !

"June 6, 2007 -> 1:49:27"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
controlIdFor: hwnd <HWND> ^<Int>

	^{{<user ExternalProxy GetWindowLongA> hwnd: hwnd value: Win32 GWL_ID}} asSmallInteger.
! !

"June 6, 2007 -> 1:49:29"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
customWndProc ^<APICallback>

	"Don't need a critical region"
	CustomWndProc isNil
		ifTrue: [	CustomWndProc := APICallBack
							register:
								[ :hwnd <ExternalProxy> :msg <SmallInteger> :wParam <ExternalData> :lParam <ExternalData> |
									self dispatchMsgFor: hwnd msg: msg wParam: wParam lParam: lParam ]
							parameters: (OrderedCollection[Class]
								with: ExternalProxy with: SmallInteger with: ExternalProxy with: ExternalProxy).	].
	^CustomWndProc! !

"June 6, 2007 -> 1:49:30"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
drawItemMsg: data <DRAWITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) drawItemMsg: data! !

"June 6, 2007 -> 1:49:31"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
measureItemMsg: data <MEASUREITEMSTRUCT> for: control <Int> ^<ExternalData>

	^(self controlFor: control ifAbsent: [ ^0 ]) measureItemMsg: data! !

"June 6, 2007 -> 1:49:31"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
notificationMsg: notifyCode <ExternalData> for: control <Int>

	(self controlFor: control ifAbsent: [ ^0 ]) notificationMsg: notifyCode! !

"June 6, 2007 -> 1:49:32"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
registerControl: id <Int> for: inst <Win32Control>

	Win32Control critical: 
		[ self controls at: id put: inst	]! !

"June 6, 2007 -> 1:49:33"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'restricted' !
unregisterControl: id <Int>

	Win32Control critical: [ self controls removeKey: id ]! !

"June 6, 2007 -> 1:49:34"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugEvents ^<Boolean>

	^Session debugEvents! !

"June 6, 2007 -> 1:49:35"!

! (Delta mirrorFor: #Win32Control) classSide methodsFor: 'testing' !
debugNotifications ^<Boolean>

	^false! !

"June 6, 2007 -> 1:49:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
backgroundPainter ^<Painter>

	backgroundPainter isNil
		ifTrue: [ ^super backgroundPainter ].
	^backgroundPainter! !

"June 6, 2007 -> 1:49:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 6, 2007 -> 1:49:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 6, 2007 -> 1:49:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
fullyEnabled ^<Boolean>

	"is true if we are enabled and all parents are enabled"
	^self enabled and: [ super enabled ]! !

"June 6, 2007 -> 1:49:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 6, 2007 -> 1:49:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'accessing' !
redraw ^<Boolean>

	^redraw! !

"June 6, 2007 -> 1:49:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
changing

	"flush the cached background painter so that it updates"
	backgroundPainter := nil.
	
	super changing! !

"June 6, 2007 -> 1:49:44"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
deferringRedrawDo: blk <[^Object]>
	"defer redrawing during evaluation of blk.  If these calls are nested recursively,
	   redrawing is deferred until the outermost returns, at which point the entire control
	   is invalidated.  This can be used to surround a large number of changes to the receiver
	   that would otherwise cause redundant redrawing."

	| oldFlag <Boolean> |
	oldFlag := self redraw.
	self redraw: false.
	blk value.
	self redraw: oldFlag.
	oldFlag
		ifTrue: [ self invalidate ]! !

"June 6, 2007 -> 1:49:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 6, 2007 -> 1:49:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
release

	self hasWin32Handle
		ifTrue: [ self destroyWin32Handle ].
	super release.! !

"June 6, 2007 -> 1:49:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'control' !
visible: flag <Boolean>

	| data <ExternalData> |
	self assert: [ self hasWin32Handle ].

	data := flag ifTrue: [ Win32 SW_SHOW ] ifFalse: [ Win32 SW_HIDE ].
	{{<user ExternalProxy ShowWindow> hwnd: self win32Handle flag: data}}.! !

"June 6, 2007 -> 1:49:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'debugging' !
printAllocOn: strm <CharOutputStream>

	super printAllocOn: strm.
	self hasWin32Handle
		ifTrue: [	strm show: ' hwnd: '; print: self win32Handle ]
		ifFalse: [ strm show: ' (no hwnd)' ]! !

"June 6, 2007 -> 1:49:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'displaying' !
localDisplayOn: can <Canvas>

	can subwindowsToDisplay add: self! !

"June 6, 2007 -> 1:49:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self callOrigWndProcFor: ev msg) = 0! !

"June 6, 2007 -> 1:49:54"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	| orig <Point> |

	"Translate location back into native window coordinates"
	orig := self allocation enclosingRect origin.
	^(self callOrigWndProcFor: ev msg withLParam: (ExternalProxy forHigh: loc y - orig y low: loc x - orig x)) = 0! !

"June 6, 2007 -> 1:49:56"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-local' !
allocation: r <Region> at: pos <Point>

	| oldAlloc <Region> alloc <Rect> oldLayoutStatus <Int> |
	oldLayoutStatus := self layoutStatus.
	oldAlloc := allocation.
	alloc := r enclosingRect.
	super allocation: r at: pos.

	oldAlloc isNil
		ifTrue: [ self win32Handle.		"Make sure window is created with the current allocation & position" ]
		ifFalse: [	| oldNativePos <Point> old <Rect> | 
						"We need to use a variable since pos...Window changes nativePos"
						old := oldAlloc enclosingRect.
						oldNativePos := nativePosition.
						self hasWin32Handle
							ifTrue: [	(old width ~= alloc width
													or: [ old height ~= alloc height
													or: [ oldNativePos ~= self nativePosition ]  ] )
												ifTrue: [  self updateWindowDimensions  ]	 ]
							ifFalse: [	self isAttached
												ifTrue: [ self win32Handle ]	] ].
	"Invalidate if we are relaying out as a %hack to solve the problems that a higher level
		relayoutAndInvalidate doesn't invalidate contained native windows like this one"
	oldLayoutStatus = Visual needsRelayout
		ifTrue: [ self invalidate ]! !

"June 6, 2007 -> 1:49:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'geometry-nonlocal' !
moveBy: positionDelta <Point>

	"We override this since moving a native visual will generate any needed invalidations
	  automatically."

	self adjustPositionBy: positionDelta! !

"June 6, 2007 -> 1:49:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'initialization' !
initialize

	super initialize.
	redraw := true.
	enabled := true.
	isFocus := false.
	self addNonLocalCount: 1.		"Receiver is non-local"
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.
	controls := IdentitySet[Win32Control] new.! !

"June 6, 2007 -> 1:49:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 6, 2007 -> 1:50:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 6, 2007 -> 1:50:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor ^<Cursor>

	^cursor! !

"June 6, 2007 -> 1:50:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
cursor: c <Cursor>

	cursor := c.! !

"June 6, 2007 -> 1:50:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 6, 2007 -> 1:50:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:50:6"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
handleMouseEvent: type <Symbol> at: loc <Point> ^<Boolean>

	| ev <UIEvent> |

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	Sampler notNil
		ifTrue: [ Sampler 
						in: self topWindow visual 
						sampleEvent: type 
						at: (loc translatedBy: self positionInTopWindow)
						event: ev ].
	^self mouseEvent: type at: loc event: ev! !

"June 6, 2007 -> 1:50:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result translatedBy: self allocation enclosingRect origin! !

"June 6, 2007 -> 1:50:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 6, 2007 -> 1:50:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 6, 2007 -> 1:50:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
noPalette

	palette := nil! !

"June 6, 2007 -> 1:50:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 6, 2007 -> 1:50:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending ^<Boolean>

	^paintPending! !

"June 6, 2007 -> 1:50:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paintPending: b <Boolean>

	paintPending := b! !

"June 6, 2007 -> 1:50:15"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette ^<Palette>

	^palette! !

"June 6, 2007 -> 1:50:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 6, 2007 -> 1:50:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					 ].
	^0! !

"June 6, 2007 -> 1:50:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 6, 2007 -> 1:50:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 6, 2007 -> 1:50:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 6, 2007 -> 1:50:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 6, 2007 -> 1:50:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 6, 2007 -> 1:50:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 6, 2007 -> 1:50:25"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 6, 2007 -> 1:50:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callOrigWndProc: msg wParam: wParam lParam: lParam ]
! !

"June 6, 2007 -> 1:50:27"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 6, 2007 -> 1:50:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 6, 2007 -> 1:50:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 6, 2007 -> 1:50:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 6, 2007 -> 1:50:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |
							self palette isNil
								ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

							"draw on the buffer canvas"
							drawing value: bufferCanvas.
							bufferCanvas shallowFlush.

							"Now, copy the buffer bits onto the screen"
							directCanvas atOffset: invalid origin
								do: [ bufferCanvas atOffset: invalid origin 
									do: [	directCanvas
													bitBlt: bufferCanvas
												extent: invalid extent
												op: UI ropCopy.		].	].
							oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 6, 2007 -> 1:50:33"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 6, 2007 -> 1:50:34"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 6, 2007 -> 1:50:36"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Window' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle>  |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 6, 2007 -> 1:50:37"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'methods copied from Windows with mods' !
display

	"win32 controls do no Smalltalk level painting by default"! !

"June 6, 2007 -> 1:50:38"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
detaching

	super detaching.
	self cleanUp! !

"June 6, 2007 -> 1:50:39"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
isFocus: f <Boolean>

	isFocus := f.
	super isFocus: f.
! !

"June 6, 2007 -> 1:50:40"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'notification' !
nativePositionChanged

	"DON'T pass this message to super, since our children are native relative to us!!"

	(self checkForNativePositionChanging or: [ self isAttached ])
		ifTrue: [ self updateWindowDimensions ]! !

"June 6, 2007 -> 1:50:41"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
buildWin32Handle

	self subclassResponsibility! !

"June 6, 2007 -> 1:50:42"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProc: msgCode <ExternalData> wParam: wParam <ExternalData> lParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but takes all args rather than using a MSG structure"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:50:43"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> ^<ExternalData>

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: m lParam }}! !

"June 6, 2007 -> 1:50:45"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
callOrigWndProcFor: m <MSG> withLParam: lParam <ExternalData>^<ExternalData>
	"Like callOrigWndProcFor:, but overrides the lParam value from the msg"

	"Note that we use the receiver's win32Handle below rather than the one in the message so
	 	 this works even when the event was generated during a grab"
	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: self win32Handle
		msg: m message
		wparam: m wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:50:46"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
canBeFocusCandidate ^<Boolean>
	"%optional: Subclasses that cannot be the input focus even when they are enabled should override this
	  to return false"

	^true! !

"June 6, 2007 -> 1:50:47"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
checkForNativePositionChanging ^<Boolean>
	"returns true if the native position has been changed"

	
	^self hasWin32Handle
			and: [	| oldpos <Point> |
						oldpos := nativePosition.
						oldpos ~= self nativePosition	]! !

"June 6, 2007 -> 1:50:48"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
cleanUp

	self isFocus
		ifTrue: [	self nativeWindow ignoreNextFocusSet: true.
						self session noInputFocus. ].
	self destroyWin32Handle.
! !

"June 6, 2007 -> 1:50:49"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
controlId ^<Int>

	^controlId! !

"June 6, 2007 -> 1:50:50"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createNativeWindow

	"we need a critical region to protect the class variable:"
	Win32Control
		critical: [	controlId := self actualClass assignId.
							self actualClass registerControl: self controlId for: self.
							self paintPending: false.
							self buildWin32Handle.
							self palette notNil
								ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
							self nativeWindow registerControl: self.
	
							self originalWndProc: (self wndProc).
							self wndProc: self customWndProc.
							self isFocus
								ifTrue: [ self setFocus ].
						].! !

"June 6, 2007 -> 1:50:51"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
createVisible ^<Boolean>

	^true! !

"June 6, 2007 -> 1:50:52"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
customWndProc ^<APICallback>

	^self actualClass customWndProc! !

"June 6, 2007 -> 1:50:53"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
debugTest: msgCode <ExternalData> for: hwnd <ExternalData>

	Win32Control debugEvents
			ifTrue: [	Platform errorStream
									show: 'control winproc event: ';
									show: (MSG descriptionOf: msgCode asExternalProxy);
									show: ' window: ';
									print: hwnd;
									cr. 	].! !

"June 6, 2007 -> 1:50:55"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
destroyWin32Handle

	win32Handle notNil
		ifTrue: [	| hand <ExternalProxy> |
						self actualClass unregisterControl: self controlId.
						self nativeWindow unregisterControl: self.
						hand := self win32Handle.
						win32Handle := nil.		"We nil the handle before destroying so that we can tell
																we are dead if there is a focus shift caused by destroy"
						{{<user ExternalProxy DestroyWindow>
							handle: hand }}.		]! !

"June 6, 2007 -> 1:50:57"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
displayUpwardPopUpMenuAt: loc <Point> ^<Boolean>
	"Look up the parent chain for a popUp menu and display it, if there is one.
		Return true if one was found"

	| m <Menu> t <Timer> |
	m := self parent popUpMenuIfAbsent: [ ^false ].
	self	displayPopUpMenu: m
			at: loc
			forButton: #secondary.
	t := self session atIntervals: 1.0 do:
			[	m release.
				t release. ].
	^true! !

"June 6, 2007 -> 1:50:58"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
extendedWin32Style ^<ExternalData>

	^Win32 WS_EX_NOPARENTNOTIFY! !

"June 6, 2007 -> 1:50:59"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
handleMouseEvent: type <Symbol>
message: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>

	| loc <Point> |
	"Translate to be relative to our origin"
	loc := (lParam low @ lParam high) + self allocation enclosingRect origin.
	self handleMouseEvent: type at: loc! !

"June 6, 2007 -> 1:51:0"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 6, 2007 -> 1:51:1"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
invalidate: r <Region>

	self registerPaintTime.
	(self layoutStatus = Visual valid and: [ self hasWin32Handle ])
		ifTrue: [	| rect <Rect> nativerect <RECT> |

						nativerect := RECT new allocate.
						rect := r enclosingRect relativeTo: self allocation origin.
						nativerect
							left: rect left asInteger;
							right: rect right asInteger;
							top: rect top asInteger;
							bottom: rect bottom asInteger.
						{{<user ExternalProxy InvalidateRect>
							hwnd: self win32Handle
							RECT: nativerect
							erase: true}}.
						nativerect free.	]! !

"June 6, 2007 -> 1:51:2"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
nativePosition ^<Point>

	"We have to adjust for the fact that our allocation origin might not be 0@0"
	^nativePosition := self positionInContainingNativeWindow + self allocation enclosingRect origin! !

"June 6, 2007 -> 1:51:3"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc ^<HWND>

	^originalWndProc! !

"June 6, 2007 -> 1:51:4"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
originalWndProc: h <HWND>

	originalWndProc := h! !

"June 6, 2007 -> 1:51:5"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
redraw: flag <Boolean>
	"Tell the widget to start or stop redrawing (temporarily) when necessary.  This is usually used
		with a true arg before a large number of changes, followed by a send with a false arg."

	flag = self redraw
		ifFalse: [	redraw := flag.
						self hasWin32Handle
							ifTrue: [	self	sendMessage: Win32 WM_SETREDRAW
													wparam: flag asExternalData
													lparam: 0	]].! !

"June 6, 2007 -> 1:51:7"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	win32Handle notNil
		ifTrue: [	{{<user ExternalProxy EnableWindow>
								handle: self win32Handle
								state: self fullyEnabled asExternalData}}.	].
! !

"June 6, 2007 -> 1:51:8"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
setWindowText: t <Str>

	| label <CString> |
	label := CString for: t.
	{{<user ExternalProxy SetWindowText>
		handle: self win32Handle
		str: label}}.
	label free.! !

"June 6, 2007 -> 1:51:9"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
updateWindowDimensions
	"set the control's native size and position"

	| pos <Point> |

	pos := self nativePosition.
	self paintPending: false.
	{{<user ExternalProxy MoveWindow>
		handle: self win32Handle
		x: pos x asInteger
		y: pos y asInteger
		width: self allocation enclosedRect width asInteger
		height: self allocation enclosedRect height asInteger
		repaint: true asExternalData
	 }} asBoolean
			ifFalse: [ Win32 handleError ]! !

"June 6, 2007 -> 1:51:10"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := Win32 WS_CHILDWINDOW.
	self createVisible
		ifTrue: [ s := s externalBitOr: Win32 WS_VISIBLE. ].
	self fullyEnabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s! !

"June 6, 2007 -> 1:51:11"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc ^<ExternalProxy>

	^Window wndProcOf: self win32Handle! !

"June 6, 2007 -> 1:51:12"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private' !
wndProc: wp <ExternalProxy>

	Window wndProcOf: self win32Handle put: wp! !

"June 6, 2007 -> 1:51:13"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeKillFocus

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].! !

"June 6, 2007 -> 1:51:14"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	"We didn't request this, so windows must be requesting it, so
							record it"
						"We don't use becomeFocus here because that would cause another
							windows setFocus message"
						self session inputFocus: self.		]! !

"June 6, 2007 -> 1:51:16"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-message handling' !
contextMenuMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<Boolean>

	^self displayUpwardPopUpMenuAt:
			(self localFromGlobalPosition: lParam low @ lParam high)! !

"June 6, 2007 -> 1:51:17"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isFocusCandidate ^<Boolean>

	^self canBeFocusCandidate
		and: [ self hasWin32Handle
		and: [ self enabled ] ]! !

"June 6, 2007 -> 1:51:18"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'private-testing' !
isRectangularAndOpaque ^<Boolean>

	^true! !

"June 6, 2007 -> 1:51:19"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-to session' !
blinkFocus: shown <Boolean>
	
! !

"June 6, 2007 -> 1:51:20"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
buttonColorMsg: hdc <ExternalProxy> ^<ExternalData>

	"Should only get sent to buttons, which override this"
	self shouldNotHappen! !

"June 6, 2007 -> 1:51:21"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
commandWith: notifyCode <ExternalData> ^<ExternalData>

	"Subclasses should override to process command msgs"! !

"June 6, 2007 -> 1:51:22"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
drawItemMsg: data <DRAWITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 6, 2007 -> 1:51:23"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self parent nativeWindow hInstance! !

"June 6, 2007 -> 1:51:24"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
measureItemMsg: data <MEASUREITEMSTRUCT> ^<ExternalData>

	self shouldNotHappen! !

"June 6, 2007 -> 1:51:26"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self debugTest: msgCode for: hwnd.

	(self session handleIfFocusMsg: msgCode for: self wParam: wParam lParam: lParam) = 0
		ifTrue: [ ^0 ].

	msgCode @= Win32 WM_LBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #primaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONUP 
		ifTrue: [	self handleMouseEvent: #primaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_LBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #primaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDOWN 
		ifTrue: [	self handleMouseEvent: #secondaryButtonDown
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONUP 
		ifTrue: [	self handleMouseEvent: #secondaryButtonUp
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_RBUTTONDBLCLK
		ifTrue: [	self handleMouseEvent: #secondaryButtonDoubleClick
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_MOUSEMOVE 
		ifTrue: [	self handleMouseEvent: #mouseMove
								message: msgCode wParam: wParam lParam: lParam.
						^0 ].

	msgCode @= Win32 WM_CTLCOLORBTN
		ifTrue: [ ^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam) ].

	msgCode @= Win32 WM_DRAWITEM
		ifTrue: [	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger ].

	msgCode @= Win32 WM_MEASUREITEM
		ifTrue: [	| data <MEASUREITEMSTRUCT> |
						data := MEASUREITEMSTRUCT forProxy: lParam.
						data CtlType @= Win32 ODT_MENU
							ifFalse: [ ^Win32Control measureItemMsg: data for: data CtlID asSmallInteger ] ].

	(msgCode @= Win32 WM_COMMAND and: [ lParam @~= Win32 NULL ])
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						^0 ].

	msgCode @= Win32 WM_SETFOCUS
		ifTrue: [ self beforeSetFocus ].
	msgCode @= Win32 WM_KILLFOCUS
		ifTrue: [ self beforeKillFocus ].

	msgCode @= Win32 WM_CONTEXTMENU
		ifTrue: [ (self contextMenuMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam)
						ifTrue: [ ^0 ]. ].

	msgCode @= Win32 WM_QUERYNEWPALETTE 
		ifTrue: [	self queryPaletteMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_PALETTECHANGED 
		ifTrue: [	self paletteChangedMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam.
						^0 ].
	msgCode @= Win32 WM_SETCURSOR 
		ifTrue: [	^self setCursorMsg: msgCode hwnd: hwnd
								wParam: wParam lParam: lParam	 ].

	^{{<user ExternalProxy CallWindowProcA> 
		proc: self originalWndProc
		hwnd: hwnd
		msg: msgCode
		wparam: wParam
		lparam: lParam }}! !

"June 6, 2007 -> 1:51:28"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
notificationMsg: notifyCode <ExternalData>

	"Subclasses can extend to process notification msgs"

	Win32Control debugNotifications
			ifTrue: [ Platform errorStream
							show: 'control notification: ';
							print: notifyCode;
							show: ' window: ';
							print: self win32Handle;
							cr ].

	notifyCode @= Win32 BN_KILLFOCUS
		ifTrue: [ "%todo" ].
	notifyCode @= Win32 BN_SETFOCUS
		ifTrue: [ "%todo" ].
! !

"June 6, 2007 -> 1:51:29"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalProxy>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 6, 2007 -> 1:51:30"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
setFocus

	ignoreNextFocusSet := true.
	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 6, 2007 -> 1:51:31"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil	
		ifTrue: [ self createNativeWindow ].
	^win32Handle! !

"June 6, 2007 -> 1:51:32"!

! (Delta mirrorFor: #Win32Control) methodsFor: 'testing' !
isFocus ^<Boolean>

	^isFocus! !

"June 6, 2007 -> 1:51:52"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:54"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:55"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:56"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:57"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:58"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:51:59"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:0"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:0"!

Delta define: #Window as: (
(Class subclassOf: 'InstanceCritical |> Object' instanceVariables: 'natural <Rect> min <Rect> max <Rect>
			"These have to be cached for access so that the UI thread doesn''t have to execute
			  widget code"

win32Handle <HWND>
medium <Medium>
session <Session>
visual <Visual>
parent <Window>
			"If parent is non-nil, then this window is owned by another"
backgroundPainter <Painter>

desiredPosition <Point> "If nil, then use default position"
extent <Point>

scratchRECT <RECT>
			"A temporary Win32 RECT structure used for invalidations.  This must be
		     per window so we don''t have to use critical regions to access it"

mostRecentInputFocus <Visual>
			"If not nil, points to the most recent input focus, so we can try to restore the
				input focus to the right spot if the window is inactive and becomes active
				again without a new focus being chosen.  We have to be careful not to
				hold onto this too long, since it can cause a memory leak.  To that end,
				frequent checks are made to see if it is attached; if it is not, this is purged"
initialInputFocus <Visual>
			"If not nil, points to a visual that should become the input focus once the window
				is layed out. This is purged after use to prevent a memory leak."
menu <Menu>
			"If not nil, is the menu bar"
popUpMenu <Menu>
			"If not nil, then is a popup menu that is currently showing"
optimizeIncrementalLayout <Boolean>
ignoreNextFocusSet <Boolean>

refreshInterval <Float>
			"Time in seconds for the maximum time between refreshes."
nextPaintTime <Float>
			"If not nil, then if any paint is needed, it should occur
				no later than this time"
paintPending <Boolean>
useDisplayBuffering <Boolean>
			"If true, use double buffering for flicker free display"
toClose <[Window]>
			"This block is executed with the receiver when the user tries to close the window.  By default,
				this just destroys the window quietly"
enabled <Boolean>
			"Indicates whether the window is enabled/disabled"
cursor <Cursor>
deferredPaintRegion <Rect>
controls <Extensible[Win32Control]>
palette <Palette>
haveErased <Boolean>
		') classVariables: 'DefaultWndProc <ExternalProxy>
WindowsMessageHandlers  <VarDict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>
			"Dictionary mapping message codes to dispatch blocks"
BufferingPossible <Boolean>
			"If false, then all double buffering is disabled"
		'; protocols: 'VisualParent; RelayoutTarget') !


"June 6, 2007 -> 1:52:2"!

(Delta mirrorFor: #Window)
comment: 
'Native windows, with a fairly machine independent interface
(except for methods with ''win32'' in their names).

Tags: %User %UI

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 6, 2007 -> 1:52:3"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'custom messages' !
LAYOUT ^<ExternalData>
	"This is by the UI thread to tell a window's session process to layout a window.  This has
	  to be done through the message queue so that the layout code runs in the window's session
	  process.  lParam low is width, and lParam high is height."

	^16r400! !

"June 6, 2007 -> 1:52:4"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible ^<Boolean>

	BufferingPossible isNil
		ifTrue: [ BufferingPossible := true ].
	^BufferingPossible! !

"June 6, 2007 -> 1:52:5"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'debugging' !
bufferingPossible: f <Boolean>
	"If this is set to false, all double buffering will be disabled, usually for debugging
		purposes."

	BufferingPossible := f! !

"June 6, 2007 -> 1:52:6"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Cursor ^<ExternalProxy>

	^{{<user ExternalProxy LoadCursorA> arg: 0 arg: Win32 IDC_ARROW}}! !

"June 6, 2007 -> 1:52:7"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWin32Icon ^<ExternalProxy>

	^{{<user ExternalProxy LoadIconA> arg: 0 arg: Win32 IDI_APPLICATION}}! !

"June 6, 2007 -> 1:52:8"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
defaultWndProc ^<ExternalProxy>

	"Don't need a critical region because duplicate inits are no problem"
	DefaultWndProc isNil
		ifTrue: [	DefaultWndProc := Platform DLLLookup: 'DefWindowProcA' in: 'user' ].
	^DefaultWndProc! !

"June 6, 2007 -> 1:52:10"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
parentOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetParent> wnd: w}}! !

"June 6, 2007 -> 1:52:11"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> ^<HWND>

	^{{<user ExternalProxy GetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC}}! !

"June 6, 2007 -> 1:52:11"!

! (Delta mirrorFor: #Window) classSide methodsFor: 'restricted-win32 functions' !
wndProcOf: w <HWND> put: newWinProc <HWND> ^<HWND>

	^{{<user ExternalProxy SetWindowLongA> wnd: w attr: Win32 GWL_WNDPROC value: newWinProc}}! !

"June 6, 2007 -> 1:52:12"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
addNonLocalCount: delta <Int>
	
	! !

"June 6, 2007 -> 1:52:14"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containerBackgroundPainter ^<Painter>

	^Painter defaultBackground! !

"June 6, 2007 -> 1:52:15"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
containsFocus: flag <Boolean>

	flag
		ifTrue: [	self session activeWindow: self.
						self mostRecentInputFocus: session inputFocus.	].
	"We don't need to remove the active window ifFalse because the session does that"! !

"June 6, 2007 -> 1:52:16"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayNowIfInvalid
	"Redraw any invalid areas before proceeded"

	self display! !

"June 6, 2007 -> 1:52:18"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
displayPopUpMenu: menu <Menu> at: loc <Point> forButton: button <Symbol>

	| gloc <Point> flags <ExternalData> |
	popUpMenu := menu.

	flags := Win32 TPM_LEFTALIGN.
	button = #left
		ifTrue: [ flags := flags externalBitOr: Win32 TPM_LEFTBUTTON ]
		ifFalse: [ flags := flags externalBitOr: Win32 TPM_RIGHTBUTTON ].

	gloc := self globalFromLocalPosition: loc.
	{{<user ExternalProxy TrackPopupMenu>
		handle: menu win32Handle
		flags: flags
		x: gloc x
		y: gloc y
		reserved: 0
		window: self win32Handle
		rect: Win32 NULL
	}} asBoolean
		ifFalse: [ Win32 getLastError @= Win32 ERROR_POPUP_ALREADY_ACTIVE
							ifFalse: [ Win32 handleError ].
						].

	popUpMenu := nil.
! !

"June 6, 2007 -> 1:52:19"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
invalidate: r <Region> forChild: child <Visual>

	self invalidate: (r enclosingRect translatedBy: child position)! !

"June 6, 2007 -> 1:52:20"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
isAttached ^<Boolean>

	^true! !

"June 6, 2007 -> 1:52:21"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
nativeWindow ^<Window | Win32Control>

	^self! !

"June 6, 2007 -> 1:52:22"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
parentVisualOfChild ^<Visual>

	self shouldNotHappen! !

"June 6, 2007 -> 1:52:24"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
popUpMenuIfAbsent: f <[^X def]> ^<Menu | X>

	^f value! !

"June 6, 2007 -> 1:52:25"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInContainingNativeWindowOf: child <Visual> ^<Point>

	^child position! !

"June 6, 2007 -> 1:52:26"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
positionInTopWindowOf: child <Visual>

	^child position! !

"June 6, 2007 -> 1:52:28"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollIfNeededToMakeVisible: area <Rect>
relativeTo: v <Visual>
minimizeMotion: minimizeMotion <Boolean>


	! !

"June 6, 2007 -> 1:52:29"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
scrollMeOrAParentBy: distance <Int> vertical: vertical <Boolean>

	"do nothing"! !

"June 6, 2007 -> 1:52:30"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
topWindow ^<Window>

	^self! !

"June 6, 2007 -> 1:52:31"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> fromChild: child <Visual> ^<Point>

	"Translate p from the child's coordinates to ours"
	^p translatedBy: child position! !

"June 6, 2007 -> 1:52:33"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translate: p <Point> toChild: child <Visual> ^<Point>

	"Translate p from our coordinates to the child's"
	^p relativeTo: child position! !

"June 6, 2007 -> 1:52:34"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> fromChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r translatedBy: child position! !

"June 6, 2007 -> 1:52:35"!

! (Delta mirrorFor: #Window) methodsFor: 'VisualParent impl' !
translateRect: r <Rect> toChild: child <Visual> ^<Rect>

	"Translate p from the child's coordinates to ours"
	^r relativeTo: child position! !

"June 6, 2007 -> 1:52:36"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
allocation ^<Region>

	^Point origin corner: self extent! !

"June 6, 2007 -> 1:52:38"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter ^<Painter>
	"The paint for the window background.  This can be automatically derived from the
	 background painter for the visual.  It can also be set explicitly."

	^self hasBackgroundPainter
		ifTrue: [ backgroundPainter ]
		ifFalse: [ backgroundPainter := self visual backgroundPainter ]! !

"June 6, 2007 -> 1:52:39"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
backgroundPainter: p <Painter>

	backgroundPainter := p! !

"June 6, 2007 -> 1:52:40"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor ^<Cursor>

	^cursor! !

"June 6, 2007 -> 1:52:42"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
cursor: c <Cursor>

	cursor := c.! !

"June 6, 2007 -> 1:52:43"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
desiredPosition: p <Point>

	desiredPosition := p! !

"June 6, 2007 -> 1:52:44"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled ^<Boolean>

	^enabled! !

"June 6, 2007 -> 1:52:45"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
enabled: flag <Boolean>

	self enabled = flag
		ifFalse: [	self setEnabled: flag ].! !

"June 6, 2007 -> 1:52:46"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
extent ^<Point>

	^extent! !

"June 6, 2007 -> 1:52:48"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasParent ^<Boolean>

	^parent notNil! !

"June 6, 2007 -> 1:52:49"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasSession ^<Session>

	^session notNil! !

"June 6, 2007 -> 1:52:50"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
hasWin32Handle ^<Boolean>

	^win32Handle notNil! !

"June 6, 2007 -> 1:52:51"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
initialInputFocus: v <Visual>

	initialInputFocus := v! !

"June 6, 2007 -> 1:52:53"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
max ^<Rect>

	^max! !

"June 6, 2007 -> 1:52:54"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
medium ^<Medium>

	^medium! !

"June 6, 2007 -> 1:52:55"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu ^<Menu>

	^menu! !

"June 6, 2007 -> 1:52:56"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
menu: m <Menu>

	menu isNil
		ifFalse: [ menu release ].
	menu := m.
	menu window: self.
	self hasWin32Handle
		ifTrue: [ self setNativeMenu ]! !

"June 6, 2007 -> 1:52:58"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
min ^<Rect>

	^min! !

"June 6, 2007 -> 1:52:59"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
mostRecentInputFocus: v  <Visual>

	mostRecentInputFocus := v! !

"June 6, 2007 -> 1:53:0"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
name: nm <Str>

	"By default, do nothing. Subclasses with a title bar can override this"! !

"June 6, 2007 -> 1:53:1"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
natural ^<Rect>

	^natural! !

"June 6, 2007 -> 1:53:2"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
noPalette

	palette := nil! !

"June 6, 2007 -> 1:53:4"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout ^<Boolean>
^false.
	^optimizeIncrementalLayout! !

"June 6, 2007 -> 1:53:5"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
optimizeIncrementalLayout: f <Boolean>

	(f ~= optimizeIncrementalLayout and: [ self hasWin32Handle ])
		ifTrue: [ self changing ].
	optimizeIncrementalLayout := f.! !

"June 6, 2007 -> 1:53:6"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette ^<Palette>

	^palette! !

"June 6, 2007 -> 1:53:7"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
palette: p <Palette>

	p == palette
		ifTrue: [ ^self ].
	self assert: [ palette isNil ].
	palette := p! !

"June 6, 2007 -> 1:53:9"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent ^<Window>

	^parent! !

"June 6, 2007 -> 1:53:10"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
parent: p <Window>
	"This message must be sent before the window handle is created"

	parent := p! !

"June 6, 2007 -> 1:53:11"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval ^<Float>

	^refreshInterval! !

"June 6, 2007 -> 1:53:12"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
refreshInterval: d <Float>
	"Wait no longer than this amount of time (in seconds) between
		paint operations, if possible"

	refreshInterval := d! !

"June 6, 2007 -> 1:53:13"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
session ^<Session>

	^session! !

"June 6, 2007 -> 1:53:15"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
setNativeMenu

	{{<user ExternalProxy SetMenu>
		wnd: self win32Handle
		menu: self menu win32Handle
	}} asBoolean
		ifFalse: [ Win32 handleError ]! !

"June 6, 2007 -> 1:53:16"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose ^<[Window]>

	^toClose! !

"June 6, 2007 -> 1:53:17"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
toClose: blk <[Window]>

	toClose := blk! !

"June 6, 2007 -> 1:53:19"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering ^<Boolean>

	^useDisplayBuffering! !

"June 6, 2007 -> 1:53:20"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
useDisplayBuffering: f <Boolean>

	useDisplayBuffering := f! !

"June 6, 2007 -> 1:53:21"!

! (Delta mirrorFor: #Window) methodsFor: 'accessing' !
visual ^<Visual>

	^visual! !

"June 6, 2007 -> 1:53:22"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
close
	"Close and destroy the window.  This causes release to be sent to the window and its visual"

	self session aboutToDestroyWindow: self.
	{{<user ExternalProxy DestroyWindow> arg: win32Handle}}.
! !

"June 6, 2007 -> 1:53:24"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
ignoreNextFocusSet: flag <Boolean>

	ignoreNextFocusSet := flag! !

"June 6, 2007 -> 1:53:25"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate

	self visual layoutStatus > Visual invalid
		ifTrue: [ self invalidate: self allocation enclosingRect	].! !

"June 6, 2007 -> 1:53:27"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
invalidate: r <Region>

	| rect <Rect> |

	self registerPaintTime.
	rect := r enclosingRect.
	(self scratchRECT)
		left: rect left asInteger;
		right: rect right asInteger;
		top: rect top asInteger;
		bottom: rect bottom asInteger.
	{{<user ExternalProxy InvalidateRect>
		hwnd: self win32Handle
		RECT: self scratchRECT
		erase: false asExternalData}}! !

"June 6, 2007 -> 1:53:28"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
makeActive
	"Make this the active window"

	{{<user ExternalProxy SetForegroundWindow> hwnd: self win32Handle }}.! !

"June 6, 2007 -> 1:53:29"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
release

	scratchRECT free.

	self session unregisterWindow: self.

	visual notNil
		ifTrue: [	visual detaching; release.
						visual := nil.	].

	win32Handle := nil.

	self hasMenu
		ifTrue: [ self menu release ].
	mostRecentInputFocus := nil.
	menu := nil.
	popUpMenu := nil.
	toClose := nil.
	controls := nil.
! !

"June 6, 2007 -> 1:53:30"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
requestClose

	self toClose value: self.! !

"June 6, 2007 -> 1:53:31"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
show
	"Make the window visible"

	{{<user ExternalProxy ShowWindow>
			window: self win32Handle
			nCmdShow: self nCmdShow}}.
	! !

"June 6, 2007 -> 1:53:33"!

! (Delta mirrorFor: #Window) methodsFor: 'control' !
showModal
	"Make the window visible as a modal window"

	self session addModalWindow: self.
	self show.
	! !

"June 6, 2007 -> 1:53:34"!

! (Delta mirrorFor: #Window) methodsFor: 'debugging' !
dumpOn: strm <CharOutputStream>

Transcript show: self class name, ' extent: '; print: self extent; show: ' hwnd: '; print: self win32Handle; cr.
	self visual dumpOn: strm indent: 1.! !

"June 6, 2007 -> 1:53:36"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
character: c <Character> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^(self visual character: c focus: focus event: ev)
		or: [	c = Character tab
					onTrue: [ self handleTabEvent: ev ] ]! !

"June 6, 2007 -> 1:53:37"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyDown: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	(self visual keyDown: key focus: focus event: ev)
		ifTrue: [ ^true ].
		
	(key = #TAB and: [ ev ctrlPressed ])
		ifTrue: [ self handleTabEvent: ev.	^true ].
	key = #F1 ifTrue: [ Profiler start.	^true ].
	key = #F2 ifTrue: [ Profiler stop.	^true ].
	^false	! !

"June 6, 2007 -> 1:53:38"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
keyUp: key <Symbol> focus: focus <Visual> event: ev <UIEvent> ^<Boolean>

	^self visual keyUp: key focus: focus event: ev
! !

"June 6, 2007 -> 1:53:40"!

! (Delta mirrorFor: #Window) methodsFor: 'event handling' !
mouseEvent: type <Symbol> at: loc <Point> event: ev <UIEvent> ^<Boolean>

	^self visual layoutStatus = Visual valid
		and: [ 	| grabGotIt <Boolean> |
						grabGotIt := self session
												mouseEvent: type
												at: loc
												event: ev.
						grabGotIt or: [	(self visual renderingRegion inParentContainsPoint: loc)
												and: [	Sampler notNil
																ifTrue: [ Sampler in: self visual sampleEvent: type at: loc - self visual position event: ev ].
															self visual
																mouseEvent: type
																at: loc - self visual position
																event: ev	] ] ]
! !

"June 6, 2007 -> 1:53:41"!

! (Delta mirrorFor: #Window) methodsFor: 'initialization' !
initSession: sess <Session>
visual: vis <Visual>

	medium := sess medium.
	session := sess.
	visual := vis.

	(self visual)
		parent: self id: 1.

	self showTimes
		ifTrue: [ Transcript show: 'prefs: '; print: [ self computePreferences ] time; cr. ]
		ifFalse: [ self computePreferences ].

	scratchRECT := RECT new allocate.
	self optimizeIncrementalLayout: true.
	ignoreNextFocusSet := false.

	self refreshInterval: self defaultRefreshInterval.
	self paintPending: false.
	self useDisplayBuffering: true.

	self toClose: [ :w <Window> | w close ].
	self enabled: true.
	controls := IdentitySet[Win32Control] new.
	self haveErased: false.! !

"June 6, 2007 -> 1:53:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
activeMenu ^<Menu>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil
		ifTrue: [ popUpMenu ]
		ifFalse: [ menu ]! !

"June 6, 2007 -> 1:53:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeQueuedMessage

	"%remove this and calls to it"! !

"June 6, 2007 -> 1:53:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beforeSetFocus

	ignoreNextFocusSet
		ifTrue: [	"We requested the focus, and have already recorded it, so
							ignore this."
						ignoreNextFocusSet := false.	]
		ifFalse: [	self visual layoutValid
							ifTrue: [	"We didn't request this, so windows must be requesting it, so
												record it"
											self findInputFocus	]	].! !

"June 6, 2007 -> 1:53:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
beginPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>  ^<HDC>

	^{{<user HDC BeginPaint> arg: hwnd arg: ps}}! !

"June 6, 2007 -> 1:53:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
buildWin32Handle
	"Subclasses must implement to create the appropriate type of window handle &
	  store it in win32Handle"

	self subclassResponsibility! !

"June 6, 2007 -> 1:53:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callAsyncDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>
	"like callDefWndProcFor:msgCode:wParam:lParam:
			but is asynchronous"

	^{{<user ExternalProxy DefWindowProcA async>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 6, 2007 -> 1:53:50"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
callDefWndProcFor: hwnd <HWND>
msgCode: msgCode <ExternalData>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy DefWindowProcA>
			hwnd: hwnd
			value: msgCode
			value: wParam
			value: lParam
	  }}! !

"June 6, 2007 -> 1:53:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
computePreferences

	natural := Point origin corner: self visual natural enclosingRect extent.
	min := Point origin corner: self visual min enclosingRect extent.
	max := Point origin corner: self visual max enclosingRect extent.! !

"June 6, 2007 -> 1:53:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
controls ^<Extensible[Win32Control]>

	^controls! !

"June 6, 2007 -> 1:53:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultRefreshInterval ^<Float>

	^0.25! !

"June 6, 2007 -> 1:53:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
defaultWndProc ^<ExternalProxy>

	^self actualClass defaultWndProc! !

"June 6, 2007 -> 1:53:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion ^<Rect>

	^deferredPaintRegion! !

"June 6, 2007 -> 1:53:57"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
deferredPaintRegion: r <Rect>

	deferredPaintRegion := r! !

"June 6, 2007 -> 1:53:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredXPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition x asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 6, 2007 -> 1:54:0"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
desiredYPos ^<ExternalData>

	^desiredPosition isNil
		ifFalse: [ desiredPosition y asInteger ]
		ifTrue: [  Win32 CW_USEDEFAULT ]! !

"June 6, 2007 -> 1:54:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
display

	| subs <Cltn[Win32Control]> |
	self withCanvasDo:
			[ :can <Canvas> |
				| paintBlk <[^Object]> |	
				paintBlk := 
					[	self paintBackgroundOn: can.
						self displayVisualIfCanOn: can.
						can shallowFlush.  ].
				self showTimes
					ifTrue: [  Transcript show: 'paint: '; print: paintBlk time; cr. ]
					ifFalse: [ paintBlk value ].
				can hasSubwindowsToDisplay
					ifTrue: [ subs := can takeSubwindowsToDisplay ].
			].
	subs notNil
		ifTrue: [	subs do:
							[ :sub <Win32Control> |
								"%hack: the handle test should not be 
									necessary; something is screwed up"
								sub hasWin32Handle
									ifTrue: [	sub sendMessage: Win32 WM_PAINT
														wparam: 0 lparam: 0.
												].
							].
					 ]! !

"June 6, 2007 -> 1:54:3"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
displayVisualIfCanOn: canvas <Canvas>

	self session visualCriticalWouldBlock
		ifTrue: [ self recordDeferredPaint: canvas clippingRect ]
		ifFalse: [	self paintOccuring.
						self visual displayOn: canvas.	]! !

"June 6, 2007 -> 1:54:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
endPaint: hwnd <HWND>  paintStructure: ps <PAINTSTRUCT>

	^{{<user ExternalProxy EndPaint> arg: hwnd arg: ps}}! !

"June 6, 2007 -> 1:54:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
extent: e <Point>
	"Change the window's extent.  This will cause a relayout
		to happen later, which will record the extent."

	| pos <Point> adjusted <Rect> |
	adjusted := self fitToMedium: e.
	pos := self getPosition.
	{{<user ExternalProxy MoveWindow>
		hwnd: self win32Handle
		x: pos x
		y: pos y
		width: adjusted x
		height: adjusted y
		repaint: true asExternalData
	}} asBoolean 
		ifFalse: [ Win32 handleError ].! !

"June 6, 2007 -> 1:54:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
findInputFocus

	"find some non-native visual
	  within us to give the input focus to."

	"If there is already a focus, and it is in this window, then we are in a callback caused
	  by our own attempt to set the focus, so do nothing."
	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ ^self ].

	"If we have a valid memory of what our input focus was last time, use it"
	self purgeMostRecentFocusIfNeeded.
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus topWindow = self ])
		ifTrue: [ "Search to see if the most recent one is still a reachable, valid candidate"
					 "%todo: we could optimize this by adding another call to the heirarchy called
						verifyFocusCandidate which sends verifyFocusCandidate:self up the heirarchy,
						giving pacifiers etc. a chance to deny it the focus.  This would be MUCH faster
						than the following loop."
					"Also note that we use session inputFocus: rather than becomeFocus, because this
						 thing was previously the focus, so we don't want to do things like scroll it"
					 self visual focusCandidatesDo:
						[ :cand <Visual> |
							cand = mostRecentInputFocus
								ifTrue: [	self session inputFocus: cand.

												^self		"^^^^^^^^^^^^^"		] ]. ].

	"There is no valid previous focus to reuse, so just choose the first one"
	(self visual firstFocusCandidateIfAbsent: [ ^self ])
		becomeFocus.
! !

"June 6, 2007 -> 1:54:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
fitToMedium: clientExtent <Point>  ^<Point>
	"takes a client extent, and returns a window extent adjusted so that it will fit on the screen"

	| normal <Point> withoutCaption <Point> captionHeight <Int> adjClient <Point> |	
	normal := (self windowSizeForClientAreaSize: clientExtent) min: self medium extent.
	withoutCaption := (self windowSizeWithoutCaptionForClientAreaSize: clientExtent) min: self medium extent.
	captionHeight := normal y - withoutCaption y.
	^self windowSizeForClientAreaSize:
			 (clientExtent x min: self medium extent x)
		@ ((clientExtent y + captionHeight min: self medium extent y) - captionHeight).! !

"June 6, 2007 -> 1:54:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
getPosition ^<Point>

	{{<user ExternalProxy GetWindowRect>
		hwnd: self win32Handle
		rect: self scratchRECT
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	^self scratchRECT left @ self scratchRECT top! !

"June 6, 2007 -> 1:54:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
globalFromLocalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ClientToScreen>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:54:12"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
handleTabEvent: ev <UIEvent>

	ev shiftPressed
		ifTrue: [ self moveFocusBack ]
		ifFalse: [ self moveFocusForward ]! !

"June 6, 2007 -> 1:54:13"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasBackgroundPainter ^<Boolean>

	^backgroundPainter notNil! !

"June 6, 2007 -> 1:54:14"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
hasMenu ^<Boolean>
	"Returns the menu that is currently active, if there is one.  It may either be the top level menu,
	  or a popup menu over the window"

	^popUpMenu notNil or: [ menu notNil ]! !

"June 6, 2007 -> 1:54:15"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased ^<Boolean>

	^haveErased! !

"June 6, 2007 -> 1:54:17"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
haveErased: f <Boolean>

	haveErased := f! !

"June 6, 2007 -> 1:54:19"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initWindowsMessageHandlers

	WindowsMessageHandlers
		at: Win32 WM_CLOSE	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w closeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETCURSOR	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setCursorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PAINT	put:
				[ :w <Window> :msg  <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paintMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_ERASEBKGND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w eraseBackgroundMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CTLCOLORBTN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w buttonColorMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DRAWITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w drawItemMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyDownMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KEYUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w keyUpMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CHAR	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w characterMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"mouse events are handled by a common event routine"
		at: Win32 WM_LBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_LBUTTONDBLCLK	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #primaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONDOWN	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MBUTTONUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #middleButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDOWN put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDown at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONUP put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonUp at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_RBUTTONDBLCLK put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #secondaryButtonDoubleClick at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_MOUSEMOVE put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w handleMouseEvent: #mouseMove at: lParam lowSigned @ lParam highSigned msg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];

		at: Win32 WM_MEASUREITEM	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w measureItemMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SETFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w setFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_KILLFOCUS	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w killFocusMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_COMMAND	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w commandMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_GETMINMAXINFO	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w getMinMaxInfoMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_SIZE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w sizeMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_NCDESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w ncDestroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_DESTROY	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w destroyMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_CAPTURECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w captureChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_INITMENUPOPUP	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w initMenuPopupMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_QUERYNEWPALETTE	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w queryPaletteMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];
		at: Win32 WM_PALETTECHANGED	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w paletteChangedMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		"---------- Custom messages"
		at: Window LAYOUT	put:
				[ :w <Window> :msg <ExternalData> :hwnd <HWND> :wParam <ExternalData> :lParam <ExternalData> |
					w layoutMsg: msg hwnd: hwnd wParam: wParam lParam: lParam ];

		yourself! !

"June 6, 2007 -> 1:54:21"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
initialInputFocus ^ <Visual>

	^initialInputFocus! !

"June 6, 2007 -> 1:54:22"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
layout: extent <Point>

	| firstLayout <Boolean> |

	firstLayout := self visual layoutStatus = Visual invalid.
 	self showTimes
		ifTrue: [	Transcript show: 'layout: '; print: [ 
								self visual allocationInParent: (0@0 corner: extent).
						] time; cr. ]
		ifFalse: [	self visual allocationInParent: (0@0 corner: extent). ].

	"We have to do this now because we can't set the input focus until layout is
		complete, since the containing native window must be accessed, etc."
	firstLayout
		ifTrue: [	self palette notNil
							ifTrue: [ self recursiveRealizePaletteForeground: true updateColors: true. ].
						(self initialInputFocus notNil and: [ self initialInputFocus isFocusCandidate ])
							ifTrue: [		self initialInputFocus becomeFocus.
												self initialInputFocus: nil 	"Not needed anymore, prevent memory leak"	]
							ifFalse: [	self findInputFocus ]
					  ]! !

"June 6, 2007 -> 1:54:23"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
localFromGlobalPosition: p <WinPOINT> ^<WinPOINT>

	| wp <WinPOINT> result <WinPOINT> |
	wp := WinPOINT new allocate.
	wp x: p x; y: p y.
	{{<user ExternalProxy ScreenToClient>
			handle: self win32Handle
			point: wp
	}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := wp x @ wp y.
	wp free.
	^result! !

"June 6, 2007 -> 1:54:25"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
menuCommandForItem: id <Int>

	(MenuItem itemFor: id)
		execute! !

"June 6, 2007 -> 1:54:26"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusBack

	(self visual lastFocusCandidateBefore: self session inputFocus)
		becomeFocus! !

"June 6, 2007 -> 1:54:27"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
moveFocusForward

	(self visual nextFocusCandidateAfter: self session inputFocus)
		becomeFocus! !

"June 6, 2007 -> 1:54:28"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nCmdShow ^<ExternalProxy>

	^{{primitiveWindowsNCmdShow}}! !

"June 6, 2007 -> 1:54:30"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime ^<Float>

	^nextPaintTime! !

"June 6, 2007 -> 1:54:31"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
nextPaintTime: t <Float>

	nextPaintTime := t! !

"June 6, 2007 -> 1:54:32"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintBackgroundOn: can <Canvas>

	can withPainter: self backgroundPainter do:
		[ can displayFilledRectangle:
			(Point origin corner: self allocation enclosingRect extent) ].! !

"June 6, 2007 -> 1:54:34"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
paintOccuring

	self nextPaintTime: Time clockValue + self refreshInterval.
	self paintPending: false.
	self session paintOccuredFor: self.! !

"June 6, 2007 -> 1:54:35"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
parentHandle ^<ExternalData>

	^parent isNil
		ifFalse: [ parent win32Handle ]
		ifTrue: [ Win32 NULL ]! !

"June 6, 2007 -> 1:54:36"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
purgeMostRecentFocusIfNeeded

	"%kludge: This should be called occasionally (in user time) to avoid memory leaks caused by
	  a pointer to a zombie visual"
	"%todo: this isn't called yet.  Set up a scanner that sends this to all windows every ten seconds or
	   so."
	(mostRecentInputFocus notNil and: [ mostRecentInputFocus isAttached not ])
		ifTrue: [ mostRecentInputFocus := nil ]! !

"June 6, 2007 -> 1:54:37"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordDeferredPaint: region <Rect> 

	self deferredPaintRegion:
		(self deferredPaintRegion isNil
			ifTrue: [ region ]
			ifFalse: [ self deferredPaintRegion merge: region ]
		)! !

"June 6, 2007 -> 1:54:38"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
recordExtent

		self setExtent: self trueClientAreaExtent.! !

"June 6, 2007 -> 1:54:40"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
registerPaintTime

	self paintPending
		ifFalse: [	self paintPending: true.
						self nextPaintTime: Time clockValue + self refreshInterval.
						self session schedulePaintFor: self at: self nextPaintTime.	].! !

"June 6, 2007 -> 1:54:41"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeeded

	self relayoutIfNeededForExtent: self extent! !

"June 6, 2007 -> 1:54:42"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
relayoutIfNeededForExtent: e <Point>

	self visual needsRelayout
		ifTrue: [ self layout: (self visual max enclosingRect extent min: e) ].
	self invalidate.! !

"June 6, 2007 -> 1:54:44"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
scratchRECT ^<RECT>

	^scratchRECT! !

"June 6, 2007 -> 1:54:45"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setCursor ^<ExternalData>

	^cursor isNil
		ifFalse: [	{{<user ExternalProxy SetCursor> handle: cursor win32Handle}}.
						1 ]
		ifTrue: [ 0 ]! !

"June 6, 2007 -> 1:54:46"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setEnabled: flag <Boolean>

	enabled := flag.
	self hasWin32Handle
		ifTrue: [	{{<user ExternalProxy EnableWindow async>
								handle: self win32Handle
								state: enabled asExternalData}}.	].! !

"June 6, 2007 -> 1:54:47"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setExtent: e <Point>

	extent := e! !

"June 6, 2007 -> 1:54:49"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
setName: nm <Str>

	self hasWin32Handle
		ifTrue: [	| title <CString> |
						title := CString for: nm.
						[	{{<user ExternalProxy SetWindowTextA>
											hwnd: self win32Handle
											title: title
							}} asBoolean
								ifFalse: [ Win32 handleError ].
						] ensure: [ title free ]
					 ]! !

"June 6, 2007 -> 1:54:51"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
shouldCallDefaultHandlerAsynchronouslyFor: msgCode <ExternalData>  ^<Boolean>

	^msgCode @= Win32 WM_SYSCOMMAND		"so that window moves let other sessions repaint"! !

"June 6, 2007 -> 1:54:52"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
showTimes ^<Boolean>
	"Report preference, layout, and painting times on the transcript"

	^false! !

"June 6, 2007 -> 1:54:53"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtent ^<Point>

	^self trueClientAreaExtentFor: self win32Handle! !

"June 6, 2007 -> 1:54:54"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
trueClientAreaExtentFor: hwnd <ExternalData> ^<Point>

	| extent <Point> rect <RECT> |
	rect := RECT new allocate.
	{{<user RECT GetClientRect> arg: hwnd arg: rect}}.
	extent := (rect right - rect left) @ (rect bottom - rect top).
	rect free.
	^extent! !

"June 6, 2007 -> 1:54:55"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Handle: h <HWND>

	win32Handle := h! !

"June 6, 2007 -> 1:54:56"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
win32Style ^<ExternalData>

	| s <ExternalData> |
	s := 0.
	self enabled
		ifFalse: [ s := s externalBitOr: Win32 WS_DISABLED ].
	^s
! !

"June 6, 2007 -> 1:54:58"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent windowStyle: self win32Style! !

"June 6, 2007 -> 1:54:59"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeForClientAreaSize: extent <Point> windowStyle: style <ExternalData>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	| r <RECT> result <Point> |
	r := RECT new allocate.
	r top: 0; left: 0; right: extent x asInteger; bottom: extent y asInteger.
	{{<user ExternalProxy AdjustWindowRect>
				 rect: r style: style hasMenu: self hasMenu asExternalData}} asBoolean
		ifFalse: [ Win32 handleError ].
	result := (r right - r left) @ (r bottom - r top).
	r free.
	^result! !

"June 6, 2007 -> 1:55:1"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowSizeWithoutCaptionForClientAreaSize: extent <Point>  ^<Point>
	"returns an integral point that is the correct window size for a desired client area size"

	^self windowSizeForClientAreaSize: extent
			windowStyle: (self win32Style externalBitAnd: (Win32 WS_CAPTION asSmallInteger bitInvert))! !

"June 6, 2007 -> 1:55:2"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
windowsMessageHandlers ^<Dict[ ExternalData,
																 [Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData] ]>

	"Don't need critical region since duplicate inits are no problem"
	WindowsMessageHandlers isNil
		ifTrue: [	WindowsMessageHandlers :=
							CustomDictionary[ExternalData,[Window, ExternalData, HWND, ExternalData, ExternalData, ^ExternalData]]
									withCompareBlock: [ :k1 <ExternalData> :k2 <ExternalData> |    k1 @= k2 ]
									hashBlock: [ :k <ExternalData> |  k hash ].
						self initWindowsMessageHandlers.
						].
	^WindowsMessageHandlers! !

"June 6, 2007 -> 1:55:4"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withBufferedCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^self withDirectCanvasDo:
		[ :directCanvas <Canvas> |
			| invalid <Rect> oldpal <Win32Handle> |
			invalid := directCanvas clippingRect.

			self session
				withBufferCanvasFor: invalid
				do: [ :bufferCanvas <Canvas> :buffer <HBITMAP> |

						self palette isNil
							ifFalse: [ oldpal := bufferCanvas win32Palette: self palette win32Handle ].

						"draw on the buffer canvas"
						drawing value: bufferCanvas.
						bufferCanvas shallowFlush.

						"Now, copy the buffer bits onto the screen"
						directCanvas atOffset: invalid origin
							do: [ bufferCanvas atOffset: invalid origin 
								do: [	directCanvas
											bitBlt: bufferCanvas
											extent: invalid extent
											op: UI ropCopy.		].	].
						 oldpal notNil
								ifTrue: [ 	Palette debugging
													ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
												bufferCanvas win32Palette: oldpal ]. 
						].	
		]! !

"June 6, 2007 -> 1:55:5"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withCanvasDo: drawing <[Canvas,^X def]> ^<X>

	^(self useDisplayBuffering and: [ Window bufferingPossible ])
		ifFalse: [	self withDirectCanvasDo: drawing ]
		ifTrue: [	self withBufferedCanvasDo: drawing ]! !

"June 6, 2007 -> 1:55:6"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDCDo: blk <[HDC]>
	"With the window's device context do the block (not for painting)"

	| hdc <HDC> |
	hdc := {{<user HDC GetDC> hwnd: self win32Handle}}.
	[ blk value: hdc ]
		ensure: [ hdc releaseDCFor: self win32Handle ]! !

"June 6, 2007 -> 1:55:8"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
withDirectCanvasDo: drawing <[Canvas,^X def]> ^<X>

	|	can <Canvas>
		ps <PAINTSTRUCT>
		paintBlk <[^Object]>
		result <X>
		oldpal <Win32Handle> |

	"use a critical region to paint, since background painting might reuse the
	  same device context in the UI thread"
	^self critical:
		[	ps := PAINTSTRUCT new allocateZeroed.
			can := self beginPaint: self win32Handle paintStructure: ps.
			can isNull
				ifTrue: [ Win32 handleError ].
			can	initialize;
				toRelease: [ :dc <HDC> | "End paint will release the context" ];
				initClippingRectBeforeTranslation: ps rcPaint asRectangle;
				window: self.
			self palette isNil
				ifFalse: [ oldpal := can win32Palette: self palette win32Handle ].

			Session debugInvalidation
				ifTrue: [	can withPainter: (Painter new paint: Paint red)
									do: [ can displayFilledRectangle: ps rcPaint asRectangle; flush. ].
								Platform errorStream show: self class name, ' rendering: '; print: ps rcPaint asRectangle; cr.	].

			result := drawing value: can.
			oldpal notNil
				ifTrue: [ 	Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								can win32Palette: oldpal ]. 
			can release. 

			self endPaint: self win32Handle paintStructure: ps.
			ps free.
			result	]! !

"June 6, 2007 -> 1:55:9"!

! (Delta mirrorFor: #Window) methodsFor: 'private' !
wndProc ^<APICallback>

	^self session wndProc! !

"June 6, 2007 -> 1:55:11"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending ^<Boolean>

	^paintPending! !

"June 6, 2007 -> 1:55:12"!

! (Delta mirrorFor: #Window) methodsFor: 'private-testing' !
paintPending: b <Boolean>

	paintPending := b! !

"June 6, 2007 -> 1:55:13"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
changing

	self session changing: self.
	self session recordPrefsFor: self.
	natural := min := max := nil.! !

"June 6, 2007 -> 1:55:15"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> ext <Point> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."

	((alloc contains: self min enclosingRect)
			and: [ self max enclosedRect contains: alloc ]
	)	ifFalse: [	"We definitely have to change our size"
							self relayoutIfNeededForExtent: nat extent.
							self extent: nat extent.
							^self	].

	(self optimizeIncrementalLayout
			or: [ nat = oldNat
			or: [	alloc contains: nat ] ])
		ifTrue: [	self relayoutIfNeededForExtent: self extent.
						^self ].

	ext := (nat width max: alloc width) @ (nat height max: alloc height).
	self relayoutIfNeededForExtent: ext.
	self extent: ext.! !

"June 6, 2007 -> 1:55:16"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
checkPaintTime: t <Float>
	"If we have reached our refresh time, paint"
	
"%todo: figure out how to remove the following %hack
		this should not be sent after the receiver is released)"	
visual isNil ifTrue: [ ^self ].

	(self hasWin32Handle and: [ self paintPending ])
		ifTrue: [ self nextPaintTime <= t
						ifTrue: [ self display ]
						ifFalse: [ self session needPaintAtTime: self nextPaintTime ]	 ]! !

"June 6, 2007 -> 1:55:18"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
oldcheckLayout: oldPrefs <SeqCltn[Region]>

	| oldNat <Rect> alloc <Rect> nat <Rect> |
	oldNat := (oldPrefs at: 2) enclosingRect.
	self computePreferences.
	nat := self natural enclosingRect.
	alloc := self allocation enclosingRect.

	"We have to do the relayout eagerly, even before the size message
			comes back, because the caller assumes that layout is then done."
	self relayoutIfNeeded.

	((alloc contains: self min enclosingRect)
			and: [ (self max enclosedRect contains: alloc)
			and: [ self optimizeIncrementalLayout
							or: [ nat = oldNat
							or: [	alloc contains: nat ] ] ] ]
	)	ifFalse: [	"We definitely have to change our size"
						self setExtent: nat extent.	].
! !

"June 6, 2007 -> 1:55:19"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefs ^<SeqCltn[Region]>

	^Array[Region] with: self min with: self natural with: self max! !

"June 6, 2007 -> 1:55:20"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prefsStatus ^<Int>

	^Visual valid! !

"June 6, 2007 -> 1:55:21"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
prerecordPrefsIfNeeded

	"nothing to do"! !

"June 6, 2007 -> 1:55:22"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
processDeferredPainting

	self deferredPaintRegion notNil
		ifTrue: [	self invalidate: self deferredPaintRegion.
						self deferredPaintRegion: nil.		]! !

"June 6, 2007 -> 1:55:24"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-to session' !
removeParentsFrom: leaves <Set[RelayoutTarget]>
alreadyChecked: checked <Set[RelayoutTarget]>

	"nothing to do"! !

"June 6, 2007 -> 1:55:25"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
hInstance ^<ExternalProxy>

	^self medium hInstance! !

"June 6, 2007 -> 1:55:26"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msg <MSG>
	"This is invoked in the UI thread when a new message arrives in the queue."

	"Forward messages to the session, which will execute them in its thread"
	self session message: msg! !

"June 6, 2007 -> 1:55:27"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
message: msgCode <ExternalData>
for: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This is where all the win32 messages get converted to our semantics.  This
	  method executes in the window's session's thread for queued messages, and
	  either the session or UI thread for unqueued messages."

	"%note/%todo: each message below must call beforeQueuedMessage before processing
	     the message IFF the message is a queued (in session thread) message"

	^(self windowsMessageHandlers at: msgCode
		ifAbsent: [ ^self handleMiscMsg: msgCode hwnd: hwnd wParam: wParam lParam: lParam ]
     )	value: self
		value: msgCode
		value: hwnd
		value: wParam
		value: lParam! !

"June 6, 2007 -> 1:55:29"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
recursiveRealizePaletteForeground: fore <Boolean> updateColors: update <Boolean>

	self palette isNil
		ifFalse: [	self withDCDo:
							[ :hdc <HDC> |
								| oldpal <Win32Handle> |
								oldpal := Palette select: self palette win32Handle into: hdc background: fore not.
								self palette unrealize.
								self palette realizeFor: hdc.
								Palette debugging
									ifTrue: [ Platform errorStream show: '(Restoring old palette)'.	].
								Palette select: oldpal win32Handle into: hdc background: fore not.
							 ].
						self invalidate.
						].
	self controls do:
		[ :c <Win32Control> |
			c recursiveRealizePaletteForeground: fore updateColors: update ].! !

"June 6, 2007 -> 1:55:30"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
registerControl: c <Win32Control>

	self controls include: c! !

"June 6, 2007 -> 1:55:31"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
releaseCapture

	{{<user ExternalProxy ReleaseCapture> noArgs}}! !

"June 6, 2007 -> 1:55:33"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
sendMessage: msg <ExternalData>
wparam: wp <ExternalData>
lparam: lp <ExternalData>
^<ExternalData>

	^{{<user ExternalProxy SendMessageA>
			handle: self win32Handle
			msg: msg
			wparam: wp
			lparam: lp}}! !

"June 6, 2007 -> 1:55:34"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setCapture

	{{<user ExternalProxy SetCapture> hwnd: self win32Handle}}.
! !

"June 6, 2007 -> 1:55:35"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
setFocus

	 self win32Handle @= {{<user ExternalProxy GetFocus> call}}
		ifFalse: [  {{<user ExternalProxy SetFocus> hwnd: self win32Handle}} ]! !

"June 6, 2007 -> 1:55:36"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
unregisterControl: c <Win32Control>

	self controls removeEvery: c! !

"June 6, 2007 -> 1:55:37"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32' !
win32Handle ^<HWND>

	win32Handle isNil
		ifTrue: [	self session creatingWindow: self do:
							[	self buildWin32Handle; recordExtent. ].  ].
	^win32Handle! !

"June 6, 2007 -> 1:55:39"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
characterMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:40"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
closeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self requestClose.
	^0! !

"June 6, 2007 -> 1:55:41"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
commandMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	
	self beforeQueuedMessage.

	^lParam @~= Win32 NULL
		ifTrue: [	"Then this is a control window notification, which should be forwarded back to the
						  smalltalk control object"
						Win32Control notificationMsg: wParam asExternalProxy high for: (Win32Control controlIdFor: lParam).
						0 ]
		ifFalse: [ wParam asExternalProxy high = 0
							ifTrue: [	self menuCommandForItem: wParam low.
											0	]
							ifFalse: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]	]! !

"June 6, 2007 -> 1:55:43"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMiscMsg: msgCode <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This performs the default window system handling for a message"
	
	^(self shouldCallDefaultHandlerAsynchronouslyFor: msgCode)
		ifTrue: [	"Some messages should be handled asyncronously, so that for
							example, moving a window allows other sessions to refresh"
						self callAsyncDefWndProcFor: hwnd
							msgCode: msgCode
							wParam:  wParam
							lParam: lParam ]
		ifFalse: [	self callDefWndProcFor: hwnd
								msgCode: msgCode
								wParam:  wParam
								lParam: lParam	]! !

"June 6, 2007 -> 1:55:44"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
handleMouseEvent: type <Symbol>
at: loc <Point>
msg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ev <UIEvent> |
	self beforeQueuedMessage.

	"%todo: remove the dispatch block for all events; isn't needed anymore"
	ev := UIEvent
			forMsg: self session currentMsg
			dispatch:
				[ :e <UIEvent> :h <UIEventHandler> |
					h mouseEvent: type at: loc event: e ].
	self mouseEvent: type at: loc event: ev.

	"Mouse events are always passed through to the default wnd proc since their may be window system specific things
	  like bringing the window to the foreground that always have to happen. (I used to pass it through only when it
	  was a left button down msg, but this is cleaner)"
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:55:45"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
initMenuPopupMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	self hasMenu 
		ifTrue: [ self activeMenu updateMenuWithHandle: wParam ].
	^0! !

"June 6, 2007 -> 1:55:47"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyDownMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:48"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
keyUpMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self beforeQueuedMessage.
	^self session handleIfFocusMsg: msg for: self wParam: wParam lParam: lParam
! !

"June 6, 2007 -> 1:55:49"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
layoutMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| ext <Point> |
	ext := lParam low @ lParam high.
	(self visual layoutStatus < Visual valid
			or: [ self visual allocation enclosingRect extent ~= ext ])
		ifTrue: [ self layout: ext ].
	^0! !

"June 6, 2007 -> 1:55:51"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
paintMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self display.
	^0! !

"June 6, 2007 -> 1:55:52"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 queued message handling' !
setCursorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^(cursor notNil
			and: [	| hitcode <Int> |
						hitcode := lParam asExternalProxy low.
						hitcode = 1 or: [ hitcode = 65534 ] "client area or disabled"  ])
		ifTrue: [ 	self setCursor.
						1 ]
		ifFalse: [ self callDefWndProcFor: hwnd
								msgCode: msg
								wParam: wParam
								lParam: lParam ]
! !

"June 6, 2007 -> 1:55:54"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
buttonColorMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control buttonColorMsg: wParam asExternalProxy for: (Win32Control controlIdFor: lParam)! !

"June 6, 2007 -> 1:55:55"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
captureChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self session lostCapture.
	
	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:55:56"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
destroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^0! !

"June 6, 2007 -> 1:55:58"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
drawItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	^Win32Control drawItemMsg: (DRAWITEMSTRUCT forProxy: lParam) for: wParam asSmallInteger! !

"June 6, 2007 -> 1:55:59"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
eraseBackgroundMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| can <Canvas> |

	self haveErased
		ifTrue: [ ^1 ].
	self haveErased: true.

	"Don't paint background when a paint is pending to reduce flickering"
	self paintPending
		ifTrue: [ ^0 ].

	"Use a critical region because the window's thread might be drawing"
	self critical:
		[	can := HDC forProxy: wParam asExternalProxy.
			can initialize.
			self paintBackgroundOn: can. 	].
	^1! !

"June 6, 2007 -> 1:56:1"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
getMinMaxInfoMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| info <MINMAXINFO> adjmin <Point> adjmax <Point> |
	info := MINMAXINFO forProxy: lParam asExternalProxy.
	adjmin := (self fitToMedium: self min extent) max: info ptMinTrackSize asPoint.
	adjmax := (self fitToMedium: self max extent) min: info ptMaxSize asPoint.
	info ptMaxSize x: adjmax x; y: adjmax y.
	info ptMaxTrackSize x: adjmax x; y: adjmax y.
	info ptMinTrackSize x: adjmin x; y: adjmin y.
	^0! !

"June 6, 2007 -> 1:56:3"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
killFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is losing the input focus, which means that some non-native visual
	  within us probably has the focus, so we have to discard the focus."

	(self session hasInputFocus and: [ self session inputFocus nativeWindow = self ])
		ifTrue: [ self session noInputFocus ].

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:56:4"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
measureItemMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	| data <MEASUREITEMSTRUCT> |
	data := MEASUREITEMSTRUCT forProxy: lParam.
	^data CtlType @= Win32 ODT_MENU
		ifFalse: [ Win32Control measureItemMsg: data for: data CtlID asSmallInteger ]
		ifTrue: [ self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam ]! !

"June 6, 2007 -> 1:56:6"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
ncDestroyMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self release.
	^0! !

"June 6, 2007 -> 1:56:7"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
paletteChangedMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	wParam @= self win32Handle
		ifFalse: [ self recursiveRealizePaletteForeground: false updateColors: true.
						self palette isNil
							ifTrue: [ ^self callDefWndProcFor: hwnd
											msgCode: msg
											wParam: wParam
											lParam: lParam	].
					].
	^0! !

"June 6, 2007 -> 1:56:9"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
queryPaletteMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	self recursiveRealizePaletteForeground: true updateColors: false.
	self palette isNil
		ifTrue: [ ^self callDefWndProcFor: hwnd
						msgCode: msg
						wParam: wParam
						lParam: lParam	].
	^0! !

"June 6, 2007 -> 1:56:10"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
setFocusMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"This window is getting the input focus, which means that some non-native visual
	  within us will have to be chosen if possible."

	self beforeSetFocus.

	^self handleMiscMsg: msg  hwnd: hwnd wParam: wParam lParam: lParam! !

"June 6, 2007 -> 1:56:12"!

! (Delta mirrorFor: #Window) methodsFor: 'restricted-win32 unqueued message handling' !
sizeMsg: msg <ExternalData>
hwnd: hwnd <HWND>
wParam: wParam <ExternalData>
lParam: lParam <ExternalData>
^<ExternalData>

	"%todo: do we need to check the value of wParam first?"
	self critical:
		[ wParam @= Win32 SIZE_MINIMIZED
			ifFalse: [	| m <MSG> |
								self invalidate.
								m := MSG new allocate.
								[ m	hwnd: self win32Handle;
										message: Window LAYOUT;
										wParam: 0;
										lParam: lParam.
									self recordExtent.
									self session message: m.
								] ensure: [ m free ]
							]
		 ].
	^0! !

"June 6, 2007 -> 1:56:13"!

! (Delta mirrorFor: #Window) methodsFor: 'testing' !
isActive ^<Boolean>

	^self session hasActiveWindow and: [ self session activeWindow = self ]! !

"June 6, 2007 -> 1:56:32"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

Delta define: #SystemInitializer as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 1:56:34"!

(Delta mirrorFor: #SystemInitializer)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 6, 2007 -> 1:56:37"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
benchmarkDictionary
	| dict |
	dict := Dictionary new.

	"Benchmarks"
	dict at: #richards			put: [ :runner :repeat :inner | runner new runRichardsBenchmarks: 		repeat ].
	dict at: #smopstones	put: [ :runner :repeat :inner | runner new runSmopstoneBenchmarks:	repeat ].
	dict at: #slopstones		put: [ :runner :repeat :inner | runner new runSlopstoneBenchmarks:		repeat ].
	dict at: #stanford			put: [ :runner :repeat :inner | runner new runStanfordBenchmarks:		repeat ].
	dict at: #deltablue			put: [ :runner :repeat :inner | runner new runDeltaBlue:							repeat ].
	dict at: #benchmarks	put: [ :runner :repeat :inner | 
		runner new runStanfordBenchmarks:			repeat.
		runner new runRichardsBenchmarks:		repeat.
		runner new runDeltaBlue:								repeat.
		runner new runSlopstoneBenchmarks:		repeat.
		runner new runSmopstoneBenchmarks:	repeat.
	].
	
	dict at: #loop			put: [ :runner :repeat :inner | runner new runStanfordLoopBenchmarks: repeat ].
	
	"Individual Stanford Benchmarks"
	dict at: #bubblesort		put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSortBenchmark repeat: repeat inner: inner].
	dict at: #bubblesort2	put: [ :runner :repeat :inner | runner new runIndividualStanford: BubbleSort2Benchmark repeat: repeat inner: inner].
	dict at: #intmm				put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMMBenchmark repeat: repeat inner: inner].
	dict at: #intmm2			put: [ :runner :repeat :inner | runner new runIndividualStanford: IntMM2Benchmark repeat: repeat inner: inner].
	dict at: #mm					put: [ :runner :repeat :inner | runner new runIndividualStanford: MMBenchmark repeat: repeat inner: inner].
	dict at: #mm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: MM2Benchmark repeat: repeat inner: inner].
	dict at: #perm				put: [ :runner :repeat :inner | runner new runIndividualStanford: PermBenchmark repeat: repeat inner: inner].
	dict at: #perm2				put: [ :runner :repeat :inner | runner new runIndividualStanford: Perm2Benchmark repeat: repeat inner: inner].
	dict at: #queens			put: [ :runner :repeat :inner | runner new runIndividualStanford: QueensBenchmark repeat: repeat inner: inner].
	dict at: #queens2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Queens2Benchmark repeat: repeat inner: inner].
	dict at: #quicksort		put: [ :runner :repeat :inner | runner new runIndividualStanford: QuicksortBenchmark repeat: repeat inner: inner].
	dict at: #quicksort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: Quicksort2Benchmark repeat: repeat inner: inner].
	dict at: #towers			put: [ :runner :repeat :inner | runner new runIndividualStanford: TowersBenchmark repeat: repeat inner: inner].
	dict at: #towers2			put: [ :runner :repeat :inner | runner new runIndividualStanford: Towers2Benchmark repeat: repeat inner: inner].
	dict at: #treesort			put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSortBenchmark repeat: repeat inner: inner].
	dict at: #treesort2		put: [ :runner :repeat :inner | runner new runIndividualStanford: TreeSort2Benchmark repeat: repeat inner: inner].
	dict at: #puzzle				put: [ :runner :repeat :inner | runner new runIndividualStanford: PuzzleBenchmark repeat: repeat inner: inner].
	dict at: #sieve				put: [ :runner :repeat :inner | runner new runIndividualStanford: SieveBenchmark repeat: repeat inner: inner].
	dict at: #sumto				put: [ :runner :repeat :inner | runner new runIndividualStanford: SumToBenchmark repeat: repeat inner: inner].
	dict at: #recurse			put: [ :runner :repeat :inner | runner new runIndividualStanford: RecurseBenchmark repeat: repeat inner: inner].
	dict at: #atallput			put: [ :runner :repeat :inner | runner new runIndividualStanford: AtAllPutBenchmark repeat: repeat inner: inner].
	dict at: #incrementall	put: [ :runner :repeat :inner | runner new runIndividualStanford: IncrementAllBenchmark repeat: repeat inner: inner].
	dict at: #nestedloop		put: [ :runner :repeat :inner | runner new runIndividualStanford: NestedLoopBenchmark repeat: repeat inner: inner].
	dict at: #tak					put: [ :runner :repeat :inner | runner new runIndividualStanford: TakBenchmark repeat: repeat inner: inner].
	dict at: #takl					put: [ :runner :repeat :inner | runner new runIndividualStanford: TaklBenchmark repeat: repeat inner: inner].
	dict at: #ordcol				put: [ :runner :repeat :inner | runner new runIndividualStanford: OrderedCollectionBenchmark repeat: repeat inner: inner].
	dict at: #dictionary		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryBenchmark repeat: repeat inner: inner].
	dict at: #dictatput		put: [ :runner :repeat :inner | runner new runIndividualStanford: DictionaryAtPutBenchmark repeat: repeat inner: inner].
	dict at: #livermore		put: [ :runner :repeat :inner | runner new runIndividualStanford: LivermoreBenchmark repeat: repeat inner: inner].

	"Individual Slopstone Benchmarks"
	dict at: #addint				put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 1 repeat: repeat inner: inner].
	dict at: #addfloat			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 2 repeat: repeat inner: inner].
	dict at: #stringaccess	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 3 repeat: repeat inner: inner].
	dict at: #createobject	put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 4 repeat: repeat inner: inner].
	dict at: #perform			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 5 repeat: repeat inner: inner].
	dict at: #evaluate			put: [ :runner :repeat :inner | runner new runIndividualSlopstone: 6 repeat: repeat inner: inner].
	
	"Individual Smopstone Benchmarks"
	dict at: #fractonacci	put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 1 repeat: repeat inner: inner].
	dict at: #primes   		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 2 repeat: repeat inner: inner].
	dict at: #streams		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 3 repeat: repeat inner: inner].
	dict at: #strings			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 4 repeat: repeat inner: inner].
	dict at: #sets				put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 5 repeat: repeat inner: inner].
	dict at: #sorting 			put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 6 repeat: repeat inner: inner].
	dict at: #sorcerer		put: [ :runner :repeat :inner | runner new runIndividualSmopstone: 7 repeat: repeat inner: inner].

	"Test Suites"
	dict at: #testsuite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new testBasicClasses] ].

	"Individual Tests"
	dict at: #string				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: String title: 'String' ] ].
	dict at: #number			put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Number title: 'Number' ] ].
	dict at: #sortedcol		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SortedCollection title: 'SortedCollection' ] ].
	dict at: #readstream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadStream title: 'SeqCltnReadStream' ] ].
	dict at: #writestream	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream' ] ].
	dict at: #bag				put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Bag title: 'Bag' ] ].
	dict at: #keyedset		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: KeyedSet title: 'KeyedSet' ] ].
	dict at: #set					put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Set title: 'Set' ] ].
	dict at: #orderedcol	put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: OrderedCollection title: 'OrderedCollection' ] ].
	dict at: #character		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: Character title: 'Character' ] ].
	dict at: #readwrite		put: [ :runner :repeat :inner | repeat timesRepeat: [ VMSuite new test: ExternalReadWriteStream title: 'ExternalReadWriteStream' ] ].

	"Errors"
	dict at: #break				put: [ :runner :repeat :inner | {{primitiveBreak}} ].

	"Bootstrap"
	dict at: #boot				put: [ :runner :repeat :inner | Dumper fileOut ].

	"Test Suite for the VM people"
	dict at: #vmtest				put: [ :runner :repeat :inner | VMSuite run ].
	dict at: #vminterpreted	put: [ :runner :repeat :inner | VMSuite runInterpreted ].
	dict at: #vmcompiled	put: [ :runner :repeat :inner | VMSuite runCompiled ].
	dict at: #vmvanilla			put: [ :runner :repeat :inner | VMSuite runVanilla ].
	dict at: #dump					put: [  :runner :repeat :inner | InliningDatabase dump ].
	dict at: #compileAll		put: [  :runner :repeat :inner | InliningDatabase compileAll ].
	dict at: #gc						put: [  :runner :repeat :inner | VM collectGarbage ].
	dict at: #norecomp		put: [  :runner :repeat :inner | VM booleanAt: #UseRecompilation put: false ].

	"Misc."
	dict at: #zone					put: [ :runner :repeat :inner | {{primitivePrintZone}} ].
	dict at: #decode				put: [ :runner :repeat :inner | {{primitiveDecodeAllMethods}} ].
	dict at: #mandelbrot		put: [ :runner :repeat :inner | repeat timesRepeat: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandelprof		put: [ :runner :repeat :inner | Profiler do: [ Mandelbrot new computeImageOnly ] ].
	dict at: #mandeltest		put: [ :runner :repeat :inner | Mandelbrot new computeImageOnly ].
	dict at: #typecheck		put: [ :runner :repeat :inner | runner new runTypecheckerBenchmarks: repeat ].
	dict at: #genprims			put: [ :runner :repeat :inner | DeltaPrimitiveGenerator doit].

	^dict! !

"June 6, 2007 -> 1:56:38"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
findRunner: test ifAbsent: blk
	test = 'timer'
		ifTrue: [^BenchmarkRunner].
	test = 'nmethod'
		ifTrue: [^BenchmarkNMethodInvocationRunner].
	test = 'method'
		ifTrue: [^BenchmarkMethodInvocationRunner].
	test = 'prims'
		ifTrue: [^BenchmarkPrimitiveRunner].
	test = 'lookup'
		ifTrue: [^BenchmarkLookupCacheRunner].
	test = 'blocks'
		ifTrue: [^BenchmarkBlockRunner].
	blk value.! !

"June 6, 2007 -> 1:56:39"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
lower: str
	| result |
	result := String new: str size.
	1 to: str size do: [ :index |
		result at: index put: (str at: index) asLowercase
	].
	^result! !

"June 6, 2007 -> 1:56:41"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
parseInteger: str ifFail: blk
	| result |
	result := 0.
	str do: [ :c | | val |
		val := c asciiValue.
		(val >= $0 asciiValue and: [ val <= $9 asciiValue ])  ifTrue: [
			result := (result * 10) + ( val - $0 asciiValue)
		] ifFalse: [
			^blk value
		]
	].
	^result! !

"June 6, 2007 -> 1:56:42"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
processCommandLineArguments ^<Boolean>
	"process command line args, and return boolean indicating whether the 
		default program should be run (which is normally the GUI)"

	| args <ReadStream[Str]>  runDefault <Boolean> |
	args := Platform commandLineTokens.
	args next.  "Skip command"
	runDefault := true.
	
	[ args atEnd ] whileFalse: [  | arg <Str> |
		arg := args next.
		
		arg = '-benchmark'
			ifTrue: [	self runBenchmarks: args.
						runDefault := false ].
		arg = '-script'
			ifTrue: [	args atEnd
							ifTrue: [ Transcript show: 'Command line argument error: -script option must be followed by a filename';cr. ]
							ifFalse: [ self runScript: args next ].
						runDefault := false ].		].
	^runDefault
! !

"June 6, 2007 -> 1:56:43"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runBenchmarks: args <InputStream[Str]>

	| dict runner repeat inner print |
	dict := self benchmarkDictionary.
	runner	:= BenchmarkRunner.
	repeat	:= 1.
	inner	:= 1.
	print		:= false.

	[ args atEnd ] whileFalse: [	| arg <Str> cmd options |
		arg := args next.
		options	:= false.
		arg = 'profile'	ifTrue: [ runner := BenchMarkProfileRunner.		options := true ].
		arg = 'prims'		ifTrue: [ runner := BenchmarkPrimTraceRunner.	options := true ].
		arg = 'inner'		ifTrue: [ inner := repeat. repeat := 1.						options := true ].
		arg = 'print'		ifTrue: [ print := true.												options := true ].
		options ifFalse: [
			repeat := self parseInteger: arg ifFail: [
				Transcript show: 'Processing '; show: arg; show: ' ('; show: repeat printString; show: ' times)'; cr.
				cmd := dict at: arg ifAbsent: [nil].
				cmd isNil ifTrue:  [ Transcript show: 'Command not found'; cr ]
							   ifFalse: [ cmd value: runner value: repeat value: inner ].
				repeat
			]
		]
	].

	print ifTrue: [
		{{primitivePrintMemory}}.
	]! !

"June 6, 2007 -> 1:56:44"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runDefaultProgram
	"This starts the 'default' program, which is the code that should run when no
	  command line options specifies something else"
	  
	[ UI start ] fork! !

"June 6, 2007 -> 1:56:45"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'command line arguments' !
runScript: filename <Str>

	[	| file <FilePath> |
		file := FilePath for: filename.
		file exists
			ifFalse: [	Transcript show: 'Error: script file ''', filename, ''' not found.'; cr.
							^self	].
		file charInputStream fileIn
	] fork! !

"June 6, 2007 -> 1:56:46"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
run
	"This is the entry point for normal execution."
	
	| commands <OrdCltn[Str]> |

	self runBaseClassInitializers.
	self runNonCriticalClassInitializers.
	(self processCommandLineArguments)
		ifTrue: [ self runDefaultProgram ].
! !

"June 6, 2007 -> 1:56:47"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runBaseClassInitializers
	"Initialize critical base library classes (run in the process scheduler)"

	Platform initialize.
	Transcript := TempTranscript new.
	SmallInteger initialize.
	Character initialize.
	CallBack initialize.
	IdleProcess initialize.
	InliningDatabase initialize.
! !

"June 6, 2007 -> 1:56:48"!

! (Delta mirrorFor: #SystemInitializer) classSide methodsFor: 'library class initialization' !
runNonCriticalClassInitializers
	"This is the root class initializer that is called when the system starts up.
		Any class initializers that must be called should be called from
		this method."

	Session initialize.

	Rectangle initialize.
	Paint initialize.
	Painter initialize.
	HPEN initialize.
	GeometricHPEN initialize.
	HBRUSH initialize.
	InfiniteRegion initialize.

	Smalltalk initialize.

	CodeEditor initialize.
	Workspace initialize.

	HTMLElement initialize.
	HTMLParser initialize.! !

"June 6, 2007 -> 1:59:45"!

"System saved" !
"June 6, 2007 -> 2:11:44"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 2:12:11"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
    | p size result |
    p := {{<kernel ExternalProxy GetCommandLineA>getCommandLine}}.
    size := 0.
    [(p byteAt: size) == 0] whileFalse: [ size := size + 1 ].
    result := String new: size.
    1 to: size do: [:index |
       result at: index put: (Character value: (p byteAt: index - 1))
    ].
    ^result! !

"June 6, 2007 -> 2:13:2"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLineTokens ^<InputStream[Str]>
    "a stream of the input line tokens.  Tokens are sequences separated by whitespace; whitespace can be 
        included in a token by double quoting the arg.  (quotes can be imbedded by doubling, as with Smalltalk strings;
        the returned token has delimiting quotes removed and internal quotes undoubled. "

    | cstrm <CharInputStream> |
    cstrm := self commandLine readStream.
    self skipSpacesIn: cstrm.
    ^CustomInputStream[Str] new
            nextBlock: [    self parseArgFrom: cstrm ];
            atEndBlock: [ cstrm atEnd ].! !

"June 6, 2007 -> 2:24:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'command line' !
commandLine ^<Str>
   ^self getCommandLine! !

"June 6, 2007 -> 2:40:18"!

"System saved" !
"June 6, 2007 -> 2:52:16"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'private' !
skipSpacesIn: strm <CharInputStream>

    [ strm atEnd not and: [ strm peekFor: Character space] ] whileTrue.
! !

"June 6, 2007 -> 2:54:14"!

"System saved" !
"June 6, 2007 -> 18:22:24"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:25"!

Delta define: #Bootstrap as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2007 -> 18:22:26"!

(Delta mirrorFor: #Bootstrap)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.
'!


"June 6, 2007 -> 18:22:27"!

! (Delta mirrorFor: #Bootstrap) classSide methodsFor: 'notification' !
checkNotification
	[ 
		{{primitiveNotificationQueueGetIfFail: [ :err |^self]}}  notify.
	] repeat.! !

"June 6, 2007 -> 18:22:28"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictAtBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  atPerformanceTest ].
Transcript show: '-------------------------------------- starting Dict>>at: benchmark'; cr.
	Transcript print:
		[ Dictionary atPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:29"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictAtPutBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  atPutPerformanceTest ].
Transcript show: '-------------------------------------- starting Dict>>at:put: benchmark'; cr.
	Transcript print:
		[ Dictionary atPutPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:30"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
dictBenchmark
"	Foo isNil
		ifTrue: [ Dictionary performanceTestPrep. Foo := 1 ]."
	2 timesRepeat: [ Dictionary  performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ Dictionary performanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:31"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
hashingBenchmarks

	self dictAtBenchmark; dictAtPutBenchmark; setIncludeBenchmark; setIncludesBenchmark! !

"June 6, 2007 -> 18:22:32"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
setIncludeBenchmark

	2 timesRepeat: [ Set  includePerformanceTest ].
Transcript show: '-------------------------------------- starting Set>>include: benchmark'; cr.
	Transcript print:
		[ Set includePerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:33"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'dave''s benchmarks' !
setIncludesBenchmark

	2 timesRepeat: [ Set  includesPerformanceTest ].
Transcript show: '-------------------------------------- starting Set>>includes: benchmark'; cr.
	Transcript print:
		[ Set includesPerformanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:34"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	Smalltalk recompileAllMethods.
	Transcript show: 'Testing completed.'; cr.! !

"June 6, 2007 -> 18:22:35"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testBlueBookCPUBoundClasses

	Number test.
    SeqCltnReadWriteStream test.
     SeqCltnReadStream  test.
    Bag test.
    KeyedSet  test.
   Set  test.
	 Dictionary test.
   SortedCollection test.
     OrderedCollection  test.
   String  test.
   Character  test.
	 Interval test.
	 Behavior test.
	 Random test.
	 BlockWithoutArguments  test.
	 Queue test.

	
! !

"June 6, 2007 -> 18:22:36"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testBlueBookClasses

    self test: Number title: 'Number'.
    self test: SmallInteger title: 'SmallInteger'.
    self test: SeqCltnReadWriteStream title: 'SeqCltnReadWriteStream'.
    self test: SeqCltnReadStream   title: 'SeqCltnReadStream'.
    self test: Bag title: 'Bag'.
    self test: KeyedSet title: 'KeyedSet'.
    self test: Set title: 'Set'.
	self test: Dictionary title: 'Dictionary'.
    self test: SortedCollection title: 'SortedCollection'.
    self test: OrderedCollection title: 'OrderedCollection'.
    self test: String title: 'String'.
    self test: Character title: 'Character'.
	self test: Interval title: 'Interval'.
	self test: Behavior title: 'Behavior'.
	self test: Random title: 'Random'.
	self test: BlockWithoutArguments title: 'BlockWithoutArguments'.

    self test: ExternalReadWriteStream title: 'ExternalReadWriteStream'.
    self test: SharedQueue title: 'SharedQueue'.
	
! !

"June 6, 2007 -> 18:22:37"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
testLibrary
	
	| t <Int> |
	t := [	self testBlueBookClasses.
    		self test: FilePath title: 'FilePath'.
			self test: CharacterReadConverter title: 'CharacterReadConverter'.	] time.
	Transcript show: 'Time = '; print: t; cr.
! !

"June 6, 2007 -> 18:22:38"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
benchmarkMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&Benchmarks';
					add: (MenuAction new
							name: 'Livermore &Benchmark';
							action: [ self livermoreBenchmark ] );
					add: (MenuAction new
							name: 'Livermore Benchmark (w/FloatValues)';
							action: [ self livermoreFloatValueBenchmark ] );
					add: (MenuAction new
							name: 'CPU benchmark';
							action: [ self cpuBenchmark ] );
					add: (MenuAction new
							name: 'Stream write';
							action: [ self streamWrite ] );
					add: (MenuAction new
							name: 'Stream read';
							action: [ self streamRead ] );
					add: (MenuAction new
							name: 'Stream lines write';
							action: [ self streamWrite2 ] );
					add: (MenuAction new
							name: 'Stream lines read';
							action: [ self streamRead2 ] );
					add: (MenuAction new
							name: '&Hashing Benchmarks';
							action: [ self hashingBenchmarks ] );
					add: (MenuAction new
							name: 'OrderedCollection Benchmark';
							action: [ self ocBenchmark ] );
					add: (MenuAction new
							name: 'Array Benchmark';
							action: [ self arrayBenchmark ] );
					add: (MenuAction new
							name: 'Random Benchmark';
							action: [ Transcript print: [ 10 timesRepeat: [ Random test ] ] time; cr. ] )
					)! !

"June 6, 2007 -> 18:22:39"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
compilationMenu ^<Menu>

	^Menu new name: '&Compiler';
					add: (MenuAction new
							name: '&Compiler Enabled';
							checked: [ VM recompilation ];
							action: [ VM recompilation: VM recompilation not ]	);
					add: (MenuAction new
							name: '&Print Compilations';
							checked: [ VM printCompilation ];
							action: [ VM printCompilation: VM printCompilation not ]	);
					add: (MenuAction new
							name: 'Print Compiled Code Space Usage (Zone)';
							action: [	VM printZone ] );
					addSeparator;
					add: (MenuAction new
							name: 'Use &Inlining Database as needed';
							checked: [ VM useInliningDatabase ];
							action: [	InliningDatabase checkLookupTable.
											VM useInliningDatabase: VM useInliningDatabase not.
										  ]	);
					add: (MenuAction new
							name: 'Compile Whole Inlining Database';
							action: [ InliningDatabase compileAll ]	);
					add: (MenuAction new
							name: 'Create &Inlining Database';
							action: [ InliningDatabase dump ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Flush Inline Caches';
							action: [ {{primitiveClearInlineCaches}} ]	)! !

"June 6, 2007 -> 18:22:40"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
developmentMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&System';
					add: self compilationMenu;
					add: self gcMenu;
					add: self uiMenu;
					add: self typeSystemMenu;
					add: self profilingMenu)! !

"June 6, 2007 -> 18:22:41"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
gcMenu ^<Menu>

	^Menu new name: '&Object Memory';
					add: (MenuAction new
							name: '&Collect Garbage';
							action: [ VM collectGarbage ]	);
					add: (MenuAction new
							name: '&Scavenge';
							action: [ VM scavengeGarbage ]	);
					addSeparator;
					add: (MenuAction new
							name: 'Print Scavenges';
							checked: [ VM printScavenge ];
							action: [ VM printScavenge: VM printScavenge not ]	);
					add: (MenuAction new
							name: 'Print Allocated Object &Histogram';
							action: [ {{primitivePrintObjectHistogram}} ]	)! !

"June 6, 2007 -> 18:22:42"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
profilingMenu ^<Menu>

	^Menu new name: '&Profiling and Debugging';
					add: (MenuAction new
							name: '&Profiling';
							checked: [ Profiler profiling ];
							action: [ Profiler profiling: Profiler profiling not ]	);
					add: (MenuAction new
							name: '&Print Profile';
							action: [ Profiler profiling: false.
										  Profiler printStats. ]	);
					add: (MenuAction new
							name: '&Reset Profile Stats';
							action: [ Profiler resetStats. ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Time Menu Actions';
							checked: [ MenuAction timeActions ];
							action: [ MenuAction timeActions: MenuAction timeActions not ]	);
					addSeparator;
					add: (MenuAction new
							name: '&Temp Debug';
							checked: [ TempDebug == true ];
							action: [	TempDebug isNil ifTrue: [ TempDebug := false ].
											TempDebug := TempDebug not.	]	)
				! !

"June 6, 2007 -> 18:22:43"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
registerTmpMenus

	Launcher registerMenu: self developmentMenu for: #Development.! !

"June 6, 2007 -> 18:22:44"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
testMenu ^<Menu>

	^Menu new
		add: (Menu new name: '&Testing';
					add: (MenuAction new
							name: 'Text Editor';
							action: [ self textEditor ] );
					add: (MenuAction new
							name: 'Test Library';
							action: [ self testLibrary ] );
					add: (MenuAction new
							name: 'Test Dialog';
							action: [ self testDialog ] );
					add: (MenuAction new
							name: 'Mandelbrot';
							action: [ self mandelbrot ] );
					add: (MenuAction new
							name: 'Transcript test';
							action: [	[	1 to: 100 do: [ :i | Transcript print: i; cr. ]. ] fork
										] );
					add: (MenuAction new
							name: 'Transcript test 2';
							action: [	[	1 to: 100 do: [ :i | Transcript print: i; cr; flush. ]. ] fork
										] );
					add: (MenuAction new
							name: 'Transcript test 3';
							action: [	[	1 to: 100 do: [ :i | i = 50 ifTrue: [ TempDebug := true ]. Transcript print: i; cr; flush. ]. ] fork.
											[	100 to: 1 by: -1 do: [ :i | Transcript print: i; cr; flush. ]. ] fork.
										] )
					)! !

"June 6, 2007 -> 18:22:45"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
typeSystemMenu ^<Menu>

	^Menu new name: '&Type System';
					add: (MenuAction new
							name: '&Report Type Loading';
							checked: [ ReportTypeLoading == true ];
							action: [ ReportTypeLoading := ReportTypeLoading not ]	);
					add: (MenuAction new
							name: 'Zap all Type data';
							action: [ Type zapAllTypes]	)! !

"June 6, 2007 -> 18:22:47"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'new menus' !
uiMenu ^<Menu>

	^Menu new name: '&UI';
					add: (MenuAction new
							name: 'Double Buffering';
							checked: [ Window bufferingPossible ];
							action: [	Window bufferingPossible: Window bufferingPossible not]	);
					add: (MenuAction new
							name: '&Smooth Scrolling';
							checked: [ ScrollState smoothScroll ];
							action: [	ScrollState smoothScroll: ScrollState smoothScroll not]	);
					addSeparator;
					add: (MenuAction new
							name: 'Debug UI &Invalidation';
							checked: [ Session debugInvalidation ];
							action: [	Session debugInvalidation: Session debugInvalidation not	]	);
					add: (MenuAction new
							name: '&Debug Events';
							checked: [ Session debugEvents ];
							action: [ Session debugEvents: Session debugEvents not ]	);
					add: (MenuAction new
							name: '&Debug Incremental Layout';
							checked: [ Session debugIncrementalLayout ];
							action: [	Session debugIncrementalLayout: Session debugIncrementalLayout not]	)! !

"June 6, 2007 -> 18:22:48"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
cpuBenchmark

	Transcript print: [ 3 timesRepeat: [ self testBlueBookCPUBoundClasses ] ] time; cr.! !

"June 6, 2007 -> 18:22:49"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
newListBox
	| lb |
	lb := ListBox forMultipleSelections" forSingleSelection".
													lb xStretchy: true; variableItemHeight: false.
													lb stringList: #(hello goodbye atest andanotherstring 'Hi Urs' lsdfsdfsdfsdfsd sdkfljsdlkfjsdlkjf lksdfjlksdjfklsdjfklsdf lksdfj kksdlf lksdfj sdflj lsdjflksjdkfjlk ksldfjlksdfjklsjdf sdkfjl sdklfjkljlksdj lksdjfl ksdjf sdfsdfsf sdfsdfsdfsf sdfsdfsdfsf) .
													lb onSelChange: [ :lb | Transcript print: lb selections; cr. ].
													lb onDoubleClick: [ :lb | Transcript show: 'DOUBLE!!'; print: lb selections; cr. ].
													lb simpleMultiple: false.
													lb resetNaturalHeight: 10.
													lb selections: (Set withAll: #(2)).
	^lb withBorder: (Border standard3DRaised: false)
! !

"June 6, 2007 -> 18:22:50"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
newWidget

	^self newListBox! !

"June 6, 2007 -> 18:22:51"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamRead

	| p s c |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charInputStream.
	c := 0.
	[ s atEnd ]
		whileFalse: [ self assert: [ s next == $a ].
								c := c + 1. ].
	self assert: [ c = 1000000 ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:52"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamRead2

	| p s c v |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charInputStream.
	c := 0.
	[ s atEnd ]
		whileFalse: [ c = 10000 ifTrue: [ self halt. ].	v := s upTo: Character cr.
								self assert: [  v size = 98 ].
								c := c + 1. ].
	self assert: [ c = 10000 ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:53"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamWrite

	| p s |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charOutputStream.
	1000000 timesRepeat:
		[ s put: $a ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:54"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'private' !
streamWrite2

	| p s |
	p := FilePath for: 'foo.dat'.
	Transcript print: [
	s := p charOutputStream.
	10000 timesRepeat:
		[	98 timesRepeat: [ s put: $a ].
			s cr. ].
	s close. ] time; cr.! !

"June 6, 2007 -> 18:22:55"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
arrayBenchmark

	1 timesRepeat: [ Array performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ Array performanceTest ] time; cr.! !

"June 6, 2007 -> 18:22:56"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreBenchmark

	|	n		
		size
		x		
		y		
		q 		
		r 		
		z 		
		t 		
		|

	n := 1001.
	size := n + 12.
	x := Array new: size.
	y := (Array new: size) atAllPut: 1.1234.
	z := (Array new: size) atAllPut: 1.1234.
	q := r := t := 1.234.

	Transcript show: 'Livermore seconds equivalent:', (((Time millisecondsToRun: 
		[	1000 timesRepeat:
				[	1 to: n do:
						[ :k  |
							x at: k put: 
								(q + ( (y at: k) * (r*(z at: k + 10)) + (t*(z at: k + 11)) ))
						]
				]
		]) * 10) asFloat / 1000.0) printString; cr.! !

"June 6, 2007 -> 18:22:57"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreFloatValueBenchmark

	|	n		
		size
		x		
		y		
		q 		
		r 		
		z 		
		t 		
		|

	n := 1001.
	size := n + 12.
	x := Array new: size.
	y := (Array new: size) atAllPut: 1.1234.
	z := (Array new: size) atAllPut: 1.1234.
	q := r := t := 1.234.

	Transcript show: 'Livermore seconds equivalent:', (((Time millisecondsToRun: 
		[	1000 timesRepeat:
				[	self livermoreFloatValueInner: x y: y z: z ]
		]) * 10) asFloat / 1000.0) printString; cr.! !

"June 6, 2007 -> 18:22:58"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
livermoreFloatValueInner: x y: y z: z

	|	n		
		size
		q 		<FloatValue>
		r 		<FloatValue>
		t 		<FloatValue>
		|

	n := 1001.
	size := n + 12.
	q := r := t := 1.234.

	1 to: n do:
		[ :k  |
			x at: k put: 
					(q + ( (y at: k) asFloatValue * (r*(z at: k + 10) asFloatValue) + (t*(z at: k + 11) asFloatValue) )) asFloat
		]! !

"June 6, 2007 -> 18:23:0"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
ocBenchmark

	1 timesRepeat: [ OrderedCollection performanceTest ].
Transcript show: '-------------------------------------- starting benchmark'; cr.
	Transcript print:
		[ OrderedCollection performanceTest ] time; cr.! !

"June 6, 2007 -> 18:23:0"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'startup' !
test: class title: title
    Transcript show: 'Testing '; show: title; cr.
    class test.
    Transcript show: 'end'; cr
! !

"June 6, 2007 -> 18:23:2"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
doubleOverflowCheck
	| number |
	number := 2.0.
	[ number isFinite ] whileTrue: [
		Transcript print: number; cr.
		number := number * number.
	]! !

"June 6, 2007 -> 18:23:3"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
indexTest
	   'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1.
        'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1. 'a' at: 1! !

"June 6, 2007 -> 18:23:3"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testContext
	self testContext: 1 and: 2 and: 3! !

"June 6, 2007 -> 18:23:4"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testContext: a and: b and: c
	[ (a + b) printString. self deoptimize ] value! !

"June 6, 2007 -> 18:23:5"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testNLR
	| f |
	f := self testNLRBlock.
	f value.
	
! !

"June 6, 2007 -> 18:23:6"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'test code' !
testNLRBlock
	^[^self]! !

"June 6, 2007 -> 18:23:7"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
displayErrorsFromHandler: eh  <DeltaTypeErrorHandler>  

eh reportedErrors isEmpty 
   ifTrue:[Transcript  show: 'No type errors'; cr.]
   ifFalse:[eh reportedErrors do:[: e <TypeError> | Transcript show: e errorMessage; cr.]].! !

"June 6, 2007 -> 18:23:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
tryNewClass! !

"June 6, 2007 -> 18:23:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
tryNewMixin! !

"June 6, 2007 -> 18:23:9"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
typecheckMinWorld! !

"June 6, 2007 -> 18:23:10"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'typechecker tests' !
typecheckMirror: m <Mirror>

m typecheck. 
m classSide typecheck
! !

"June 6, 2007 -> 18:23:11"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
clearLookupCache
	{{primitiveClearLookupCache}}! !

"June 6, 2007 -> 18:23:12"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
decodeAllMethods
	{{primitiveDecodeAllMethods}}.! !

"June 6, 2007 -> 18:23:13"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
printObjectHistogram
	{{primitivePrintObjectHistogram}}! !

"June 6, 2007 -> 18:23:14"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'utilities' !
setupInlining
	"Set inlining flags for helping the inlining compiler. Experimental"
	
	((Mirror on: HashedCollection) 	compiledMethodAt: #at: 					ifFail: []) neverInline.
	((Mirror on: Dictionary) 					compiledMethodAt: #at:put:				ifFail: []) neverInline.
	((Mirror on: Dictionary) 					compiledMethodAt: #at:put:ifNew:	ifFail: []) alwaysInline.
	((Mirror on: OutputStreamView) 	compiledMethodAt: #cr						ifFail: []) neverInline.
	((Mirror on: Object) 							compiledMethodAt: #assert:				ifFail: []) alwaysInline.
! !

"June 6, 2007 -> 18:24:30"!

"System saved" !
"June 6, 2007 -> 22:15:39"!

"System saved" !
"June 7, 2007 -> 1:20:56"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	"Smalltalk recompileAllMethods."
	Transcript show: 'Testing completed.'; cr.! !

"June 7, 2007 -> 1:22:11"!

"System saved" !
"June 8, 2007 -> 2:6:29"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	"win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}"! !

"June 8, 2007 -> 2:42:42"!

"System saved" !
"June 8, 2007 -> 3:4:34"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 8, 2007 -> 3:7:4"!

"System saved" !
"June 8, 2007 -> 21:54:37"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 8, 2007 -> 21:55:45"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle')) !


"June 8, 2007 -> 21:56:53"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 8, 2007 -> 21:57:8"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle <Win32Handle>
	"the thread id"')) !


"June 8, 2007 -> 22:3:55"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 8, 2007 -> 22:8:45"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 8, 2007 -> 22:31:45"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 8, 2007 -> 22:33:49"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 8, 2007 -> 22:34:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 9, 2007 -> 0:29:57"!

Delta define: #Win32Process as: (
(Class subclassOf: 'Process' instanceVariables: 'win32Handle <Win32Handle>
	"the thread id"')) !


"June 9, 2007 -> 0:30:47"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 0:31:37"!

! (Delta mirrorFor: #Win32Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 9, 2007 -> 0:35:33"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Process! !

"June 9, 2007 -> 0:50:14"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block

	^{{ self primitiveProcessCreate: block
				ifFail: [ :err <Symbol> | self error: err ]
		}}! !

"June 9, 2007 -> 0:52:6"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		(Platform processClass primitiveCreate: [ i recordId. block value ])
	  ) initFor: block.
	^i! !

"June 9, 2007 -> 0:53:30"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'platform classes' !
processClass
	^Win32Process! !

"June 9, 2007 -> 0:54:29"!

Delta define: #UnixProcess as: (
(Class subclassOf: 'Process' instanceVariables: '')) !


"June 9, 2007 -> 0:55:3"!

! (Delta mirrorFor: #UnixProcess) methodsFor: 'private-initialization' !
recordId! !

"June 9, 2007 -> 1:0:15"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
processClass

	^UnixProcess! !

"June 9, 2007 -> 1:8:57"!

"System saved" !
"June 9, 2007 -> 14:1:17"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:19"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"June 9, 2007 -> 14:1:20"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 9, 2007 -> 14:1:21"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		{{self primitiveProcessCreate: [ i recordId. block value ]
				ifFail: [ :err <Symbol> | self error: err ]
		}}
	  ) initFor: block.
	^i! !

"June 9, 2007 -> 14:1:22"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^80! !

"June 9, 2007 -> 14:1:23"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
initFor: block <[]>

	body := block.

	self register.
	
! !

"June 9, 2007 -> 14:1:24"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := {{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 14:1:25"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority ^<Int>

	^priority! !

"June 9, 2007 -> 14:1:26"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority: prio <Int>

	priority := prio! !

"June 9, 2007 -> 14:1:27"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
processError ^ <ProcessError>

	^processError
! !

"June 9, 2007 -> 14:1:28"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
status ^<Symbol>
	"One of:
		#Initialized				- State right after creation.
		#Yielded					- Gave up control by calling yield.
		#InAsyncDLL			- Gave up control but continues to execute asynchronous DLL.
		#Stopped				- Gave up control by calling stop.
		#Preempted			- Was preempted by system.
		#Running					- Currently running
		#Completed			- Ran to completion.
		#Killed						- The process has been terminated.
		#BooleanError		- A boolean was expected at hardcoded control structure.
		#LookupError			- The receiver does not understand doesNotUnderstand:.
		#PrimitiveLookupError	- Binding a primitive failed.
		#DLLLookupError				 - Binding a DLL function failed.
		#NLRError				- Context for NLR did not exist.
		#StackOverflow		- Stack exhausted.
	"

	^{{self primitiveProcessStatus}}! !

"June 9, 2007 -> 14:1:29"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
running ^<Boolean>
	"Not suspended, dying, or dead. (This includes processes blocked in async dll calls)"

	^Processor isRunning: self! !

"June 9, 2007 -> 14:1:30"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
suspended ^<Boolean>
	"Not on the running list, but can be resumed"

	| s <Symbol> |
	self running
		ifTrue: [ ^false ].
	s := self status.
	^s == #Yielded
		or: [ s == #InAsyncDLL
		or: [ s == #Initialized
		or: [ s == #Preempted
		or: [ s == #Stopped ]   ]]]! !

"June 9, 2007 -> 14:1:31"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
resume

	Processor resume: self! !

"June 9, 2007 -> 14:1:32"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
suspend

	Processor suspend: self.
	Processor activeProcess = self
		ifTrue: [ self yield ]! !

"June 9, 2007 -> 14:1:34"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
terminate

	Processor terminating: self.
	self vmTerminate.	! !

"June 9, 2007 -> 14:1:35"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
waitUntilDead
	"can be called after a process has been terminated to wait until it has completed
		unwinding its stack etc, and is truly dead.  This loops currently, so it is not
		a good way for waiting for the death of a process that has not been terminated.
		This may never return if the process that has been terminated does not ever
		finish cleaning up."
	
	[ self running ]
		whileTrue: [ Processor yield ]! !

"June 9, 2007 -> 14:1:36"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
activationStack ^ <Array[Activation]>

	^{{self primitiveProcessStackLimit: 100 ifFail: [ :err <CompressedSymbol>  | self error: err]}}! !

"June 9, 2007 -> 14:1:37"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
processError: e <ProcessError>

	processError := e
! !

"June 9, 2007 -> 14:1:38"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
stopInEvaluator

	Processor stopInEvaluator: self! !

"June 9, 2007 -> 14:1:39"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 20 ifFail: [ :err <Symbol> | self error: err]}}
! !

"June 9, 2007 -> 14:1:40"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"June 9, 2007 -> 14:1:41"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
yield
	{{primitiveProcessYield}}! !

"June 9, 2007 -> 14:1:42"!

! (Delta mirrorFor: #Process) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^112! !

"June 9, 2007 -> 14:1:43"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
register

	Processor register: self.! !

"June 9, 2007 -> 14:1:44"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
vmTerminate

	{{self primitiveProcessTerminateIfFail: [ :err <Symbol> | self error: err ]}}! !

"June 9, 2007 -> 14:6:45"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block! !

"June 9, 2007 -> 14:31:1"!

"System saved" !
"June 9, 2007 -> 15:17:24"!

! (Delta mirrorFor: #IdleProcess) classSide methodsFor: 'accessing' !
hasIdleActions

	^self theIdleProcess hasIdleActions! !

"June 9, 2007 -> 15:17:49"!

! (Delta mirrorFor: #ProcessorScheduler) methodsFor: 'private' !
hasIdleActions ^<Boolean>

	^IdleProcess hasIdleActions! !

"June 9, 2007 -> 17:42:19"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 9, 2007 -> 17:42:50"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"June 9, 2007 -> 17:43:43"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one three')) !


"June 9, 2007 -> 17:44:17"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"June 9, 2007 -> 17:44:48"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
one: aValue

	one := aValue! !

"June 9, 2007 -> 17:45:6"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
two: aValue

	two := aValue! !

"June 9, 2007 -> 17:45:18"!

! (Delta mirrorFor: #TestA) methodsFor: 'accessing' !
three: aValue

	three := aValue! !

"June 9, 2007 -> 17:47:0"!

(Delta mirrorFor: #TestA) removeMethod: #two: ifAbsent: [] !


"June 9, 2007 -> 17:47:23"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one three')) !


"June 9, 2007 -> 17:51:37"!

(Delta mirrorFor: #TestA) removeDefinitionIfFail: [] !


"June 9, 2007 -> 18:34:20"!

! (Delta mirrorFor: #IdleProcess) methodsFor: 'private' !
process

	^self! !

"June 9, 2007 -> 21:39:47"!

(Delta mirrorFor: #IdleProcess) removeMethod: #process ifAbsent: [] !


"June 9, 2007 -> 21:42:19"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'os-specific' !
processClass ! !

"June 9, 2007 -> 21:42:48"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os-specific' !
processClass ! !

"June 9, 2007 -> 21:43:17"!

(Delta mirrorFor: #Win32Platform) classSide removeMethod: #processClass ifAbsent: [] !


"June 9, 2007 -> 21:44:8"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os specific' !
currentThreadId

	^{{<kernel Win32Handle GetCurrentThreadId> call}}! !

"June 9, 2007 -> 21:44:31"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := Platform currentThreadId! !

"June 9, 2007 -> 21:45:0"!

(Delta mirrorFor: #Process) classSide removeMethod: #processClass ifAbsent: [] !


"June 9, 2007 -> 21:45:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId

	^0! !

"June 9, 2007 -> 21:50:6"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 "
	self deltaHack.
	^0! !

"June 9, 2007 -> 21:51:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	self deltaHack.
	^0! !

"June 9, 2007 -> 21:52:38"!

(Delta mirrorFor: #Process) classSide removeMethod: #primitiveCreate: ifAbsent: [] !


"June 9, 2007 -> 22:6:12"!

"System saved" !
"June 10, 2007 -> 0:57:19"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    ^name , '.so'! !

"June 10, 2007 -> 1:4:51"!

! (Delta mirrorFor: #UnixPlatform) methodsFor: 'instance creation' !
processClass! !

"June 10, 2007 -> 1:5:35"!

! (Delta mirrorFor: #UnixPlatform) methodsFor: 'instance creation' !
processClass 
! !

"June 10, 2007 -> 1:6:35"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
processClass 
! !

"June 10, 2007 -> 1:6:53"!

(Delta mirrorFor: #UnixPlatform) classSide removeMethod: #processClass ifAbsent: [] !


"June 10, 2007 -> 1:6:59"!

(Delta mirrorFor: #UnixPlatform) removeMethod: #processClass ifAbsent: [] !


"June 10, 2007 -> 1:17:21"!

Delta define: #UnixFilePattern as: (
(Class subclassOf: 'FilePattern' instanceVariables: '')) !


"June 10, 2007 -> 1:17:21"!

(Delta mirrorFor: #UnixFilePattern)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 10, 2007 -> 1:17:23"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'instance creation' !
for: pat <Str>  ^<FilePattern>

    self assert: [ self validPattern: pat ].
    ^self new pattern: pat! !

"June 10, 2007 -> 1:17:24"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'testing' !
validPattern: pat <Str> ^<Boolean>

    "Make sure this is a valid syntactic pattern (should be valid even if no *s)"
    self unimplemented! !

"June 10, 2007 -> 1:17:25"!

! (Delta mirrorFor: #UnixFilePattern) classSide methodsFor: 'restricted' !
patternHasWildcards: pat <Str> ^<Boolean>

    ^(pat includes: Platform multipleMatchWildcardCharacter)
        or: [ pat includes: Platform singleMatchWildcardCharacter ]! !

"June 10, 2007 -> 1:17:26"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
firstWildElementOf: els <SeqCltn[FilePattern]> ifFail: fail <[^X def]> ^<Int | X>

    1 to: els size do:
        [ :i <Int> |
            (els at: i) isPath
                ifFalse: [ ^i ]
        ].
    ^fail value! !

"June 10, 2007 -> 1:17:27"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
patternExtending: pat <FilePattern> ^<Str>

    ^pat pattern last = $\
        ifTrue: [ pat pattern, self pattern ]
        ifFalse: [ pat pattern,'\', self pattern ]! !

"June 10, 2007 -> 1:17:29"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    "assumes that the last element of the receiver is the only one that contains wildcards"
    | data <WIN32_FIND_DATA> hnd <Win32Handle> allpat <CString> pat <Str> els <SeqCltn[FilePattern]> prefix <Str> |
    data := WIN32_FIND_DATA new allocate.
    els := self elements.
    "%todo %opt - should check to see if the pattern is suitable for the windows call directly, so that the 
        elements are prefiltered.  Rule would be: use pattern directly if * appears only just before a dot or at the
        end, and contains no other wildcards"
    els size = 1
        ifTrue: [   allpat := CString for: '*.*'.
                        prefix := ''. ]
        ifFalse: [  allpat := CString for: self containingDirectory pattern, '\*.*'.
                            prefix := (FilePattern forAll: (els copyFrom: 1 to: els size - 1)) pattern,'\'.  ].
    pat := els last pattern.
    [   hnd := {{<kernel Win32Handle FindFirstFileA>
                        pattern: allpat
                        data: data
                    }}.
        hnd @= Win32 INVALID_HANDLE_VALUE
            ifTrue: [ Win32 getLastError @= Win32 ERROR_NO_MORE_FILES
                            ifFalse: [ Win32 handleError ]
                            ifTrue: [ ^self ]
                        ]
            ifFalse: [  [   | next <Str> |
                                next := data cFileName asString.
                                ((pat platformMatch: next) and: [ next ~= '.' and: [ next ~= '..' ]])
                                    ifTrue: [ blk value: (FilePath for: prefix,next) ].
                                [   {{<kernel Win32Handle FindNextFileA>
                                        hnd: hnd
                                        data: data
                                    }} asBoolean
                                        ifFalse: [ Win32 getLastError @= Win32 ERROR_NO_MORE_FILES
                                                            ifFalse: [ Win32 handleError ]
                                                            ifTrue: [ ^self ]
                                                     ]
                                        ifTrue: [   next := data cFileName asString.
                                                        ((pat platformMatch: next) and: [ next ~= '.' and: [ next ~= '..' ]])
                                                            ifTrue: [ blk value: (FilePath for: prefix,next) ].
                                                    ]
                                ] repeat.
                            ] ensure:
                                [   {{<kernel Win32Handle FindClose> hnd: hnd}} asBoolean
                                        ifFalse: [ Win32 handleError ].
                                ]
                        ]                                       
    ] ensure:
        [   data free.
            allpat free.        ]! !

"June 10, 2007 -> 1:17:30"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'testing' !
isAbsolute ^<Boolean>

    ^self pattern includes: $:! !

"June 10, 2007 -> 1:17:31"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $\.
                (next includes: $:)
                    ifTrue: [ next := next,'\' ].
                blk value: (FilePattern for: next)  ].! !

"June 10, 2007 -> 1:17:32"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
pathsDo: blk <[FilePath]>

    | els <SeqCltn[FilePattern]> i <Int> |
    els := self elements.
    i := self firstWildElementOf: els
                ifFail: [ ^self shouldNotHappen ].
    i = els size
        ifTrue: [ self terminalPathsDo: blk ]
        ifFalse: [  | rest <FilePattern> |
                        i + 1 = els size
                            ifTrue: [ rest := els last ]
                            ifFalse: [ rest := FilePattern forAll: (els copyFrom: i + 1 to: els size) ].
                        (FilePattern forAll: (els copyFrom: 1 to: i))
                            pathsDo:
                                [ :fp <FilePath> |
                                    fp isDirectory
                                        ifTrue: [ (fp, rest) pathsDo: blk ]     ]
                     ]! !

"June 10, 2007 -> 1:17:33"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'accessing' !
extensions ^<FilePattern>

    ^self , (FilePattern for: '*')! !

"June 10, 2007 -> 1:17:53"!

Delta define: #UnixFilePath as: (
(Class subclassOf: 'FilePath mixin |>(ExternalStreamableObject mixin |>(ExternalObject mixin |>UnixFilePattern))' instanceVariables: '')) !


"June 10, 2007 -> 1:17:53"!

(Delta mirrorFor: #UnixFilePath)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 10, 2007 -> 1:17:55"!

! (Delta mirrorFor: #UnixFilePath) classSide methodsFor: 'instance creation' !
currentDirectory ^<FilePath>

    | buf <CString> buflen <Int> |
    buflen := 1000.
    buf := CString new malloc: buflen.
    ^[      {{<kernel ExternalProxy GetCurrentDirectoryA>
                size: buflen
                buf: buf
            }} isNull
                ifTrue: [ Win32 handleError ]
                ifFalse: [ self new pattern: buf asString ]
      ] ensure: [ buf free ]! !

"June 10, 2007 -> 1:17:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>

    self win32FileAttributesIfFail: [ ^false ].
    ^true! !

"June 10, 2007 -> 1:17:57"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^((self win32FileAttributesIfFail: [ ^false ])
            externalBitAnd: Win32 FILE_ATTRIBUTE_DIRECTORY
      ) @~= 0! !

"June 10, 2007 -> 1:17:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^((self win32FileAttributesIfFail: [ ^false ])
            externalBitAnd: Win32 FILE_ATTRIBUTE_READONLY
      ) @~= 0! !

"June 10, 2007 -> 1:17:59"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isSyntaxValid ^<Boolean>

    "Extend inherited version to ensure no wildcard characters"
    ^super isSyntaxValid and: [ self unimplemented ]! !

"June 10, 2007 -> 1:18:0"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
createValueFor: mode <Symbol>  ^<ExternalData>

    mode = #read
        ifTrue: [ ^3        "OPEN_EXISTING" ].
    mode = #write
        ifTrue: [ ^2        "CREATE_ALWAYS" ].
    mode = #readWrite
        ifTrue: [ ^4        "OPEN_ALWAYS" ].
    self shouldNotHappen! !

"June 10, 2007 -> 1:18:1"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<kernel ExternalProxy RemoveDirectoryA>
                name: name
        }} asBoolean
            ifFalse: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:2"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<kernel ExternalProxy DeleteFileA>
                name: name
        }} asBoolean
            ifFalse: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:3"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileAttributesFor: mode <Symbol>  ^<ExternalData>
    
    mode = #read
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0800        "FILE_FLAG_SEQUENTIAL_SCAN"
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #write)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    (mode = #readWrite)
        ifTrue: [ ^ExternalProxy new
                    setHigh:    16r0000    
                    low:            16r80        "FILE_ATTRIBUTE_NORMAL"    ].
    self shouldNotHappen.! !

"June 10, 2007 -> 1:18:4"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>

    ^Win32FileDescriptor! !

"June 10, 2007 -> 1:18:5"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^ExternalProxy new setHigh: 16r8000 low: 0 ].
    mode = #write
        ifTrue: [ ^ExternalProxy new setHigh: (16r4000 bitOr: 16r8000) low: 0 ].
    mode = #readWrite
        ifTrue: [ ^ExternalProxy new setHigh: (16r4000 bitOr: 16r8000) low: 0 ].! !

"June 10, 2007 -> 1:18:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
sharingValueFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^1    "FILE_SHARE_WRITE" ].
    "in all other cases"
    ^0 "no sharing"! !

"June 10, 2007 -> 1:18:7"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
win32FileAttributesIfFail: blk <[^X def]> ^<ExternalProxy | X>

    | name <CString> |
    name := CString for: self name.
    ^[  | result <ExternalProxy> |
        result := {{<kernel ExternalProxy GetFileAttributesA>
                            name: name
                        }}.
        result @= (ExternalProxy forHigh: 16rFFFF low: 16rFFFF)
            ifTrue: [ blk value ]
            ifFalse: [ result ]
     ] ensure: [ name free ]! !

"June 10, 2007 -> 1:18:8"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <ExternalData>
        dsharing <ExternalData>
        dcreate <ExternalData>
        dattributes <ExternalData>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeProxyFor: mode.
    dsharing := self sharingValueFor: mode.
    dcreate := self createValueFor: mode.
    dattributes := self fileAttributesFor: mode.

    proxy := self win32CreateFile_name: dname
        mode: dmode
        sharing: dsharing
        security: 0
        create: dcreate
        attributes: dattributes
        template: 0.

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 10, 2007 -> 1:18:9"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
win32CreateFile_name: dname    <ExternalData>
mode: dmode            <ExternalData>
sharing: dsharing        <ExternalData>
security: dsecurity        <ExternalData>
create: dcreate            <ExternalData>
attributes: dattributes    <ExternalData>
template: dtemplate        <ExternalData>
^<ExternalProxy>
    ^{{<kernel ExternalProxy CreateFileA>
        name: dname
        mode: dmode
        sharing: dsharing
        security: dsecurity
        create: dcreate
        attributes: dattributes
        template: dtemplate}}! !

"June 10, 2007 -> 1:18:11"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> sec <SECURITY_ATTRIBUTES> |
    name := CString for: self name.
    sec := SECURITY_ATTRIBUTES new allocateZeroed.
    sec nLength: sec structureSize.

    [   {{<kernel ExternalProxy CreateDirectoryA>
            name: name
            security: sec
        }} asBoolean
            ifFalse: [ Win32 getLastError @= Win32 ERROR_ALREADY_EXISTS
                                ifFalse: [ fail value: #CannotCreateFile ] ]
    ] ensure: [ name free.
                        sec free.    ]! !

"June 10, 2007 -> 1:18:12"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted-double dispatching' !
deletePathIfFail: blk <[Symbol]>

    self exists
        ifFalse: [  blk value: #NoSuchFileOrDirectory.
                        ^self       ].
    self isDirectory
        ifTrue: [ self deleteDirectoryIfFail: blk ]
        ifFalse: [ self deleteFileIfFail: blk ]! !

"June 10, 2007 -> 1:18:13"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
copyAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<kernel ExternalProxy CopyFileA>
                source: csrc
                dest: cdest
                failIfExists: false asExternalData
        }} asBoolean
            ifFalse: [  fail value:
                                ('Error copying file: ', Win32 getLastError printString) asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"June 10, 2007 -> 1:18:14"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
moveAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<kernel ExternalProxy MoveFileA>
                source: csrc
                dest: cdest
        }} asBoolean
            ifFalse: [  | err <ExternalData> |
                            err := Win32 getLastError.
                            err @= Win32 ERROR_ALREADY_EXISTS
                                ifTrue: [   fail value: #AlreadyExists.
                                                 ^self.  ].
                            err @= Win32 ERROR_SHARING_VIOLATION
                                ifTrue: [   fail value: #SharingViolation.
                                                 ^self.  ].
                            fail value:
                                ('Error moving file: ', Win32 getLastError printString) asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"June 10, 2007 -> 1:18:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'accessing' !
type ^<Str>
    "The file type (on most platforms this is the part after the $. at the end)"

    | indices <SeqCltn[Int]> |
    indices := self name indicesOfSubCollection: '.'.
    indices isEmpty
        ifTrue: [ ^'' ].
    ^self name
            copyFrom: indices last + 1
            to: self name size! !

"June 10, 2007 -> 1:19:17"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
pathClass ^<FilePath class>

    ^UnixFilePath! !

"June 10, 2007 -> 1:19:25"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'platform classes' !
patternClass ^<FilePattern class>

    ^UnixFilePattern! !

"June 10, 2007 -> 1:51:59"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := CString for: self name.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
     	^result asSmallInteger >= 0]
     	ensure: [ name free.
     				{{<libc ExternalProxy close>
   	 					fd: result}} ]! !

"June 10, 2007 -> 1:53:55"!

"System saved" !
"June 11, 2007 -> 21:19:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<ExternalData>

    mode = #read
        ifTrue: [ ^ExternalProxy new set: 0 ].
    mode = #write
        ifTrue: [ ^ExternalProxy new set: 1 ].
    mode = #readWrite
        ifTrue: [ ^ExternalProxy new set: 2 ]! !

"June 11, 2007 -> 21:20:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeProxyFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^0 ].
    mode = #write
        ifTrue: [ ^1 ].
    mode = #readWrite
        ifTrue: [ ^2 ]! !

"June 11, 2007 -> 21:21:29"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^0 ].
    mode = #write
        ifTrue: [ ^1 ].
    mode = #readWrite
        ifTrue: [ ^2 ]! !

"June 11, 2007 -> 21:21:45"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <ExternalData>
        dsharing <ExternalData>
        dcreate <ExternalData>
        dattributes <ExternalData>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:22:10"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #win32CreateFile_name:mode:sharing:security:create:attributes:template: ifAbsent: [] !


"June 11, 2007 -> 21:23:10"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    "%todo: use overlapped io"
    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:25:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }}

    dname free.
    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:27:42"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.
    dmode := self modeFor: mode.

    [ proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:28:44"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 11, 2007 -> 21:30:9"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
win32FileAttributesIfFail: blk <[^X def]> ^<ExternalProxy | X>

    | name <CString> |
    self halt.
    name := CString for: self name.
    ^[  | result <ExternalProxy> |
        result := {{<kernel ExternalProxy GetFileAttributesA>
                            name: name
                        }}.
        result @= (ExternalProxy forHigh: 16rFFFF low: 16rFFFF)
            ifTrue: [ blk value ]
            ifFalse: [ result ]
     ] ensure: [ name free ]! !

"June 11, 2007 -> 22:28:5"!

Delta define: #UnixFileDescriptor as: (
(Class subclassOf: 'FileDescriptor' instanceVariables: 'ioCount <ExternalProxy>
            "Used to hold the count of bytes read/written, & other temporary results, for speed"
        ')) !


"June 11, 2007 -> 22:28:5"!

(Delta mirrorFor: #UnixFileDescriptor)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.2 $
'!


"June 11, 2007 -> 22:28:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
initializeIOCount
    ioCount := ExternalProxy new.
    ioCount malloc: 4.! !

"June 11, 2007 -> 22:28:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
ioCount ^<ExternalProxy>

    ^ioCount! !

"June 11, 2007 -> 22:28:8"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
postCopy
    super postCopy.
    self initializeIOCount.! !

"June 11, 2007 -> 22:28:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
printLastError
    | result |
    "Dump the error message for the last windows call"
    "%temporary"
    result := {{<kernel ExternalProxy GetLastError>geterror}}.
    Platform errorStream show: 'Last error from windows: ', result asSmallInteger printString; cr! !

"June 11, 2007 -> 22:28:10"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<kernel ExternalProxy SetFilePointer>
        handle: self handle
        distanceLow: p
        distanceHigh: 0
        moveMethod: 0 }}    "FILE_BEGIN"! !

"June 11, 2007 -> 22:28:11"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [        count := 0 ]
        ifFalse: [
                    result := {{<kernel ExternalProxy ReadFile>
                        handle: self handle
                        buffer: self buffer
                        count: self bufferSize
                        numberRead: self ioCount
                        overlapped: 0    }}.
                    result isNull
                        ifTrue: [ 
                        self printLastError.
                        errf value: #IOError.
                                ^0    ].
                    count := self ioCount smallIntegerAt: 0.    ].
    self setPosition: self position + count.
    ^count! !

"June 11, 2007 -> 22:28:12"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position ~= pos
        ifTrue: [ self position: pos ].
    result := {{<kernel ExternalProxy WriteFile>
        handle: self handle
        buffer: self buffer
        count: nBytes
        numberWritten: self ioCount
        overlapped: 0 }}.
    result isNull
        ifTrue: [ errf value: #IOError.
                ^0    ].
    count := self ioCount smallIntegerAt: 0.
    self setPosition: self position + count.! !

"June 11, 2007 -> 22:28:14"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
getBufferSize ^<Int>

    "Use the sector size"
    ^self sectorSize * 8! !

"June 11, 2007 -> 22:28:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
sectorSize ^<Int>
    "Use the sector size"
    | junk <ExternalProxy> bytesPerSector <ExternalProxy> status <ExternalProxy> result <Int> |
    junk := ExternalProxy new malloc: Platform wordSize.
    bytesPerSector := ExternalProxy new malloc: Platform wordSize.
    status := {{<kernel ExternalProxy GetDiskFreeSpaceA>
            rootPath: 0
            sectorsPerCluster: junk
            bytesPerSector: bytesPerSector
            freeClusters: junk
            clusters: junk    }}.
    status isNull
        ifTrue: [ self error: 'Cannot get disk sector size' ]
        ifFalse: [ result := bytesPerSector smallIntegerAt: 0 ].
    junk free.
    bytesPerSector free.
    ^result! !

"June 11, 2007 -> 22:28:16"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    | result <ExternalProxy> |
    result := {{<kernel ExternalProxy GetFileSize>
                handle: self handle
                sizeHigh: self ioCount    }}.
    self ioCount isAllOnes
        ifTrue: [ "must check for possible error status"
                | status <ExternalProxy> |
                "status := {<kernel ExternalProxy GetLastError>}."
                status isNull    "NO_ERROR"
                    ifFalse: [ self error: 'Can''t get file size' ].    ].
    ^(ioCount smallIntegerAt: 0) = 0
        ifFalse: [    "%todo: construct a large integer from the high&low words"
                    self unimplemented    ]
        ifTrue: [ result asSmallInteger ]! !

"June 11, 2007 -> 22:28:17"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
flushIfFail: errf <[ExternalError]>

    | result <ExternalProxy> |
    "%todo: uncomment"
    "result := {<kernel ExternalProxy FlushFileBuffers async>
        handle: self handle }."
    result isNull
        ifTrue: [ errf value: 'I/O Error flushing file information' ].! !

"June 11, 2007 -> 22:28:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
openIfFail: err <[ExternalError]>
    super openIfFail: err.
    self ioCount malloc: Platform wordSize.! !

"June 11, 2007 -> 22:28:19"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
severExternalConnections
    | result <ExternalProxy> |
    
    super severExternalConnections.
    self ioCount free.
    result := {{<kernel ExternalProxy CloseHandle>
        handle: self handle }}.
    result isNull
        ifTrue: [ self error: 'Error closing file handle' ].! !

"June 11, 2007 -> 22:28:20"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'initialization' !
mode: m <Symbol>
    super mode: m.
    self initializeIOCount.! !

"June 11, 2007 -> 22:29:30"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fileDescriptorClass ^<FileDescriptor class>

    ^UnixFileDescriptor! !

"June 11, 2007 -> 22:32:37"!

"System saved" !
"June 12, 2007 -> 1:35:32"!

Delta define: #StatBuffer as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"June 12, 2007 -> 2:14:23"!

(Delta mirrorFor: #StatBuffer)
comment: 
'Represents the buffer in which stat
returns file attributes'!


"June 12, 2007 -> 2:15:42"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
blockSize

	^self smallIntegerAt: self blockSizeOffset! !

"June 12, 2007 -> 2:15:59"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
structureSize

	^88! !

"June 12, 2007 -> 2:16:24"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
blockSizeOffset

	^48! !

"June 12, 2007 -> 2:38:52"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new allocate.
    [ status := {{<libc ExternalProxy fstat>
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 2:39:9"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
getBufferSize ^<Int>

    "Use the block size"
    ^self blockSize * 8! !

"June 12, 2007 -> 2:42:57"!

"System saved" !
"June 12, 2007 -> 11:26:54"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
version

	^3! !

"June 12, 2007 -> 11:27:24"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 11:28:12"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
blockSize ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [4096]
		ifFalse: [ statBuffer blockSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 11:29:46"!

"System saved" !
"June 12, 2007 -> 18:29:46"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<libc ExternalProxy libc>
        fd: self handle
        offset: p
        whence: self SEEK_SET }}    "FILE_BEGIN"! !

"June 12, 2007 -> 18:33:18"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
SEEK_SET

	^0! !

"June 12, 2007 -> 18:52:44"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [        count := 0 ]
        ifFalse: [
                    count := {{<libc ExternalProxy read>
                        fd: self handle
                        buffer: self buffer
                        count: self bufferSize    }}.
                    count := self ioCount smallIntegerAt: 0.    ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 19:29:4"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
fileSizeOffset

	^44! !

"June 12, 2007 -> 19:29:18"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
fileSize
! !

"June 12, 2007 -> 19:29:40"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
fileSize

	^self smallIntegerAt: self fileSizeOffset! !

"June 12, 2007 -> 19:33:36"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'accessing' !
size ^<Int>
    "Use the sector size"
    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	^status asSmallInteger == -1
		ifTrue: [0]
		ifFalse: [ statBuffer fileSize ]]
		ensure: [ statBuffer free]! !

"June 12, 2007 -> 19:43:26"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [ count := {{<libc ExternalProxy read>
                        fd: self handle
                        buffer: self buffer
                        count: self bufferSize    }} ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 19:47:14"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    count := {{<libc ExternalProxy write>
                        fd: self handle
                        buffer: self buffer
                        count: nBytes    }}.
    self setPosition: self position + count! !

"June 12, 2007 -> 19:53:7"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'control' !
severExternalConnections
    | result <ExternalProxy> |
    
    super severExternalConnections.
    self ioCount free.
    result := {{<libc ExternalProxy close>
        handle: self handle }}.
    result asSmallInteger == -1
        ifTrue: [ self error: 'Error closing file handle' ].! !

"June 12, 2007 -> 20:19:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 0
        }} asSmallInteger == -1
            ifFalse: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:22:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [ {{<libc ExternalProxy rmdir>
             name: name
        }} asSmallInteger == -1
            ifFalse: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:31:1"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<libc ExternalProxy unlink>
                name: name
        }} asSmallInteger == -1
            ifFalse: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 12, 2007 -> 20:33:38"!

"System saved" !
"June 12, 2007 -> 20:47:28"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'private' !
setExternalPosition: p <Int>
    "%todo: support large integer positions for extremely large files"
    {{<libc ExternalProxy lseek>
        fd: self handle
        offset: p
        whence: self SEEK_SET }}    "FILE_BEGIN"! !

"June 12, 2007 -> 20:49:30"!

"System saved" !
"June 12, 2007 -> 21:54:15"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
readAt: pos <Int> ifFail: errf <[ExternalError]> ^<Int>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    self knowAtEnd
        ifTrue: [ count := 0 ]
        ifFalse: [ count := {{<libc ExternalProxy read>
        				                fd: self handle
                        				buffer: self buffer
                        				count: self bufferSize }} asSmallInteger ].
    self setPosition: self position + count.
    ^count! !

"June 12, 2007 -> 21:55:36"!

"System saved" !
"June 13, 2007 -> 0:13:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_RDONLY

	^0! !

"June 13, 2007 -> 0:13:32"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_WRONLY

	^1! !

"June 13, 2007 -> 0:13:49"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_RDWR

	^2! !

"June 13, 2007 -> 0:16:45"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_CREAT

	^64! !

"June 13, 2007 -> 0:18:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^self O_WRONLY bitOr: self O_CREAT ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ]
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 0:21:27"!

"System saved" !
"June 13, 2007 -> 0:37:58"!

! (Delta mirrorFor: #UnixFileDescriptor) methodsFor: 'i/o' !
write: nBytes <Int> at: pos <Int> ifFail: errf <[ExternalError]>
    | result <ExternalProxy> count <Int> |
    self position = pos
        ifFalse: [ self position: pos ].
    count := {{<libc ExternalProxy write>
                        fd: self handle
                        buffer: self buffer
                        count: nBytes    }} asSmallInteger.
    self setPosition: self position + count! !

"June 13, 2007 -> 0:39:18"!

"System saved" !
"June 13, 2007 -> 0:49:47"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^self O_WRONLY bitOr: self O_CREAT ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 0:51:7"!

"System saved" !
"June 13, 2007 -> 16:56:15"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'restricted' !
openInternalFor: mode <Symbol> ifFail: err <[ExternalError, ^X def]>  ^<ExternalProxy | X>

    |   dname <ExternalProxy>
        dmode <SmallInt>
        proxy <ExternalProxy> |
    dname := self nameProxy.

    [ dmode := self modeFor: mode.
    	proxy := {{<libc ExternalProxy open>
    					name: dname
    					flags: dmode
    					create: 8r777 }} ]
    		ensure: [ dname free ].

    ^proxy isAllOnes
        ifFalse: [ proxy ]
        ifTrue: [ err value: #cannotOpenFile ]! !

"June 13, 2007 -> 16:58:7"!

"System saved" !
"June 13, 2007 -> 17:9:33"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_CREAT

	^8r100! !

"June 13, 2007 -> 17:9:53"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
O_TRUNC

	^8r1000! !

"June 13, 2007 -> 17:10:28"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
modeFor: mode <Symbol> ^<SmallInt>

    mode = #read
        ifTrue: [ ^self O_RDONLY ].
    mode = #write
        ifTrue: [ ^(self O_WRONLY bitOr: self O_CREAT) bitOr: self O_TRUNC ].
    mode = #readWrite
        ifTrue: [ ^self O_RDWR bitOr: self O_CREAT ].
    self error: 'Unrecognised mode: ' , mode! !

"June 13, 2007 -> 17:11:49"!

"System saved" !
"June 13, 2007 -> 18:37:47"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 0
        }} asSmallInteger == -1
            ifTrue: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 13, 2007 -> 18:39:4"!

"System saved" !
"June 13, 2007 -> 20:2:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'control' !
createDirectoryIfFail: fail <[Symbol]>

    | name <CString> |
    name := CString for: self name.

    [{{<libc ExternalProxy mkdir>
            name: name
            mode: 8r777
        }} asSmallInteger == -1
            ifTrue: [  fail value: #CannotCreateFile ]
    ] ensure: [ name free ]! !

"June 13, 2007 -> 20:4:21"!

"System saved" !
"June 13, 2007 -> 20:49:28"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
fstat: statBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    [ status := {{<libc ExternalProxy __fxstat>
    					version: statBuffer version
            			name: self handle
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ statBlock value: statBuffer ]]
		ensure: [ statBuffer free]! !

"June 13, 2007 -> 20:54:50"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free]! !

"June 13, 2007 -> 20:55:0"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #fstat:ifFail: ifAbsent: [] !


"June 13, 2007 -> 20:56:9"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
mode

	^self smallIntegerAt: self modeOffset! !

"June 13, 2007 -> 20:56:32"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
modeOffset

	^8! !

"June 13, 2007 -> 20:57:48"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 21:39:33"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
modeOffset

	^16! !

"June 13, 2007 -> 21:39:50"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
uidOffset

	^24! !

"June 13, 2007 -> 21:40:1"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'offsets' !
gidOffset

	^28! !

"June 13, 2007 -> 21:45:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IFDIR

	^8r40000! !

"June 13, 2007 -> 21:58:0"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IRUSR

	^8r4000! !

"June 13, 2007 -> 21:58:20"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWUSR

	^8r2000! !

"June 13, 2007 -> 21:58:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXUSR

	^8r1000! !

"June 13, 2007 -> 21:59:36"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXGRP

	^8r100! !

"June 13, 2007 -> 21:59:54"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWGRP

	^8r200! !

"June 13, 2007 -> 22:0:2"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IRGRP

	^8r400! !

"June 13, 2007 -> 22:0:25"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IROTH

	^8r40! !

"June 13, 2007 -> 22:0:34"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IWOTH

	^8r20! !

"June 13, 2007 -> 22:0:43"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
S_IXOTH

	^8r10! !

"June 13, 2007 -> 22:6:56"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
geteuid

	^{{<libc ExternalProxy geteuid> call}} asSmallInteger! !

"June 13, 2007 -> 22:7:11"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
getguid

	^{{<libc ExternalProxy getguid> call}} asSmallInteger! !

"June 13, 2007 -> 22:7:48"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
uid

	^self smallIntegerAt: self uidOffset! !

"June 13, 2007 -> 22:8:3"!

! (Delta mirrorFor: #StatBuffer) methodsFor: 'accessing' !
gid

	^self smallIntegerAt: self gidOffset! !

"June 13, 2007 -> 22:15:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == 0])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == 0])
    					or: [(stat mode bitAnd: self S_IWOTH) == 0]]]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 22:28:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
stat: testBlock ifFail: failBlock

    | statBuffer <StatBuffer> 
    	status <ExternalProxy>
    	name <CString> |
    statBuffer := StatBuffer new.
    statBuffer allocate.
    name := CString for: self name.
    [ status := {{<libc ExternalProxy __xstat>
    					version: statBuffer version
            			name: name
            			buffer: statBuffer    }}.
	status asSmallInteger == -1
		ifTrue: [ failBlock value ]
		ifFalse: [ ^testBlock value: statBuffer ]]
		ensure: [ statBuffer free.
						name free]! !

"June 13, 2007 -> 22:31:18"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
exists ^<Boolean>
	| name result |
	name := self nameProxy.
    [ result := {{<libc ExternalProxy open>
   	 					name: name
    					flags: 0}}.
     	^result asSmallInteger >= 0]
     	ensure: [ name free.
     				{{<libc ExternalProxy close>
   	 					fd: result}} ]! !

"June 13, 2007 -> 22:31:23"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isDirectory ^<Boolean>

    ^self stat: [:stat| (stat mode bitAnd: self S_IFDIR) == self S_IFDIR]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 13, 2007 -> 22:39:36"!

"System saved" !
"June 13, 2007 -> 22:55:42"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
patternExtending: pat <FilePattern> ^<Str>

    ^pat pattern last = $/
        ifTrue: [ pat pattern, self pattern ]
        ifFalse: [ pat pattern,'/', self pattern ]! !

"June 13, 2007 -> 22:57:18"!

"System saved" !
"June 13, 2007 -> 23:5:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"June 13, 2007 -> 23:8:45"!

! (Delta mirrorFor: #FilePath) classSide methodsFor: 'testing' !
test

	| f <FilePath> f2 <FilePath> |

	f := FilePath for: 'tmpDir'.
	[ f exists not ] verify.

	f createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ].
	[ f exists ] verify: 'tmpDir exists'.
	[ f isDirectory ] verify: 'tmpDir isDirectory'.
	[ f isWriteable ] verify: 'tmpDir isWriteable'.

	f2 := f , (FilePath for: 'sub').
	[ f2 exists not ] verify: 'tmpDir/sub exists not'.

	f2 createDirectoryIfFail: [ :err <Symbol> | Win32 handleError ].
	[ f2 exists ] verify: 'tmpDir/sub exists'.
	[ f isDirectory ] verify: 'tmpDir/sub isDirectory'.
	[ f isWriteable ] verify: 'tmpDir/sub isWriteable'.

	[ (self tryToDeleteTestDir: f) not ] verify: 'delete tmpDir should fail'.
	[ self tryToDeleteTestDir: f2 ] verify: 'delete tmpDir/sub'.
	[ self tryToDeleteTestDir: f ] verify: 'delete tmpDir'.

	[ f2 exists not ] verify: 'tmpDir/sub should not exist'.
	[ f exists not ] verify: 'tmpDir should not exist'.
! !

"June 13, 2007 -> 23:10:6"!

"System saved" !
"June 14, 2007 -> 0:9:58"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
getegid

	^{{<libc ExternalProxy getegid> call}} asSmallInteger! !

"June 14, 2007 -> 0:10:13"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #getguid ifAbsent: [] !


"June 14, 2007 -> 0:42:20"!

"System saved" !
"June 14, 2007 -> 20:20:37"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isReadOnly ^<Boolean>

    ^self isWriteable not! !

"June 14, 2007 -> 20:20:40"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'testing' !
isWriteable

    ^self stat: [:stat| 
    				(stat uid == self geteuid and: [(stat mode bitAnd: self S_IWUSR) == self S_IWUSR])
    					or: [(stat gid == self getegid and: [(stat mode bitAnd: self S_IWGRP) == self S_IWGRP])
    					or: [(stat mode bitAnd: self S_IWOTH) == self S_IWOTH]]]
    	ifFail: [ self error: 'could not stat file' ]! !

"June 14, 2007 -> 20:22:57"!

"System saved" !
"June 15, 2007 -> 17:41:22"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteDirectoryIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [ {{<libc ExternalProxy rmdir>
             name: name
        }} asSmallInteger == -1
            ifTrue: [ blk value: #ErrorDeletingDirectory ]
    ] ensure: [ name free ]! !

"June 15, 2007 -> 17:41:29"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'private' !
deleteFileIfFail: blk <[Symbol]>

    | name <CString> |
    name := CString for: self name.
    [   {{<libc ExternalProxy unlink>
                name: name
        }} asSmallInteger == -1
            ifTrue: [ blk value: #ErrorDeletingFile ]
    ] ensure: [ name free ]! !

"June 15, 2007 -> 17:43:12"!

"System saved" !
"June 17, 2007 -> 12:21:49"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6']
    self error: 'Unrecognised shared library'! !

"June 18, 2007 -> 10:26:43"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	Smalltalk recompileAllMethods.
	Transcript show: 'Testing completed.'; cr.! !

"June 18, 2007 -> 10:27:57"!

"System saved" !
"June 18, 2007 -> 18:51:20"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    self error: 'Mapping ', name, ' not found'! !

"June 18, 2007 -> 18:53:50"!

"System saved" !
"June 18, 2007 -> 19:20:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'environment' !
environmentVariableAt: key <Str> ifAbsent: blk <[^X def]> ^ <Str | X>

    | cKey <CString> cValue <CString> |
    cKey := CString for: key.
    [cValue := {{<libc CString getenv> key: cKey}}.
    ^cValue isNull
    	ifTrue: [blk value]
    	ifFalse: [cValue asString]]
    	ensure: [cKey free]! !

"June 18, 2007 -> 19:21:41"!

"System saved" !
"June 18, 2007 -> 21:1:8"!

! (Delta mirrorFor: #Bootstrap) methodsFor: 'library testing' !
deterministicallyTestSystem
	"As many tests as we can do deterministically (i.e. without requiring UI interaction, for now)."

	self testLibrary.
	"Smalltalk recompileAllMethods."
	Transcript show: 'Testing completed.'; cr.! !

"June 18, 2007 -> 21:1:37"!

"System saved" !
"December 2, 2007 -> 19:16:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
copyAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | source target	|
	source := self readStream.
	target := newPath writeStream.
	[[source atEnd]	 whileFalse: [
		target nextPut: source next]]
			ensure: [source close.
							target close]! !

"December 2, 2007 -> 19:41:10"!

"System saved" !
"December 3, 2007 -> 0:25:40"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                (next includes: $:)
                    ifTrue: [ next := next,'/' ].
                blk value: (FilePattern for: next)  ].! !

"December 3, 2007 -> 0:28:2"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t <SYSTEMTIME> |
	t := SYSTEMTIME new allocate.
	{{<kernel ExternalProxy GetLocalTime> struct: t}}.
	^t! !

"December 3, 2007 -> 0:28:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t <SYSTEMTIME> |
	t := SYSTEMTIME new allocate.
	{{<kernel ExternalProxy GetLocalTime> struct: t}}.
	^t
! !

"December 3, 2007 -> 0:29:15"!

! (Delta mirrorFor: #Time) classSide methodsFor: 'restricted-win32' !
localSYSTEMTIME ^<SYSTEMTIME>

	^Platform localSYSTEMTIME
! !

"December 3, 2007 -> 0:53:24"!

Delta define: #TimeT as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 3, 2007 -> 0:53:52"!

! (Delta mirrorFor: #TimeT) methodsFor: 'accessing' !
structureSize

	^4! !

"December 3, 2007 -> 1:11:44"!

Delta define: #TM as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 3, 2007 -> 1:32:8"!

"System saved" !
"December 3, 2007 -> 1:34:28"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
structureSize

	^32! !

"December 3, 2007 -> 1:37:36"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm st |
	t := TimeT new allocate.
	tm := TM new allocate.
	st := SYSTEMTIME new allocate.
	{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy time> struct: t}}.
	^t
! !

"December 3, 2007 -> 1:50:4"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mSecondOffset

	^0! !

"December 3, 2007 -> 1:50:37"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMinuteOffset

	^2! !

"December 3, 2007 -> 1:51:3"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mHourOffset

	^4! !

"December 3, 2007 -> 1:51:35"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mDayOffset

	^6! !

"December 3, 2007 -> 1:51:57"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMonthOffset

	^8! !

"December 3, 2007 -> 1:52:13"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mYearOffset

	^10! !

"December 3, 2007 -> 1:54:6"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth.
	st doubleByteAt: st wYearOffset put: self mYear.
	^st! !

"December 3, 2007 -> 1:55:4"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mDay

	^self doubleByteAt: self mDayOffset! !

"December 3, 2007 -> 1:55:22"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mSecond

	^self doubleByteAt: self mSecondOffset! !

"December 3, 2007 -> 1:55:33"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mMinute

	^self doubleByteAt: self mMinuteOffset! !

"December 3, 2007 -> 1:55:46"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mHour

	^self doubleByteAt: self mHourOffset! !

"December 3, 2007 -> 1:56:2"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mMonth

	^self doubleByteAt: self mMonthOffset! !

"December 3, 2007 -> 1:56:11"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
mYear

	^self doubleByteAt: self mYearOffset! !

"December 3, 2007 -> 1:57:43"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm st |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 1:58:47"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}}.
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:5:10"!

"System saved" !
"December 3, 2007 -> 2:43:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}} asInteger == -1
		ifTrue: [self error: 'Invalid time'].
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:45:44"!

"System saved" !
"December 3, 2007 -> 2:50:59"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	tm := TM new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	{{<libc ExternalProxy gmtime>
		struct: t
		result: tm}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:53:25"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc ExternalProxy gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:53:57"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 2:54:29"!

"System saved" !
"December 3, 2007 -> 3:3:30"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	Transcript show: 'stage1'.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	Transcript show: 'stage2'.
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: 'stage3'.
	^tm asSYSTEMTIME] ensure: [t free. tm free]
! !

"December 3, 2007 -> 3:3:50"!

"System saved" !
"December 3, 2007 -> 3:5:34"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	Transcript show: 'stage1'.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	Transcript show: 'stage2'.
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: 'stage3'.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:6:5"!

"System saved" !
"December 3, 2007 -> 3:8:54"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript show: tm mDay printString.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:11:51"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	Transcript
		show: tm mYear printString; space;
		show: tm mMonth printString; space;
		show: tm mDay printString; space;
		show: tm mHour printString; space;
		show: tm mMinute printString; space;
		show: tm mSecond printString.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:14:11"!

"System saved" !
"December 3, 2007 -> 3:16:47"!

! (Delta mirrorFor: #TM) methodsFor: 'accessing' !
structureSize

	^64! !

"December 3, 2007 -> 3:16:57"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mDayOffset

	^12! !

"December 3, 2007 -> 3:17:2"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mHourOffset

	^8! !

"December 3, 2007 -> 3:17:7"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMinuteOffset

	^4! !

"December 3, 2007 -> 3:17:17"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mMonthOffset

	^16! !

"December 3, 2007 -> 3:17:33"!

! (Delta mirrorFor: #TM) methodsFor: 'offsets' !
mYearOffset

	^20! !

"December 3, 2007 -> 3:18:8"!

"System saved" !
"December 3, 2007 -> 3:20:15"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth.
	st doubleByteAt: st wYearOffset put: self mYear + 1900.
	^st! !

"December 3, 2007 -> 3:20:42"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'time' !
localSYSTEMTIME ^<SYSTEMTIME>

	| t tm |
	t := TimeT new allocate.
	[{{<libc ExternalProxy time> struct: t}} isAllOnes
		ifTrue: [self error: 'Invalid time'].
	tm := {{<libc TM gmtime>
					struct: t}}.
	^tm asSYSTEMTIME] ensure: [t free]
! !

"December 3, 2007 -> 3:21:2"!

"System saved" !
"December 3, 2007 -> 3:27:49"!

! (Delta mirrorFor: #TM) methodsFor: 'converting' !
asSYSTEMTIME

	| st |
	st := SYSTEMTIME new allocate.
	st doubleByteAt: st wSecondOffset put: self mSecond.
	st doubleByteAt: st wMinuteOffset put: self mMinute.
	st doubleByteAt: st wHourOffset put: self mHour.
	st doubleByteAt: st wDayOffset put: self mDay.
	st doubleByteAt: st wMonthOffset put: self mMonth + 1.
	st doubleByteAt: st wYearOffset put: self mYear + 1900.
	^st! !

"December 3, 2007 -> 3:28:8"!

"System saved" !
"December 3, 2007 -> 23:52:19"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"December 3, 2007 -> 23:52:37"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two')) !


"December 3, 2007 -> 23:53:23"!

! (Delta mirrorFor: #TestA) classSide methodsFor: 'instance creation' !
one: one two: two

	^self new
		one: one
		two: two! !

"December 3, 2007 -> 23:54:26"!

! (Delta mirrorFor: #TestA) methodsFor: 'initialization' !
one: value1 two: value2

	one := value1.
	two := value2! !

"December 3, 2007 -> 23:59:24"!

Delta define: #TestA as: (
(Class subclassOf: 'Object' instanceVariables: 'one two three')) !


"December 4, 2007 -> 0:2:49"!

(Delta mirrorFor: #TestA) removeDefinitionIfFail: [] !


"December 4, 2007 -> 2:42:29"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob |
    glob := nil! !

"December 4, 2007 -> 2:43:25"!

Delta define: #GlobT as: (
(Class subclassOf: 'CStructure' instanceVariables: '')) !


"December 4, 2007 -> 2:44:4"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
structureSize

	^36! !

"December 4, 2007 -> 2:47:20"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathc

	^0! !

"December 4, 2007 -> 2:47:47"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathv

	^4! !

"December 4, 2007 -> 2:48:1"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathvOffset

	^4! !

"December 4, 2007 -> 2:48:13"!

! (Delta mirrorFor: #GlobT) methodsFor: 'offsets' !
glPathcOffset

	^0! !

"December 4, 2007 -> 2:54:13"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathc

	^self smallIntegerAt: self glPathcOffset! !

"December 4, 2007 -> 2:56:6"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathv

	^self subProxyAt: self glPathvOffset! !

"December 4, 2007 -> 3:8:30"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings |
    glob := GlobT new allocate.
   {{<libc ExternalProxy glob>
    	pattern: self pattern
    	flags: 0
    	ignore: 0
    	glob: glob}}.
    [pathArray := glob glPathv.
    strings := OrderedCollection new.
    1 to: glob glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString.
    	strings add: cstring]] ensure: [
   			strings do: [:string| string free].
   			pathArray free.
    		glob free]! !

"December 4, 2007 -> 3:10:10"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
    [pathArray := glob glPathv.
    strings := OrderedCollection new.
    1 to: glob glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString.
    	strings add: cstring]] ensure: [
   			strings do: [:string| string free].
   			pathArray free.
    		glob free.
    		patternString free]! !

"December 4, 2007 -> 3:13:55"!

! (Delta mirrorFor: #GlobT) methodsFor: 'iterating' !
pathsDo: blk

	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	cstring := (pathArray cStringAt: (index - 1) * 4).
    	blk value: cstring asString]! !

"December 4, 2007 -> 3:15:39"!

! (Delta mirrorFor: #GlobT) methodsFor: 'allocating' !
free
	
	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	(pathArray cStringAt: (index - 1) * 4) free].
    pathArray free.
    super free! !

"December 4, 2007 -> 3:16:55"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: blk]
		ensure: [glob free]! !

"December 4, 2007 -> 3:17:18"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: blk]
		ensure: [
			glob free.
			patternString free.]! !

"December 4, 2007 -> 3:19:36"!

"System saved" !
"December 4, 2007 -> 3:30:24"!

! (Delta mirrorFor: #GlobT) methodsFor: 'accessing' !
glPathv

	^self proxyAt: self glPathvOffset! !

"December 4, 2007 -> 3:36:17"!

! (Delta mirrorFor: #GlobT) methodsFor: 'iterating' !
pathsDo: blk

	| pathArray |
	pathArray := self glPathv.
	1 to: self glPathc do: [:index| |cstring|
    	cstring := (pathArray
    		proxyAt: (index - 1) * 4
    		result: CString new).
    	blk value: cstring asString]! !

"December 4, 2007 -> 3:37:26"!

"System saved" !
"December 4, 2007 -> 3:43:41"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'private' !
terminalPathsDo: blk <[FilePath]>

    | glob pathArray strings patternString |
   glob := GlobT new allocate.
   patternString := CString for: self pattern.
   {{<libc ExternalProxy glob>
    	pattern: patternString
    	flags: 0
    	ignore: 0
    	glob: glob}}.
	[glob pathsDo: [:pathString| blk value: (FilePath for: pathString)]]
		ensure: [
			glob free.
			patternString free.]! !

"December 4, 2007 -> 3:44:19"!

(Delta mirrorFor: #GlobT) removeMethod: #free ifAbsent: [] !


"December 4, 2007 -> 3:44:52"!

"System saved" !
"December 4, 2007 -> 23:44:58"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'testing' !
isAbsolute ^<Boolean>

    ^self pattern first == $/! !

"December 4, 2007 -> 23:52:13"!

(Delta mirrorFor: #UnixFilePath) removeMethod: #win32FileAttributesIfFail: ifAbsent: [] !


"December 4, 2007 -> 23:58:6"!

! (Delta mirrorFor: #UnixFilePath) methodsFor: 'copying-moving' !
moveAs: newPath <FilePath> ifFail: fail <[ExternalError]>

    | csrc <CString> cdest <CString> |
    csrc := CString for: self name.
    cdest := CString for: newPath name.
    [   {{<libc ExternalProxy rename>
                source: csrc
                dest: cdest
        }} isAllOnes
            ifTrue: [ fail value: 'Error moving file.' asSymbol ]
    ] ensure:
        [   csrc free.
            cdest free  ]! !

"December 4, 2007 -> 23:59:30"!

"System saved" !
"December 5, 2007 -> 0:8:45"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #printLastError ifAbsent: [] !


"December 5, 2007 -> 0:9:29"!

(Delta mirrorFor: #UnixFileDescriptor) removeMethod: #sectorSize ifAbsent: [] !


"December 5, 2007 -> 0:13:28"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'testing' !
usesCrLfConvention ^<Boolean>

    ^false! !

"December 5, 2007 -> 0:15:9"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name! !

"December 5, 2007 -> 0:37:10"!

"System saved" !
"December 6, 2007 -> 0:31:8"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                next isEmpty
                    ifFalse: [ blk value: (FilePattern for: next)] ]! !

"December 6, 2007 -> 0:31:10"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
elementsDo: blk <[FilePattern]>

    | s <CharacterReadStream> |

    s := self pattern readStream.
    [ s atEnd ]
        whileFalse:
            [   | next <Str> |
                next := s upTo: $/.
                next isEmpty
                    ifFalse: [ blk value: (FilePattern for: next)] ]! !

"December 6, 2007 -> 0:31:39"!

"System saved" !
"December 6, 2007 -> 0:42:53"!

! (Delta mirrorFor: #UnixFilePattern) methodsFor: 'iterating' !
pathsDo: blk <[FilePath]>

	self terminalPathsDo: blk
    "| els <SeqCltn[FilePattern]> i <Int> |
    els := self elements.
    i := self firstWildElementOf: els
                ifFail: [ ^self shouldNotHappen ].
    i = els size
        ifTrue: [ self terminalPathsDo: blk ]
        ifFalse: [  | rest <FilePattern> |
                        i + 1 = els size
                            ifTrue: [ rest := els last ]
                            ifFalse: [ rest := FilePattern forAll: (els copyFrom: i + 1 to: els size) ].
                        (FilePattern forAll: (els copyFrom: 1 to: i))
                            pathsDo:
                                [ :fp <FilePath> |
                                    fp isDirectory
                                        ifTrue: [ (fp, rest) pathsDo: blk ]     ]
                     ]"! !

"December 6, 2007 -> 0:43:35"!

"System saved" !
"December 6, 2007 -> 1:7:16"!

! (Delta mirrorFor: #BasicReadStream) methodsFor: 'smalltalk filein' !
fileIn

	(CharacterReadConverter on: self) fileIn! !

"December 6, 2007 -> 1:9:23"!

"System saved" !"December 6, 2007 -> 2:16:15"!Delta define: #SimpleTest as: ((Class subclassOf: 'Object' instanceVariables: '')) !"December 6, 2007 -> 2:16:21"!"System saved" !
"December 6, 2007 -> 2:17:32"!

(Delta mirrorFor: #SimpleTest) removeDefinitionIfFail: [] !


"December 6, 2007 -> 2:17:53"!

"System saved" !"December 6, 2007 -> 2:25:14"!Delta define: #SimpleTest as: ((Class subclassOf: 'Object' instanceVariables: '')) !"December 6, 2007 -> 2:25:20"!"System saved" !
"December 7, 2007 -> 0:33:55"!

(Delta mirrorFor: #SimpleTest) removeDefinitionIfFail: [] !


"December 7, 2007 -> 0:39:42"!

"System saved" !
"December 8, 2007 -> 17:50:0"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"December 8, 2007 -> 17:50:33"!

"System saved" !
"December 8, 2007 -> 22:34:23"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	self deltaHack.
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:34:56"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	" stub to allow compatibility with Win32 specifics of process "
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:35:5"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId

	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:35:23"!

! (Delta mirrorFor: #Win32Platform) classSide methodsFor: 'os specific' !
currentThreadId

	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:36:14"!

"System saved" !
"December 8, 2007 -> 22:49:41"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	^ 0
	"^ {{ primitiveCurrentThreadId }}"! !

"December 8, 2007 -> 22:50:4"!

"System saved" !
"December 8, 2007 -> 22:57:3"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'os specific' !
currentThreadId
	"^ 0"
	^ {{ primitiveCurrentThreadId }}! !

"December 8, 2007 -> 22:57:33"!

"System saved" !
"December 9, 2007 -> 19:45:6"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so'].
    ^name, '.so'! !

"December 9, 2007 -> 19:45:26"!

"System saved" !
"December 9, 2007 -> 20:21:22"!

! (Delta mirrorFor: #UnixPlatform) classSide methodsFor: 'Dynamic Linked Libraries' !
DLLMapName: name <Str> ^<Str>
    name = 'libc' ifTrue: [^'libc.so.6'].
    ^name, '.so'! !

"December 9, 2007 -> 20:23:17"!

"System saved" !
"April 29, 2008 -> 19:10:19"!

! (Delta mirrorFor: #DeltaProtocol) methodsFor: 'Unclassified' !
isRelevantSubstitution: s <Substitution> ^ <Boolean>
" In our system, substitutions are constructed in a structured fashion.
Consequently, either all the keys of a substitution are relevant, or none are.
We choose an arbitrary key, check if it is relevant, and return the result.
"
| res |

s keys do:[: k <Symbol> | 
                     ^self relevantTypeVars includes: k.
                    ].
^false! !

"April 29, 2008 -> 19:10:37"!

"System saved" !
"April 30, 2008 -> 0:16:41"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
add: anElement

	anElement isNil ifTrue: [^self].
	super add: anElement! !

"April 30, 2008 -> 0:16:41"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
add: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super add: anElement! !

"April 30, 2008 -> 0:17:4"!

"System saved" !
"May 2, 2008 -> 2:39:7"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement! !

"May 2, 2008 -> 9:56:38"!

"System saved" !
"May 18, 2008 -> 2:18:6"!

Delta define: #ExceptionSelector as: (
Protocol superProtocol: '<Object>') !


"May 18, 2008 -> 2:18:6"!

(Delta mirrorFor: #ExceptionSelector)
comment: 
'Defines the <exceptionSelector> protocol from the ANSI standard.'!


"May 18, 2008 -> 2:18:6"!

! (Delta mirrorFor: #ExceptionSelector) methodsFor: 'exception selector' !
handles: anException ! !

"May 18, 2008 -> 2:18:14"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 18, 2008 -> 2:18:14"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test	self testShouldHandleWhenHandleBlockReturnsTrue;		testShouldPassExceptionToHandlesBlock! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock	|exception selector|	exception := Object new.	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].	selector handles: exception! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue	|canHandle selector|		selector := BlockExceptionSelector					handlesBlock: [:ex| canHandle].	canHandle := true.	[selector handles: nil] verify.	canHandle := false.	[(selector handles: nil) not] verify! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block 	^self new		handlesBlock: block;		yourself! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block	handlesBlock := block ! !

"May 18, 2008 -> 2:18:14"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor	^handlesBlock value: exceptionDescriptor! !

"May 18, 2008 -> 2:18:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandlerBlockWithException! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException	|handled exception|	handled := false.	exception = Object new.	(BlockExceptionHandler		handleBlock: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block	^self new		handleBlock: block;		yourself! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new	^super new initialize! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize	handleBlock := [:exception|].	passBlock := [:exception|].! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block	handleBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^false! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock	^aBlock value: (handleBlock value: exception)! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception	^handleBlock value: exception! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block	passBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception	passBlock value: exception! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nil! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block	returnBlock := block! !

"May 18, 2008 -> 2:18:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value	returnBlock value: value! !

"May 18, 2008 -> 2:18:30"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 18, 2008 -> 2:18:30"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new	^super new		initialize;		yourself! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test	self testDefaultActionShouldInvokeDefaultActionBlock;		testDefaultDefault;		testHandlerShouldDelegateToHandlerBlock! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault	|exception wasInvoked|	exception := BlockExceptionDescriptor new.	exception defaultAction! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock	|exception wasInvoked|	exception := BlockExceptionDescriptor new.	wasInvoked := false.	exception defaultActionBlock: [wasInvoked := true].	exception defaultAction.	[wasInvoked] verify! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock	|descriptor actualHandler|		descriptor := BlockExceptionDescriptor new.	descriptor handlerBlock: [:handler| actualHandler := handler].	descriptor handler: #handler.	[actualHandler == #handler] verify! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block	defaultBlock := block! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block	handlerBlock := block ! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler	handlerBlock value: handler ! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize	defaultBlock := [].	handlerBlock := [:ignore|]! !

"May 18, 2008 -> 2:18:30"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction	defaultBlock value! !

"May 18, 2008 -> 2:18:37"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 18, 2008 -> 2:18:38"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandlerBlockWithException! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException	|handled exception|	handled := false.	exception = Object new.	(BlockExceptionHandler		handleBlock: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block	^self new		handleBlock: block;		yourself! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new	^super new initialize! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize	handleBlock := [:exception|].	passBlock := [:exception|].! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block	handleBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^false! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock	^aBlock value: (handleBlock value: exception)! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception	^handleBlock value: exception! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block	passBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception	passBlock value: exception! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nil! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block	returnBlock := block! !

"May 18, 2008 -> 2:18:38"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value	returnBlock value: value! !

"May 18, 2008 -> 2:18:43"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 18, 2008 -> 2:18:43"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test	self testShouldInvokeHandleBlockWhenExceptionMatches;		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;		testShouldDelegateToNextHandlerWhenNoMatch;		testHandlerShouldSetHandlerOnException;		testPassShouldDeferToNextHandler;		testReturnShouldEvaluateReturnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches	|handled trueSelector exception|	handled := false.	exception := BlockExceptionDescriptor new.	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	(LinkedExceptionHandler		on: trueSelector		do: [:ex| [ex == exception] verify.			handled := true])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch	|handled falseSelector exception nextHandler|	handled := false.	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].	exception := BlockExceptionDescriptor new.	nextHandler := (BlockExceptionHandler						handleBlock: [:ex| [ex == exception] verify.										handled := true]).	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])		nextHandler: nextHandler;		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler	|handled falseSelector exception|	handled := false.	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].	exception := BlockExceptionDescriptor new.	exception defaultActionBlock: [handled := true].	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])		handle: exception.	[handled] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler	|handler trueSelector exception wasPassed nextHandler|	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	exception := BlockExceptionDescriptor new.		handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].	handler nextHandler: nextHandler.		wasPassed := false.	handler pass: exception.	[wasPassed] verify	! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock	|handler result |	handler := LinkedExceptionHandler					on: nil					do: [:ex| ]					return: [:returnValue| result := returnValue].	handler return: #value.	[result == #value] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException	|handler trueSelector exception assignedHandler|	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].	exception := BlockExceptionDescriptor new.	exception handlerBlock: [:handler| assignedHandler := handler].	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].	[assignedHandler ~~ handler] verify.	handler handle: exception.	[assignedHandler == handler] verify! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock	^self new		on: anExceptionSelector do: handleBlock return: [:value|] outer: nil;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock	^self new		on: anExceptionSelector do: handleBlock return: returnBlock outer: nil;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock	^self new		on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock;		yourself! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock	exceptionSelector := anExceptionSelector.	handleBlock := block.	returnBlock := aReturnBlock.	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler	nextHandler := exceptionHandler ! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception	self handle: exception		return: returnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock	Processor activeProcess pushHandler: self.	^[(self evaluateProtectee: aBlock) value]		ensure: [Processor activeProcess popHandler]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock	|result|	protectee := aBlock.	retryBlock := [^[self evaluateProtectee: protectee]].	result := protectee value.	^[result]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry		retryBlock value! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock		protectee := aBlock.	retryBlock value! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception	^(exceptionSelector handles: exception)		or: [nextHandler notNil 		and: [nextHandler canHandleSignal: exception]]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock	exception handler: self.	^(exceptionSelector handles: exception)		ifTrue: [aReturnBlock value: (handleBlock value: exception)]		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock	^nextHandler handle: exception return: aReturnBlock! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception	^nextHandler handle: exception! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue	returnBlock value: aValue! !

"May 18, 2008 -> 2:18:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler	^nextHandler! !

"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 18, 2008 -> 2:18:50"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^80! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
for: block <[]> ^<Instance>
	"Create and return a new process that will execute the block at the
	 specified priority.  The new process is suspended."

	| i <Instance> |
	i := (guaranteed <Instance>
		{{self primitiveProcessCreate: [ i recordId. block value ]
				ifFail: [ :err <Symbol> | self error: err ]
		}}
	  ) initFor: block.
	^i! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'instance creation' !
primitiveCreate: block! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
test

	self testHandleShouldInvokeDefaultAction;
		 testPushHandlerShouldReplaceDefaultHandler;
		 testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch;
		 testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	Processor activeProcess handle: exception.
	[wasInvoked] verify.! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldReplaceDefaultHandler

	|process exceptionSelector wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| wasInvoked := true]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process exceptionSelector wasInvoked exception|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	process := Processor activeProcess.
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| ]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) classSide methodsFor: 'testing' !
testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process trueSelector falseSelector wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [].
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	process := Processor activeProcess.
	outerHandler := (LinkedExceptionHandler
							on: trueSelector
							do: [:ex| wasInvoked := true]).
	[process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
							on: falseSelector
							do: [:ex| ]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler.
			process popHandler]
! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority ^<Int>

	^priority! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
priority: prio <Int>

	priority := prio! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
processError ^ <ProcessError>

	^processError
! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'accessing' !
status ^<Symbol>
	"One of:
		#Initialized				- State right after creation.
		#Yielded					- Gave up control by calling yield.
		#InAsyncDLL			- Gave up control but continues to execute asynchronous DLL.
		#Stopped				- Gave up control by calling stop.
		#Preempted			- Was preempted by system.
		#Running					- Currently running
		#Completed			- Ran to completion.
		#Killed						- The process has been terminated.
		#BooleanError		- A boolean was expected at hardcoded control structure.
		#LookupError			- The receiver does not understand doesNotUnderstand:.
		#PrimitiveLookupError	- Binding a primitive failed.
		#DLLLookupError				 - Binding a DLL function failed.
		#NLRError				- Context for NLR did not exist.
		#StackOverflow		- Stack exhausted.
	"

	^{{self primitiveProcessStatus}}! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
resume

	Processor resume: self! !

"May 18, 2008 -> 2:18:50"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
suspend

	Processor suspend: self.
	Processor activeProcess = self
		ifTrue: [ self yield ]! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
terminate

	Processor terminating: self.
	self vmTerminate.	! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'control' !
waitUntilDead
	"can be called after a process has been terminated to wait until it has completed
		unwinding its stack etc, and is truly dead.  This loops currently, so it is not
		a good way for waiting for the death of a process that has not been terminated.
		This may never return if the process that has been terminated does not ever
		finish cleaning up."
	
	[ self running ]
		whileTrue: [ Processor yield ]! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'file out' !
fileOutSignature ^<Integer>
    ^112! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
register

	Processor register: self.! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private' !
vmTerminate

	{{self primitiveProcessTerminateIfFail: [ :err <Symbol> | self error: err ]}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
initFor: block <[]>

	body := block.

	self register.
	
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'private-initialization' !
recordId

	win32Handle := Platform currentThreadId! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
activationStack ^ <Array[Activation]>

	^{{self primitiveProcessStackLimit: 100 ifFail: [ :err <CompressedSymbol>  | self error: err]}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
processError: e <ProcessError>

	processError := e
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
stopInEvaluator

	Processor stopInEvaluator: self! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
traceStack

	{{self primitiveProcessTraceStack: 20 ifFail: [ :err <Symbol> | self error: err]}}
! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
win32Handle ^<Win32Handle>
	"This is valid only after the process has begun to actually execute"

	^win32Handle! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'restricted' !
yield
	{{primitiveProcessYield}}! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
running ^<Boolean>
	"Not suspended, dying, or dead. (This includes processes blocked in async dll calls)"

	^Processor isRunning: self! !

"May 18, 2008 -> 2:18:51"!

! (Delta mirrorFor: #Process) methodsFor: 'testing' !
suspended ^<Boolean>
	"Not on the running list, but can be resumed"

	| s <Symbol> |
	self running
		ifTrue: [ ^false ].
	s := self status.
	^s == #Yielded
		or: [ s == #InAsyncDLL
		or: [ s == #Initialized
		or: [ s == #Preempted
		or: [ s == #Stopped ]   ]]]! !

"May 18, 2008 -> 2:19:14"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 18, 2008 -> 2:19:14"!

Delta define: #TestException as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:14"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test	self testSignalShouldInvokeProcessHandler;		testPassShouldDeferToOuterHandler;		testPassShouldNotReturn;		testPassShouldInvokeDefaultActionWithoutReturning;		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;		testOuterTwiceShouldInvokeSurroundingHandlerTwice;		testResumeShouldReturnAsValueOfOuter;		testResumeShouldReturnFromSignal;		testResumeWithValueShouldReturnFromSignal;		testReturnShouldDelegateToHandler;		testIsNestedShouldBeFalseWithNoHandler;		testIsNestedShouldBeTrueWhenOuterHandlerHandles;		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;		testResignalAsShouldRestoreSignalEnvironment;		testRetryShouldReevaluateProtectee;		testRetryUsingShouldReplaceProtectee! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler	|wasPassed|	wasPassed := false.	[[Exception signal]		on: Exception		do: [:ex| ex pass]]			on: Exception			do: [:ex| wasPassed := true].	[wasPassed] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn	[([[Exception signal]		on: Exception		do: [:ex| ex pass.			self shouldNotHappen]]			on: Exception			do: [:ex| #result]) == #result] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning	[([|result|		result := (TestException defaultActionBlock: [#result])						signal.		[result == #result] verify.		result]			on: TestException			do: [:ex| ex pass.				self shouldNotHappen]) == #result] verify! !

"May 18, 2008 -> 2:19:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable	[([|result|		result := (TestException defaultActionBlock: [#result])						signal.		[result == #result] verify.		result]			on: TestException			do: [:ex| ex outer.				self shouldNotHappen]) == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable	|outer result|	[(TestException defaultActionBlock: [#result])		resumable: true;		signal]			on: TestException			do: [:ex| outer := ex outer.				result := #returned].	[result == #returned] verify.	[outer == #result] verify.! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice	|count|	count := 0.	[[(TestException defaultActionBlock: [-1])			resumable: true;			signal]		on: TestException		do: [:ex| ex outer.				ex outer]]			on: TestException			do: [:ex| count := count + 1].	[count == 2] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter	|result|	[[Exception signal]	 	on: Exception	 	do: [:ex| result := ex outer]]	 		on: Exception	 		do: [:ex| ex resume: #result].	[result == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal	|result|	[result := Exception signal]	 	on: Exception	 	do: [:ex| ex resume: #result].	[result == #result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal	|wasResumed|	wasResumed := false.	[Exception signal.	 wasResumed := true]	 	on: Exception	 	do: [:ex| ex resume].	[wasResumed] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler		|wasInvoked|	wasInvoked := false.	Processor activeProcess 		pushHandler: (BlockExceptionHandler 						handleBlock: [:ex| wasInvoked := true]).	Exception signal.	[[wasInvoked] verify]		ensure: [Processor activeProcess popHandler]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler		|exception handler result|	exception := Exception new.	handler := BlockExceptionHandler new.	result := #invalid.	handler returnBlock: [:value| result := value].	exception handler: handler.	exception return.	[result isNil] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler		|exception|	exception := Exception new.	[exception isNested not] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles		|result|	[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: Exception			do: [:ex| self shouldNotHappen]. 	[result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee		|log count|	log := String new writeStream.	count := 0.	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]		on: Exception		do: [:ex|			log nextPutAll: 'handle '.			count := count + 1.			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.												Exception signal]]].	[log contents = 'handle unwind using handle '] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee		|count|	count := 0.	[count := count + 1.	count == 1 ifTrue:[Exception signal]]		on: Exception		do: [:ex| ex retry].	[count == 2] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment		|log|	log := String new writeStream.	[[Exception signal]		on: TestException		do: [:ex| log nextPutAll: 'resignal']]			on: Exception			do: [:ex|				[log nextPutAll: 'signal '. 				ex resignalAs: TestException new]					ifCurtailed: [log nextPutAll: 'curtail ']].	[log contents = 'signal curtail resignal'] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles		|result|	[[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: TestException			do: [:ex|]]				on: Exception				do: [:ex|]. 	[result] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle		|result|	[[Exception signal]		on: Exception		do: [:ex| result := ex isNested]]			on: TestException			do: [:ex|]. 	[result not] verify! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t	"This message is not specified in the ANSI protocol, but that looks like an oversight because #tag is specified, and the spec states that the signaler may store the tag value."	tag := t! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag	"Return an exception's tag value."	^tag == nil		ifTrue: [self messageText]		ifFalse: [tag]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested	"Determine whether the current exception handler is within the scope of another handler for the same exception."	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer	"Evaluate the enclosing exception action and return to here instead of signal if it resumes (see #resumeUnchecked:)."	| oldHandler oldResume |	self isResumable ifFalse: [		self pass.	].		[oldResume := resumeBlock.	resumeBlock := [:value| ^value].	(oldHandler := handler) outer: self return: [:value| ^value]]		ensure: [handler := oldHandler.				resumeBlock := oldResume]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass	"Yield control to the enclosing exception action for the receiver."	passBlock value! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException	"Signal an alternative exception in place of the receiver."	resignalBlock value: replacementException! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume	"Return from the message that signaled the receiver."	self resume: nil! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue	"Return resumptionValue as the value of the signal message."	resumeBlock value: resumptionValue! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry	"Abort an exception handler and re-evaluate its protected block."	handler retry! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock	"Abort an exception handler and evaluate a new block in place of the handler's protected block."	handler retryUsing: alternativeBlock! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return	"Return nil as the value of the block protected by the active exception handler."	self return: nil! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue	"Return the argument as the value of the block protected by the active exception handler."	handler return: returnValue! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description	"Return a textual description of the exception."	| desc mt |	desc := self class name asString.	^(mt := self messageText) == nil		ifTrue: [desc]		ifFalse: [desc, ': ', mt]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText	"Return an exception's message text."	^messageText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream	stream nextPutAll: self description! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText	"Set an exception's message text."	messageText := signalerText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal	^self privateSignal value! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal	"Ask ContextHandlers in the sender chain to handle this signal.  The default is to execute and return my defaultAction."		resignalBlock := [:ex| ^[ex signal]].	resumeBlock := [:result| ^[result]].	passBlock := [^[handler pass: self]].	Processor activeProcess handle: self.	^[]! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	self messageText: signalerText.	^ self signal! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction	"The default action taken if the exception is signaled."	self subclassResponsibility! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable	"Determine whether an exception is resumable."	^ true! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler	handler := aHandler! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal	"Signal the occurrence of an exceptional condition."	^ self new signal! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText	"Signal the occurrence of an exceptional condition with a specified textual description."	^ self new signal: signalerText! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException	"Create an exception set.""	^ExceptionSet new		add: self;		add: anotherException;		yourself"! !

"May 18, 2008 -> 2:19:15"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception	"Determine whether an exception handler will accept a signaled exception."	^ exception isKindOf: self! !

"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"May 18, 2008 -> 2:19:21"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block	^self new		defaultActionBlock: block;		yourself! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"May 18, 2008 -> 2:19:21"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

Delta define: #BlockWithoutArguments as: (
Generic forAll: '(R covar) ' body: ((Class subclassOf: 'Block' instanceVariables: '') protocols: '[^R]')) !


"May 18, 2008 -> 2:19:36"!

(Delta mirrorFor: #BlockWithoutArguments)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.   $Revision: 1.4 $
'!


"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self testOnDoShouldInvokeDoWhenExceptionSignalled;
		testOnDoShouldPopHandler;
		testOnDoShouldInvokeNestedHandler! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	[wasHandled] verify
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor selector defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	selector := BlockExceptionSelector handlesBlock: [:ex| true].
	[Exception signal]
		on: selector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked falseSelector outerInvoked|
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	innerInvoked := false.
	outerInvoked := false.
	[[[Exception signal]
		on: falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	[innerInvoked not] verify.
	[outerInvoked] verify]
		ensure: [Processor activeProcess resetHandlers]
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForEnsure: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ensure: b2! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
testForUnwind: b <[]> onUnwind: b2 <[]> ^<Object>

	[ ^b value ] ifCurtailed: b2! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
critical ^<R>
	"This is used for very short, fast critical regions where the overhead or inconvenience
	  of a semaphore is not desired.  The argument is evaluated without any process context
	  switches taking place, so that it can perform atomic operations.  WARNING: the blk MUST
	  NOT do anything that might cause the process to block, such as any kind of I/O.  This
	  method is only appropriate for very fast atomic operations that are extremely reliable, since
	  no other processes will get a chance to run while it is being evaluated, and if it crashes,
	  it will not be debuggable, since the development & debugger processes will not be able to run."

	"%todo: implement this right.  NOTE: an interesting semantic idea: we could dramatically improve
	  the usefulnes of this if it was a critical region on the receiver, not on the system as a whole."

	^self value! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ensure: f <[]> ^<R>

	"Use the following impl when vm bug fixed"
	"[ ^self value ] ifCurtailed: f"

	| result <R> |
	[ result := self value ] ifCurtailed: f.
	f value.
	^result! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
fork ^<Process>

	^self forkAt: Processor activePriority! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
forkAt: priority <Int> ^<Process>

	^self newProcess priority: priority; resume! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
ifCurtailed: protect <[]> ^<R>

	^guaranteed <R>
		  {{self primitiveUnwindProtect: protect
				ifFail: [ :err <Symbol> |	self shouldNotHappen ]
		  }}
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
newProcess ^<Process>

	^Process for: self! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 18, 2008 -> 2:19:36"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
profile

	Profiler do: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
repeat ^<BottomType>

	[ true ] whileTrue: [ self value ].
	self shouldNotHappen.! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
time ^<Int>

	^Time millisecondsToRun: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
userTime ^<Int>

	^Time userMillisecondsToRun: self! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
value ^<R>

    ^{{self primitiveValue}}! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
valueIfFail: fail <[^X def]>  ^<R | X>

	^self value! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed' ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
verify: message
	"Evaluate the receiver, and generate an error if it does not return true.  This is different than
	  Object>>#assert: in that 1) it is a boolean block message, and 2) it ALWAYS evaluates, whereas
	  #assert: does not guarantee that it will evaluate the predicate.

	  Use verify in situations where you must ensure that the test is performed, for example when there
	  are side-effects that must take place, or if it is testing code that should always be performed.

	  Note that this message is only valid for blocks that return boolean values."

	"Note: we don't use self as the receiver for #error: below because it will currently
		prevent the block from being optimized away by the inliner"
	self value
		ifFalse: [ BlockWithoutArguments[Object] error: 'Assertion failed: ', message ].

	"%hack %todo: remove this when compiler bug fixed"
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse ^<Object>

	^self whileFalse: []! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileFalse: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"
	(guaranteed <Boolean> (self value))
		ifFalse: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileFalse: [ blk value ]	].
	^nil! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue ^<Object>

	^self whileTrue: []! !

"May 18, 2008 -> 2:19:37"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'evaluating' !
whileTrue: blk <[]> ^<Object>

	"We can guarantee that self value is a Boolean in typesafe programs because the typechecker removes this
		  message from the protocol of blocks that don't return Booleans"


	(guaranteed <Boolean> (self value))
		ifTrue: [	blk value.
					[ (guaranteed <Boolean> (self value)) ]
						whileTrue: [ blk value ]	].

	^nil! !

"May 18, 2008 -> 2:23:36"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement! !

"May 18, 2008 -> 2:24:59"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement ifNew: ifNew
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^self].
	super include: anElement ifNew: ifNew! !

"May 18, 2008 -> 2:25:3"!

(Delta mirrorFor: #Set) removeMethod: #include: ifAbsent: [] !


"May 18, 2008 -> 2:25:5"!

(Delta mirrorFor: #Set) removeMethod: #add: ifAbsent: [] !


"May 18, 2008 -> 2:26:4"!

! (Delta mirrorFor: #Set) methodsFor: 'adding' !
include: anElement ifNew: ifNew
"workaround for problem with adding nil to a set"
self deltaHack.
	anElement isNil ifTrue: [^anElement].
	^super include: anElement ifNew: ifNew! !

"May 18, 2008 -> 2:36:12"!

"System saved" !
"May 18, 2008 -> 6:44:16"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:44:27"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:44:45"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:46:42"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:47:22"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"May 18, 2008 -> 6:48:43"!

! (Delta mirrorFor: #CommentReader) methodsFor: 'a new category' !
fileInFrom: stream <ReadStream>

	self mirror comment: stream nextChunk! !

"May 18, 2008 -> 6:49:56"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
comment:  aString

	(ClassMirror on: self) comment: aString! !

"May 18, 2008 -> 6:51:25"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
commentStamp: ignore prior: ignore2

	^(CommentReader for: (ClassMirror on: self))! !

"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitDelay as: (
(Class subclassOf: 'Delay' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #SUnitNameResolver as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

Delta define: #TestFailure as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

(Delta mirrorFor: #TestFailure)
comment: 
'Signaled in case of a failed test (failure). The test framework distinguishes between failures and errors. A failure is anticipated and checked for with assertions. Errors are unanticipated problems like a division by 0 or an index out of bounds ...'!


"May 18, 2008 -> 6:52:32"!

Delta define: #ResumableTestFailure as: (
(Class subclassOf: 'TestFailure' instanceVariables: '')) !


"May 18, 2008 -> 6:52:32"!

(Delta mirrorFor: #ResumableTestFailure)
comment: 
'A ResumableTestFailure triggers a TestFailure, but lets execution of the TestCase continue. this is useful when iterating through collections, and #assert: ing on each element. in combination with methods like testcase>>#assert:description:, this lets you run through a whole collection and note which tests pass.

here''''s an example:

	

	(1 to: 30) do: [ :each |
		self assert: each odd description: each printString, '' is even'' resumable: true]

for each element where #odd returns <false>, the element will be printed to the Transcript. '!


"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitAddDependent: anObject
 
        self addDependent: anObject! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitChanged: anAspect
 
        self changed: anAspect! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Object) methodsFor: 'Camp Smalltalk' !
sunitRemoveDependent: anObject
 
        self removeDependent: anObject! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
sunitAllSelectors 

        ^self allSelectors asSortedCollection asOrderedCollection! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
sunitSelectors
 
        ^self selectors asSortedCollection asOrderedCollection! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitEnsure: aBlock
 
        ^self ensure: aBlock! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'Camp Smalltalk' !
sunitOn: anException do: aHandlerBlock
 
        ^self on: anException do: aHandlerBlock! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
sunitName
 
        ^self name! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
classNamed: aSymbol

        ^Smalltalk
                at: aSymbol
                ifAbsent: [nil].! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
defaultLogDevice
	^ Transcript! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
errorObject
	^Error! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood new! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification new! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitAsSymbol
 
        ^self asSymbol! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitMatch: aString
 
        ^self match: aString! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #String) methodsFor: 'Camp Smalltalk' !
sunitSubStrings
 
        ^self substrings! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #Symbol) methodsFor: 'Camp Smalltalk' !
sunitAsClass
 
        ^SUnitNameResolver classNamed: self! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #TestFailure) methodsFor: 'Camp Smalltalk' !
defaultAction

self halt.
        "Debugger
                openContext: initialContext
                label: messageText
                contents: initialContext shortStack"! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #ResumableTestFailure) methodsFor: 'Camp Smalltalk' !
isResumable
	"Of course a ResumableTestFailure is resumable ;-)"

	^true! !

"May 18, 2008 -> 6:52:33"!

! (Delta mirrorFor: #ResumableTestFailure) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
	self resume: aValue! !

"May 18, 2008 -> 7:11:18"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector].
	^selectors! !

"May 18, 2008 -> 7:12:14"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
selectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector].
	^selectors! !

"May 18, 2008 -> 7:13:3"!

"System saved" !
"May 18, 2008 -> 7:17:42"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
superclassesDo: block

	|current|
	current := self superclass.
	[current = nil]
		whileFalse: [
			block value: current.
			current := current superclass]! !

"May 18, 2008 -> 7:18:25"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	self superclassesDo: [:class| selectors add: class selectors].
	^selectors! !

"May 18, 2008 -> 7:19:37"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
superclassesDo: block

	|current|
	current := self superclassIfAbsent: [^self].
	[current = nil]
		whileFalse: [
			block value: current.
			current := current superclassIfAbsent: [^self]]! !

"May 18, 2008 -> 7:19:55"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set new.
	self superclassesDo: [:class| selectors addAll: class selectors].
	^selectors! !

"May 18, 2008 -> 7:20:40"!

"System saved" !
"May 18, 2008 -> 7:28:15"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:28:15"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:28:15"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:28:15"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:28:15"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:28:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
runCount

	^self passedCount + self failureCount + self errorCount
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
tests

	^(OrderedCollection new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierachy: anObject]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTest: aTest
	self tests add: aTest
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTests: aCollection 
	aCollection do: [:eachTest | self addTest: eachTest]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
defaultResources
	^self tests 
		inject: Set new
		into: [:coll :testCase | 
			coll
				addAll: testCase resources;
				yourself]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name

	^name
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierachy: anObject]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources
	resources isNil ifTrue: [resources := self defaultResources].
	^resources
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources: anObject
	resources := anObject
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run
	| result |
 	result := TestResult new.
	self resources do: [ :res |
		res isAvailable ifFalse: [^res signalInitializationError]].
	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].
	^result
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		each run: aResult]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
tests
	tests isNil ifTrue: [tests := OrderedCollection new].
	^tests
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:28:16"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
currentDictionary

	CurrentDictionary isNil
		ifTrue: [CurrentDictionary := Dictionary new].

	^CurrentDictionary
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current|]
		ifAbsentPut: [self new].

			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	self currentDictionary
		at: self
		put: aTestResource
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestResource
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAvailable
	^self current notNil and: [self current isAvailable]
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isUnavailable

	^self isAvailable not
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
new

	^super new initialize
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current tearDown] ensure: [
		self current: nil]
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
resources
	^#()
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
signalInitializationError
	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
error
	^self exError
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
exError
	^SUnitNameResolver errorObject
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
failure
	^TestFailure
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Init / Release' !
new
	^super new initialize
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
resumableFailure
	^ResumableTestFailure
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalErrorWith: aString 
	self error sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalFailureWith: aString 
	self failure sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:28:17"!

! (Delta mirrorFor: #TestSuite) classSide methodsFor: 'Creation' !
named: aString

	^self new
		name: aString;
		yourself
			! !

"May 18, 2008 -> 7:32:49"!

! (Delta mirrorFor: #Class) methodsFor: 'file-in compatibility' !
subclass: clsName <Symbol>
instanceVariableNames: iVars <Str>
classVariableNames: cVars <Str>
poolDictionaries: pVars <Str>
category: cat <Str>
^<Class>

	| mirror <ClassMirror> |
	[ pVars isEmpty ] verify.
	mirror := Class subclassOf: self name instanceVariables: iVars.
	mirror classVariables: cVars.
	Delta define: clsName as: mirror.
	^mirror reflectee! !

"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:24"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:34:24"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:34:25"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:34:52"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:34:52"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:35:7"!

"System saved" !
"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestCase as: (
(Class subclassOf: 'Object' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 7:35:45"!

(Delta mirrorFor: #TestCase)
comment: 
'A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.

When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.

When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.'!


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResource as: (
(Class subclassOf: 'Object' instanceVariables: 'name description') classVariables: 'CurrentDictionary') !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

Delta define: #TestResult as: (
(Class subclassOf: 'Object' instanceVariables: 'failures errors passed')) !


"May 18, 2008 -> 7:35:45"!

(Delta mirrorFor: #TestResult)
comment: 
'This is a Collecting Parameter for the running of a bunch of tests. TestResult is an interesting object to subclass or substitute. #runCase: is the external protocol you need to reproduce. Kent has seen TestResults that recorded coverage information and that sent email when they were done.'!


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

Delta define: #TestSuite as: (
(Class subclassOf: 'Object' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 7:35:46"!

(Delta mirrorFor: #TestSuite)
comment: 
'This is a Composite of Tests, either TestCases or other TestSuites. The common protocol is #run: aTestResult and the dependencies protocol'!


"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean

	aBoolean ifFalse: [self signalFailure: 'Assertion failed']
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString
	aBoolean ifFalse: [
		self logFailure: aString.
		TestResult failure sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
assert: aBoolean description: aString resumable: resumableBoolean 
	| exception |
	aBoolean
		ifFalse: 
			[self logFailure: aString.
			exception := resumableBoolean
						ifTrue: [TestResult resumableFailure]
						ifFalse: [TestResult failure].
			exception sunitSignalWith: aString]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debug
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[(self class selector: testSelector) runCase] 
		sunitEnsure: [self resources do: [:each | each reset]]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
debugAsFailure
	| semaphore |
	semaphore := Semaphore new.
	self resources do: [:res | 
		res isAvailable ifFalse: [^res signalInitializationError]].
	[semaphore wait. self resources do: [:each | each reset]] fork.
	(self class selector: testSelector) runCaseAsFailure: semaphore.

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean

	self assert: aBoolean not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString
	self assert: aBoolean not description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
deny: aBoolean description: aString resumable: resumableBoolean 
	self
		assert: aBoolean not
		description: aString
		resumable: resumableBoolean
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
executeShould: aBlock inScopeOf: anExceptionalEvent 
	^[aBlock value.
 	false] sunitOn: anExceptionalEvent
		do: [:ex | ex sunitExitWith: true]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
failureLog	
	^SUnitNameResolver defaultLogDevice

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^false
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
logFailure: aString
	self isLogging ifTrue: [
		self failureLog 
			cr; 
			nextPutAll: aString; 
			flush]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
openDebuggerOnFailingTestMethod
	"SUnit has halted one step in front of the failing test method. Step over the 'self halt' and 
	 send into 'self perform: testSelector' to see the failure from the beginning"

	self
		halt;
		performTest
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
performTest

	self perform: testSelector sunitAsSymbol
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self class printString;
		nextPutAll: '>>#';
		nextPutAll: testSelector
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject 
	"an empty method. for Composite compability with TestSuite"


			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
resources
	| allResources resourceQueue |
	allResources := Set new.
	resourceQueue := OrderedCollection new.
	resourceQueue addAll: self class resources.
	[resourceQueue isEmpty] whileFalse: [
		| next |
		next := resourceQueue removeFirst.
		allResources add: next.
		resourceQueue addAll: next resources].
	^allResources
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run
	| result |
	result := TestResult new.
	self run: result.
	^result
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
run: aResult
	aResult runCase: self
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCase

	[self setUp.
	self performTest] sunitEnsure: [self tearDown]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
runCaseAsFailure: aSemaphore
	[self setUp.
	self openDebuggerOnFailingTestMethod] sunitEnsure: [
		self tearDown.
		aSemaphore signal]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
selector
	^testSelector
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Private' !
setTestSelector: aSymbol
	testSelector := aSymbol
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
setUp
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock
	self assert: aBlock value
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock description: aString
	self assert: aBlock value description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
should: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)
		description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock
	self deny: aBlock value
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock description: aString
	self deny: aBlock value description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
shouldnt: aBlock raise: anExceptionalEvent description: aString 
	^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not 		description: aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Accessing' !
signalFailure: aString
	TestResult failure sunitSignalWith: aString! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
tearDown
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description

	description isNil
		ifTrue: [^''].

	^description
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
description: aString

	description := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
initialize
	self setUp

			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isAvailable
	"override to provide information on the
	readiness of the resource"
	
	^true
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Testing' !
isUnavailable
	"override to provide information on the
	readiness of the resource"
	
	^self isAvailable not
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name

	name isNil
		ifTrue: [^self printString].

	^name
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Printing' !
printOn: aStream

	aStream nextPutAll: self class printString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Accessing' !
resources
	^self class resources
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
setUp
	"Does nothing. Subclasses should override this
	to initialize their resource"
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
signalInitializationError
	^self class signalInitializationError
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Running' !
tearDown
	"Does nothing. Subclasses should override this
	to tear down their resource"
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
correctCount
	"depreciated - use #passedCount"

	^self passedCount
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
defects
	^OrderedCollection new
		addAll: self errors;
		addAll: self failures; yourself
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errorCount

	^self errors size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
errors

	errors isNil
		ifTrue: [errors := OrderedCollection new].
	^errors
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failureCount

	^self failures size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
failures
	failures isNil
		ifTrue: [failures := Set new].
	^failures
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasErrors

	^self errors size > 0
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasFailures

	^self failures size > 0
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
hasPassed

	^self hasErrors not and: [self hasFailures not]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Init / Release' !
initialize
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isError: aTestCase

	^self errors includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isFailure: aTestCase
	^self failures includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Testing' !
isPassed: aTestCase

	^self passed includes: aTestCase
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passed

	passed isNil
		ifTrue: [passed := OrderedCollection new].

	^passed
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
passedCount

	^self passed size
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Printing' !
printOn: aStream

	aStream
		nextPutAll: self runCount printString;
		nextPutAll: ' run, ';
		nextPutAll: self correctCount printString;
		nextPutAll: ' passed, ';
		nextPutAll: self failureCount printString;
		nextPutAll: ' failed, ';
		nextPutAll: self errorCount printString;
		nextPutAll: ' error'.

	self errorCount ~= 1
		ifTrue: [aStream nextPut: $s]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
runCount

	^self passedCount + self failureCount + self errorCount
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Accessing' !
tests

	^(OrderedCollection new: self runCount)
		addAll: self passed;
		addAll: self errors;
		addAll: self failures;
		yourself
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
addDependentToHierachy: anObject
	self sunitAddDependent: anObject.
	self tests do: [ :each | each addDependentToHierachy: anObject]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTest: aTest
	self tests add: aTest
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
addTests: aCollection 
	aCollection do: [:eachTest | self addTest: eachTest]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
defaultResources
	^self tests 
		inject: Set new
		into: [:coll :testCase | 
			coll
				addAll: testCase resources;
				yourself]
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name

	^name
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
name: aString

	name := aString
			! !

"May 18, 2008 -> 7:35:46"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Dependencies' !
removeDependentFromHierachy: anObject
	self sunitRemoveDependent: anObject.
	self tests do: [ :each | each removeDependentFromHierachy: anObject]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources
	resources isNil ifTrue: [resources := self defaultResources].
	^resources
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
resources: anObject
	resources := anObject
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run
	| result |
 	result := TestResult new.
	self resources do: [ :res |
		res isAvailable ifFalse: [^res signalInitializationError]].
	[self run: result] sunitEnsure: [self resources do: [:each | each reset]].
	^result
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		each run: aResult]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Accessing' !
tests
	tests isNil ifTrue: [tests := OrderedCollection new].
	^tests
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuite
	| suite |
	^self isAbstract
		ifTrue: 
			[suite := self suiteClass named: self name asString.
			self allSubclasses 
				do: [:each | each isAbstract ifFalse: [suite addTest: each buildSuiteFromSelectors]].
			suite]
		ifFalse: [self buildSuiteFromSelectors]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromAllSelectors

	^self buildSuiteFromMethods: self allTestSelectors
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromLocalSelectors

	^self buildSuiteFromMethods: self testSelectors
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromMethods: testMethods

	^testMethods
		inject: (self suiteClass named: self name asString)
		into: [:suite :selector |
			suite
				addTest: (self selector: selector);
				yourself]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
buildSuiteFromSelectors

	^self shouldInheritSelectors
		ifTrue: [self buildSuiteFromAllSelectors]
		ifFalse: [self buildSuiteFromLocalSelectors]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
debug: aSymbol

	^(self selector: aSymbol) debug
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestCase subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestCase
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
resources

	^#()
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
run: aSymbol

	^(self selector: aSymbol) run
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
selector: aSymbol

	^self new setTestSelector: aSymbol
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Testing' !
shouldInheritSelectors
	"I should inherit from an Abstract superclass but not from a concrete one by default, unless I have no testSelectors in which case I must be expecting to inherit them from my superclass.  If a test case with selectors wants to inherit selectors from a concrete superclass, override this to true in that subclass."

	^self superclass isAbstract
		or: [self testSelectors isEmpty]

"$QA Ignore:Sends system method(superclass)$"
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
suite

	^self buildSuite
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Building Suites' !
suiteClass
	^TestSuite
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^self sunitSelectors select: [:each | 'test*' sunitMatch: each]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
sunitVersion
	^'3.1'
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
currentDictionary

	CurrentDictionary isNil
		ifTrue: [CurrentDictionary := Dictionary new].

	^CurrentDictionary
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current|]
		ifAbsentPut: [self new].

			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	self currentDictionary
		at: self
		put: aTestResource
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAbstract
	"Override to true if a TestResource subclass is Abstract and should not have
	TestCase instances built from it"

	^self sunitName = #TestResource
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isAvailable
	^self current notNil and: [self current isAvailable]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Testing' !
isUnavailable

	^self isAvailable not
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
new

	^super new initialize
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current tearDown] ensure: [
		self current: nil]
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
resources
	^#()
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
signalInitializationError
	^TestResult signalErrorWith: 'Resource ' , self name , ' could not be initialized'
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
error
	^self exError
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
exError
	^SUnitNameResolver errorObject
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
failure
	^TestFailure
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Init / Release' !
new
	^super new initialize
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
resumableFailure
	^ResumableTestFailure
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalErrorWith: aString 
	self error sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestResult) classSide methodsFor: 'Exceptions' !
signalFailureWith: aString 
	self failure sunitSignalWith: aString
			! !

"May 18, 2008 -> 7:35:47"!

! (Delta mirrorFor: #TestSuite) classSide methodsFor: 'Creation' !
named: aString

	^self new
		name: aString;
		yourself
			! !

"May 18, 2008 -> 7:36:43"!

"System saved" !
"May 18, 2008 -> 7:36:56"!

Delta define: #ExampleSetTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'full empty')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #ResumableTestFailureTestCase as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #SimpleTestResourceTestCase as: (
(Class subclassOf: 'TestCase' instanceVariables: 'resource')) !


"May 18, 2008 -> 7:36:56"!

Delta define: #SUnitTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'hasRun hasSetup hasRanOnce')) !


"May 18, 2008 -> 7:36:56"!

(Delta mirrorFor: #SUnitTest)
comment: 
'This is both an example of writing tests and a self test for the SUnit. The tests 
here are pretty strange, since you want to make sure things blow up. You should 
not generally have to write tests this complicated in structure, although they 
will be far more complicated in terms of your own objects- more assertions, more 
complicated setup. Kent says: "Never forget, however, that if the tests are hard 
to write, something is probably wrong with the design".'!


"May 18, 2008 -> 7:36:56"!

Delta define: #SimpleTestResource as: (
(Class subclassOf: 'TestResource' instanceVariables: 'runningState hasRun hasSetup hasRanOnce')) !


"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Running' !
setUp
	empty := Set new.
	full := Set with: 5 with: #abc
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testAdd
	empty add: 5.
	self assert: (empty includes: 5)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testGrow
	empty addAll: (1 to: 100).
	self assert: empty size = 100
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testIllegal
	self 
		should: [empty at: 5] 
		raise: TestResult error.
	self 
		should: [empty at: 5 put: #abc] 
		raise: TestResult error
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testIncludes
	self assert: (full includes: 5).
	self assert: (full includes: #abc)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testOccurrences
	self assert: (empty occurrencesOf: 0) = 0.
	self assert: (full occurrencesOf: 5) = 1.
	full add: 5.
	self assert: (full occurrencesOf: 5) = 1
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ExampleSetTest) methodsFor: 'Testing' !
testRemove
	full remove: 5.
	self assert: (full includes: #abc).
	self deny: (full includes: 5)
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
errorTest
	1 zork
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
failureLog
	^SUnitNameResolver defaultLogDevice
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
failureTest
	self
		assert: false description: 'You should see me' resumable: true; 
		assert: false description: 'You should see me too' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
isLogging
	^false
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
okTest
	self assert: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
regularTestFailureTest
	self assert: false description: 'You should see me'
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
resumableTestFailureTest
	self
		assert: false description: 'You should see me' resumable: true; 
		assert: false description: 'You should see me too' resumable: true; 
		assert: false description: 'You should see me last' resumable: false; 
		assert: false description: 'You should not see me' resumable: true
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #ResumableTestFailureTestCase) methodsFor: 'Not categorized' !
testResumable
	| result suite |
	suite := TestSuite new.
	suite addTest: (self class selector: #errorTest).
	suite addTest: (self class selector: #regularTestFailureTest).
	suite addTest: (self class selector: #resumableTestFailureTest).
	suite addTest: (self class selector: #okTest).
	result := suite run.
	self assert: result failures size = 2;
		assert: result errors size = 1
			! !

"May 18, 2008 -> 7:36:56"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
hasRun
	^hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
hasSetup
	^hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'testing' !
isAvailable
	
	^self runningState == self startedStateSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'accessing' !
runningState

	^runningState
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'accessing' !
runningState: aSymbol

	runningState := aSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
setRun
	hasRun := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
setUp
	
	self runningState: self startedStateSymbol.
	hasSetup := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
startedStateSymbol

	^#started
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
stoppedStateSymbol

	^#stopped
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResource) methodsFor: 'running' !
tearDown

	self runningState: self stoppedStateSymbol
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
dummy
	self assert: true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
error
	'foo' odd
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
fail
	self assert: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
setRun
	resource setRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
setUp
	resource := SimpleTestResource current
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testRan
	| case |

	case := self class selector: #setRun.
	case run.
	self assert: resource hasSetup.
	self assert: resource hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testResourceInitRelease
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	suite addTest: (self class selector: #dummy).
	result := suite run.
	self assert: resource hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) methodsFor: 'Not categorized' !
testResourcesCollection
	| collection |
	collection := self resources.
	self assert: collection size = 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
assertForTestResult: aResult runCount: aRunCount passed: aPassedCount failed: aFailureCount errors: anErrorCount

	self
		assert: aResult runCount = aRunCount;
		assert: aResult passedCount = aPassedCount;
		assert: aResult failureCount = aFailureCount;
		assert: aResult errorCount = anErrorCount
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
error
	3 zork
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
errorShouldntRaise
	self 
		shouldnt: [self someMessageThatIsntUnderstood] 
		raise: SUnitNameResolver notificationObject
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
fail
	self assert: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Accessing' !
hasRun
	^hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Accessing' !
hasSetup
	^hasSetup
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
noop
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Private' !
setRun
	hasRun := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Running' !
setUp
	hasSetup := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testAssert
	self assert: true.
	self deny: false
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testDefects
	| result suite error failure |
	suite := TestSuite new.
	suite addTest: (error := self class selector: #error).
	suite addTest: (failure := self class selector: #fail).
	result := suite run.
	self assert: result defects asArray = (Array with: error with: failure).
	self
		assertForTestResult: result
		runCount: 2
		passed: 0
		failed: 1
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testDialectLocalizedException

	self
		should: [TestResult signalFailureWith: 'Foo']
		raise: TestResult failure.
	self
		should: [TestResult signalErrorWith: 'Foo']
		raise: TestResult error.

			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testError

	| case result |

	case := self class selector: #error.
	result := case run.
	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1.

	case := self class selector: #errorShouldntRaise.
	result := case run.
	self 
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 0
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testException

	self
		should: [self error: 'foo']
		raise: TestResult error
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testFail

	| case result |

	case := self class selector: #fail.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 0
		failed: 1
		errors: 0
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testIsNotRerunOnDebug

	| case |

	case := self class selector: #testRanOnlyOnce.
	case run.
	case debug
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRan

	| case |

	case := self class selector: #setRun.
	case run.
	self assert: case hasSetup.
	self assert: case hasRun
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRanOnlyOnce

	self assert: hasRanOnce ~= true.
	hasRanOnce := true
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testResult

	| case result |

	case := self class selector: #noop.
	result := case run.

	self
		assertForTestResult: result
		runCount: 1
		passed: 1
		failed: 0
		errors: 0
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testRunning

	(SUnitDelay forSeconds: 2) wait
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testShould

	self
		should: [true];
		shouldnt: [false]
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SUnitTest) methodsFor: 'Testing' !
testSuite

	| suite result |

	suite := TestSuite new.
	suite 
		addTest: (self class selector: #noop);
		addTest: (self class selector: #fail);
		addTest: (self class selector: #error).

	result := suite run.

	self
		assertForTestResult: result
		runCount: 3
		passed: 1
		failed: 1
		errors: 1
			! !

"May 18, 2008 -> 7:36:57"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) classSide methodsFor: 'Not categorized' !
resources
	^Set new add: SimpleTestResource; yourself
			! !

"May 18, 2008 -> 7:37:18"!

"System saved" !
"May 18, 2008 -> 7:42:28"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
selectors

	|selectors|
	selectors := Set new.
	(ClassMirror on: self)
		methodsDo: [:method| selectors add: method selector asString].
	^selectors! !

"May 18, 2008 -> 7:43:55"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^self sunitAllSelectors select: [:each | 'test*' asString sunitMatch: each]
			! !

"May 18, 2008 -> 7:45:6"!

"System saved" !
"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestCase as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'testSelector')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:22:54"!

Delta define: #TestSuite as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: 'tests resources name')) !


"May 18, 2008 -> 14:23:20"!

"System saved" !
"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutHeaderOn: stream <WriteStream> ^ <Int>

	self fileOutDefinition: self mirror definitionString on: stream.
	self fileOutRevision: self mirror revision on: stream.
	self fileOutGroup: self mirror group on: stream.
	self fileOutComment: self mirror comment on: stream.
! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutOn: stream <WriteStream> ^ <Int>

	| pos <Int> |
	self assert: [ self mirror isMeta not ].
	pos := stream position.
	self fileOutHeaderOn: stream.
	(self class for: self mirror classSide) fileOutBodyOn: stream.
	self fileOutBodyOn: stream.
	^pos
! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutMethodsOn: stream <WriteStream> ^ <Int>

	(self class for: self mirror classSide) fileOutBodyOn: stream.
	self fileOutBodyOn: stream! !

"May 18, 2008 -> 19:15:28"!

! (Delta mirrorFor: #DefinitionWriter) methodsFor: 'Unclassified' !
fileOutOn: stream <WriteStream> ^ <Int>

	| pos <Int> |
	self assert: [ self mirror isMeta not ].
	pos := stream position.
	self fileOutHeaderOn: stream.
	self fileOutMethodsOn: stream.
	^pos
! !

"May 18, 2008 -> 19:41:37"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
testSelectors

	^(self sunitSelectors 
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]
			! !

"May 18, 2008 -> 19:42:10"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' asString sunitMatch: each])
		reject: [:each| each includes: $:]! !

"May 18, 2008 -> 19:44:51"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Accessing' !
allTestSelectors

	^(self sunitAllSelectors
		select: [:each | 'test*' sunitMatch: each])
		reject: [:each| each includes: $:]! !

"May 18, 2008 -> 19:46:20"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitMatch: aString
 
        ^self match: aString! !

"May 18, 2008 -> 19:46:20"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitSubStrings
 
        ^self substrings! !

"May 18, 2008 -> 19:59:43"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
allSubclasses

	^((ClassMirror on: self) subclasses
		collect: [:mirror| mirror reflectee])
		remove: self! !

"May 18, 2008 -> 20:0:5"!

! (Delta mirrorFor: #Class) methodsFor: 'Camp Smalltalk' !
allSubclasses

	^((ClassMirror on: self) subclasses
		collect: [:mirror| mirror reflectee])
		remove: self;
		yourself! !

"May 18, 2008 -> 20:13:18"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"May 18, 2008 -> 20:13:47"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	! !

"May 18, 2008 -> 20:14:4"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories')) !


"May 18, 2008 -> 20:14:48"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
initialize

	classes := OrderedCollection new.
	classCategories := Dictionary new! !

"May 18, 2008 -> 20:15:43"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class! !

"May 18, 2008 -> 20:15:52"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new! !

"May 18, 2008 -> 20:18:43"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class category: category

	(classes includes: class)
		ifTrue: [^self].
	classCategories
		at: class
		ifPresent: [:categories| categories add: category]
		ifAbsentPut: [Set with: category]! !

"May 18, 2008 -> 20:20:54"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutOn: stream

	self fileOutClassHeadersOn: stream.
	self fileOutClassMethodsOn: stream.
	self fileOutCategoriesOn: stream! !

"May 18, 2008 -> 20:21:49"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	classes do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 18, 2008 -> 20:22:19"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
definitionWriterFor: class

	^(DefinitionWriter for: (ClassMirror on: class))! !

"May 18, 2008 -> 20:23:32"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	classes do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"May 18, 2008 -> 20:24:28"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :category|
		(self definitionWriterFor: class)
			fileOutCategory: category on: stream]! !

"May 18, 2008 -> 20:26:59"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories remove: class! !

"May 18, 2008 -> 20:28:7"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: []! !

"May 18, 2008 -> 20:31:16"!

! (Delta mirrorFor: #FileOutSet) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"May 18, 2008 -> 20:43:39"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			Transcript show: class name, ' ', category.
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:44:8"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			Transcript show: (class name, ' ', category); cr.
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:45:17"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			definitionWriter fileOutCategory: category on: stream]]! !

"May 18, 2008 -> 20:51:49"!

"System saved" !
"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:20:22"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 19, 2008 -> 4:20:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Error)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #Notification)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:20:23"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test

	self testShouldHandleWhenHandleBlockReturnsTrue;
		testShouldPassExceptionToHandlesBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block

	handlesBlock := block ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandlerBlockWithException! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	^aBlock value: (handleBlock value: exception)! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test

	self testDefaultActionShouldInvokeDefaultActionBlock;
		testDefaultDefault;
		testHandlerShouldDelegateToHandlerBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	[wasInvoked] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	defaultBlock value! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [].
	handlerBlock := [:ignore|]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandleBlockWhenExceptionMatches;
		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;
		testShouldDelegateToNextHandlerWhenNoMatch;
		testHandlerShouldSetHandlerOnException;
		testPassShouldDeferToNextHandler;
		testReturnShouldEvaluateReturnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException

	|handler trueSelector exception assignedHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	[assignedHandler ~~ handler] verify.
	handler handle: exception.
	[assignedHandler == handler] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	[wasPassed] verify	! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	[result == #value] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled falseSelector exception nextHandler|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	nextHandler := (BlockExceptionHandler
				handleBlock: [:ex| [ex == exception] verify.
					handled := true]).
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		nextHandler: nextHandler;
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled falseSelector exception|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled trueSelector exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	(LinkedExceptionHandler
		on: trueSelector
		do: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]].
	result := protectee value.
	^[result]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	exception handler: self.
	^(exceptionSelector handles: exception)
		ifTrue: [aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"May 19, 2008 -> 4:20:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test

	self testSignalShouldInvokeProcessHandler;
		testPassShouldDeferToOuterHandler;
		testPassShouldNotReturn;
		testPassShouldInvokeDefaultActionWithoutReturning;
		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;
		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;
		testOuterTwiceShouldInvokeSurroundingHandlerTwice;
		testResumeShouldReturnAsValueOfOuter;
		testResumeShouldReturnFromSignal;
		testResumeWithValueShouldReturnFromSignal;
		testReturnShouldDelegateToHandler;
		testIsNestedShouldBeFalseWithNoHandler;
		testIsNestedShouldBeTrueWhenOuterHandlerHandles;
		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;
		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;
		testResignalAsShouldRestoreSignalEnvironment;
		testRetryShouldReevaluateProtectee;
		testRetryUsingShouldReplaceProtectee! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	[result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|result|
	[[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|]]
		on: Exception
		do: [:ex|].
	[result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	[wasPassed] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
			signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn

	[([[Exception signal]
		on: Exception
		do: [:ex| ex pass.
			self shouldNotHappen]]
		on: Exception
		do: [:ex| #result]) == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal

	|wasResumed|
	wasResumed := false.
	[Exception signal.
	wasResumed := true]
		on: Exception
		do: [:ex| ex resume].
	[wasResumed] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal

	|result|
	[result := Exception signal]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	[count == 2] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]
		on: Exception
		do: [:ex|
			log nextPutAll: 'handle '.
			count := count + 1.
			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
								Exception signal]]].
	[log contents = 'handle unwind using handle '] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	[result isNil] verify! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (BlockExceptionHandler
				handleBlock: [:ex| wasInvoked := true]).
	Exception signal.
	[[wasInvoked] verify]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldResume |
	self isResumable
		ifFalse: [self pass].
	[oldResume := resumeBlock.
	resumeBlock := [:value| ^value].
	(oldHandler := handler) outer: self return: [:value| ^value]]
		ensure: [handler := oldHandler.
			resumeBlock := oldResume]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	passBlock value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	resignalBlock value: replacementException! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal
"Ask ContextHandlers in the sender chain to handle this signal.
The default is to execute and return my defaultAction."
	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	Processor activeProcess handle: self.
	^[]! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 19, 2008 -> 4:20:24"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Error)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #Notification)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"May 19, 2008 -> 4:23:13"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
test

	self testShouldHandleWhenHandleBlockReturnsTrue;
		testShouldPassExceptionToHandlesBlock! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'test' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'initialization' !
handlesBlock: block

	handlesBlock := block ! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"May 19, 2008 -> 4:23:13"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandlerBlockWithException! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	^aBlock value: (handleBlock value: exception)! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
test

	self testDefaultActionShouldInvokeDefaultActionBlock;
		testDefaultDefault;
		testHandlerShouldDelegateToHandlerBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	[wasInvoked] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'test' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	defaultBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [].
	handlerBlock := [:ignore|]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
test

	self testShouldInvokeHandleBlockWhenExceptionMatches;
		testShouldInvokeExceptionsDefaultActionWhenNoNextHandler;
		testShouldDelegateToNextHandlerWhenNoMatch;
		testHandlerShouldSetHandlerOnException;
		testPassShouldDeferToNextHandler;
		testReturnShouldEvaluateReturnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testHandlerShouldSetHandlerOnException

	|handler trueSelector exception assignedHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	[assignedHandler ~~ handler] verify.
	handler handle: exception.
	[assignedHandler == handler] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler on: trueSelector do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	[wasPassed] verify	! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	[result == #value] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled falseSelector exception nextHandler|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	nextHandler := (BlockExceptionHandler
				handleBlock: [:ex| [ex == exception] verify.
					handled := true]).
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		nextHandler: nextHandler;
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled falseSelector exception|
	handled := false.
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler on: falseSelector do: [:ex| self shouldNotHappen])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'tests' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled trueSelector exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	trueSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	(LinkedExceptionHandler
		on: trueSelector
		do: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]].
	result := protectee value.
	^[result]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	exception handler: self.
	^(exceptionSelector handles: exception)
		ifTrue: [aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler handleBlock: [:ex| ex defaultAction] ! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
test

	self testSignalShouldInvokeProcessHandler;
		testPassShouldDeferToOuterHandler;
		testPassShouldNotReturn;
		testPassShouldInvokeDefaultActionWithoutReturning;
		testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable;
		testOuterShouldInvokeAndReturnDefaultActionWhenResumable;
		testOuterTwiceShouldInvokeSurroundingHandlerTwice;
		testResumeShouldReturnAsValueOfOuter;
		testResumeShouldReturnFromSignal;
		testResumeWithValueShouldReturnFromSignal;
		testReturnShouldDelegateToHandler;
		testIsNestedShouldBeFalseWithNoHandler;
		testIsNestedShouldBeTrueWhenOuterHandlerHandles;
		testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle;
		testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles;
		testResignalAsShouldRestoreSignalEnvironment;
		testRetryShouldReevaluateProtectee;
		testRetryUsingShouldReplaceProtectee! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	[result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|result|
	[[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|]]
		on: Exception
		do: [:ex|].
	[result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	[wasPassed] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
			signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testPassShouldNotReturn

	[([[Exception signal]
		on: Exception
		do: [:ex| ex pass.
			self shouldNotHappen]]
		on: Exception
		do: [:ex| #result]) == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeShouldReturnFromSignal

	|wasResumed|
	wasResumed := false.
	[Exception signal.
	wasResumed := true]
		on: Exception
		do: [:ex| ex resume].
	[wasResumed] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testResumeWithValueShouldReturnFromSignal

	|result|
	[result := Exception signal]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	[count == 2] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal] ensure: [log nextPutAll: 'unwind ']]
		on: Exception
		do: [:ex|
			log nextPutAll: 'handle '.
			count := count + 1.
			count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
								Exception signal]]].
	[log contents = 'handle unwind using handle '] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	[result isNil] verify! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (BlockExceptionHandler
				handleBlock: [:ex| wasInvoked := true]).
	Exception signal.
	[[wasInvoked] verify]
		ensure: [Processor activeProcess popHandler]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldResume |
	self isResumable
		ifFalse: [self pass].
	[oldResume := resumeBlock.
	resumeBlock := [:value| ^value].
	(oldHandler := handler) outer: self return: [:value| ^value]]
		ensure: [handler := oldHandler.
			resumeBlock := oldResume]! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	passBlock value! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	resignalBlock value: replacementException! !

"May 19, 2008 -> 4:23:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal
"Ask ContextHandlers in the sender chain to handle this signal.
The default is to execute and return my defaultAction."
	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	Processor activeProcess handle: self.
	^[]! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler handleBlock: [:ex| ex defaultAction]].
	^handlerChain! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"May 19, 2008 -> 4:23:15"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"May 19, 2008 -> 4:23:45"!

"System saved" !
"May 19, 2008 -> 18:11:13"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	"self requestCloseIfTopWindow."
	topWindow := self visual topWindow
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:12:17"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	"self requestCloseIfTopWindow."
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:12:49"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'control' !
continueProcess

	|topWindow|
	self process resume.
	self process: nil.		"Don't terminate process when window closes"
	topWindow := self visual topWindow.
	topWindow isNil
		ifFalse: [topWindow requestClose]! !

"May 19, 2008 -> 18:13:47"!

"System saved" !
"May 24, 2008 -> 9:11:48"!

! (Delta mirrorFor: #Behavior) methodsFor: 'Camp Smalltalk' !
allSelectors

	|selectors|
	selectors := Set withAll: self selectors.
	self superclassesDo: [:class| selectors addAll: class selectors].
	^selectors! !

"May 24, 2008 -> 9:12:3"!

"System saved" !
"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #SimpleTestResourceTestCase) classSide methodsFor: 'Not categorized' !
resources
	^Set new add: SimpleTestResource current; yourself
			! !

"May 24, 2008 -> 10:13:37"!

! (Delta mirrorFor: #ReadString) methodsFor: 'Camp Smalltalk' !
sunitAsSymbol
 
        ^self asSymbol! !

"May 24, 2008 -> 10:13:57"!

"System saved" !
"May 24, 2008 -> 10:20:55"!

! (Delta mirrorFor: #TestResource) methodsFor: 'Init / Release' !
reset

	self class reset! !

"May 24, 2008 -> 10:24:14"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	current isNil
		ifFalse: [[current tearDown] ensure: [
					self current: nil]]
			! !

"May 24, 2008 -> 10:24:59"!

"System saved" !
"May 24, 2008 -> 10:48:18"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: messageText)! !

"May 24, 2008 -> 10:49:34"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"May 24, 2008 -> 10:49:46"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"May 24, 2008 -> 10:50:12"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"May 24, 2008 -> 10:50:19"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"May 24, 2008 -> 10:50:58"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>

	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal
! !

"May 24, 2008 -> 10:55:41"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 10:57:43"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current halt]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:3:57"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current: aTestResource

	aTestResource isNil
		ifTrue: [self currentDictionary removeKey: self]
		ifFalse: [self currentDictionary
							at: self
							put: aTestResource]			! !

"May 24, 2008 -> 11:4:40"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:5:21"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current halt]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:5:38"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Accessing' !
current

	^self currentDictionary
		at: self
		ifPresent: [:current| ^current]
		ifAbsentPut: [self new].

			! !

"May 24, 2008 -> 11:8:57"!

"System saved" !
"May 24, 2008 -> 13:9:39"!

! (Delta mirrorFor: #TestResource) classSide methodsFor: 'Creation' !
reset
	|current|
	current := self currentDictionary
		at: self
		ifAbsent: [^nil].
	[current isNil
		ifFalse: [current tearDown]] ensure: [
					self current: nil]
			! !

"May 24, 2008 -> 13:9:39"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>

	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	self halt.
	(MessageNotUnderstood message: m) signal! !

"May 24, 2008 -> 13:16:22"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handles: anException
"should this really be here? - required for SUnit"
	^self class handles: anException! !

"May 24, 2008 -> 13:19:29"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"May 24, 2008 -> 13:55:35"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification" new"! !

"May 24, 2008 -> 13:55:54"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood "new"! !

"May 24, 2008 -> 13:56:20"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
notificationObject
	^Notification! !

"May 24, 2008 -> 13:56:21"!

! (Delta mirrorFor: #SUnitNameResolver) classSide methodsFor: 'Camp Smalltalk' !
mnuExceptionObject
	^MessageNotUnderstood! !

"May 24, 2008 -> 13:58:2"!

(Delta mirrorFor: #Exception) removeMethod: #handles: ifAbsent: [] !


"May 24, 2008 -> 14:1:16"!

"System saved" !
"May 24, 2008 -> 14:1:53"!

Delta define: #BecomeTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 24, 2008 -> 14:4:25"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecome

	|first second source target|
	first := Array with: 1.
	second := Array with: 2.
	source := first copy.
	target := second copy.
	
	source become: target.
	self assert: (source = second).
	self assert: (target = first)! !

"May 24, 2008 -> 14:5:53"!

! (Delta mirrorFor: #Object) methodsFor: 'private-reflective' !
become: otherObject <BottomType>
	"Replace all references to the receiver anywhere in this image with references to otherObject, instead.

	This is a very dangerous message that should only be used if you really know what you are doing. Note that ALL
	references are changed, including 'self' in any currently active method contexts for the receiver,
	which means that instance variables could be accessed incorrectly, etc.  Note that this also means that the receiver
	becomes COMPLETELY inaccessible.
	 Also, this is not typesafe, and the type of the argument has been chosen to force typed code to insert an 
	 explicit guarantee, to avoid 'accidental' type-safety holes.  "

	"self unimplemented"
	{{ self primitiveBecome: otherObject ifFail: [:error| self error: error] }}! !

"May 24, 2008 -> 14:6:45"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecome

	|first second source target|
	first := Array with: 1.
	second := Array with: 2.
	source := first copy.
	target := second copy.
	
	self assert: (source = first).
	self assert: (target = second).
	source become: target.
	self assert: (source = second).
	self assert: (target = first)! !

"May 24, 2008 -> 14:7:44"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecomeShouldReportErrorWhenReceiverIsSmallInteger! !

"May 24, 2008 -> 14:8:34"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'initialize/release' !
setUp

	super setUp! !

"May 24, 2008 -> 14:10:49"!

(Delta mirrorFor: #BecomeTest) removeMethod: #setUp ifAbsent: [] !


"May 24, 2008 -> 14:14:6"!

! (Delta mirrorFor: #BecomeTest) methodsFor: 'testing' !
testBecomeShouldReportErrorWhenReceiverIsSmallInteger

	[1 become: ''.
	TestFailure signal]
		on: Error
		do: [:error| self assert: ('FirstArgumentHasWrongType' = error messageText)]
! !

"May 24, 2008 -> 14:22:54"!

"System saved" !
"May 29, 2008 -> 22:46:34"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"May 29, 2008 -> 22:46:34"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: []! !

"May 29, 2008 -> 22:47:41"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. When adding method categories, you must add those
for class and instance side separately. When adding whole classes, just add
the instance side. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"May 29, 2008 -> 22:59:11"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
superclassesFor: aClass

	|superclasses|
	superclasses := Set new.
	aClass superclassesDo: [:class| superclasses add: class].
	^superclasses! !

"May 29, 2008 -> 23:24:57"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			(self superclassesFor: class1) includes: class2]! !

"May 29, 2008 -> 23:25:22"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 29, 2008 -> 23:45:29"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			(self superclassesFor: class2) includes: class1]! !

"May 29, 2008 -> 23:48:56"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: [:class1 :class2|
			((self superclassesFor: class1) includes: class2) not]! !

"May 29, 2008 -> 23:50:17"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"May 29, 2008 -> 23:58:30"!

Delta define: #BlockExceptionDesciptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 29, 2008 -> 23:59:51"!

! (Delta mirrorFor: #BlockExceptionDesciptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:3:21"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:3:42"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:5:41"!

(Delta mirrorFor: #BlockExceptionDesciptorTest) removeDefinitionIfFail: [] !


"May 30, 2008 -> 0:6:53"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	|exception wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 30, 2008 -> 0:7:48"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp! !

"May 30, 2008 -> 0:8:5"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"May 30, 2008 -> 0:8:14"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	exception defaultAction! !

"May 30, 2008 -> 0:8:25"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"May 30, 2008 -> 0:8:52"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"May 30, 2008 -> 0:9:0"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	exception defaultAction! !

"May 30, 2008 -> 0:9:46"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"May 30, 2008 -> 0:11:13"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|]! !

"May 30, 2008 -> 0:11:34"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"May 30, 2008 -> 0:12:36"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|descriptor actualHandler|
	descriptor := BlockExceptionDescriptor new.
	descriptor handlerBlock: [:handler| actualHandler := handler].
	descriptor handler: #handler.
	[actualHandler == #handler] verify! !

"May 30, 2008 -> 0:14:3"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"May 30, 2008 -> 0:14:56"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testHandlerShouldDelegateToHandlerBlock ifAbsent: [] !


"May 30, 2008 -> 0:14:58"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testDefaultDefault ifAbsent: [] !


"May 30, 2008 -> 0:14:59"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #testDefaultActionShouldInvokeDefaultActionBlock ifAbsent: [] !


"May 30, 2008 -> 0:15:1"!

(Delta mirrorFor: #BlockExceptionDescriptor) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:17:9"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:17:29"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| [ex == exception] verify.
			handled := true])
		handle: exception.
	[handled] verify! !

"May 30, 2008 -> 0:18:57"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"May 30, 2008 -> 0:22:9"!

(Delta mirrorFor: #BlockExceptionHandler) classSide removeMethod: #testShouldInvokeHandlerBlockWithException ifAbsent: [] !


"May 30, 2008 -> 0:22:11"!

(Delta mirrorFor: #BlockExceptionHandler) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:22:39"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:23:8"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	[selector handles: nil] verify.
	canHandle := false.
	[(selector handles: nil) not] verify! !

"May 30, 2008 -> 0:23:59"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self assert: (selector handles: nil) not! !

"May 30, 2008 -> 0:24:53"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"May 30, 2008 -> 0:25:36"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| [ex == exception] verify].
	selector handles: exception! !

"May 30, 2008 -> 0:26:2"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception)].
	selector handles: exception! !

"May 30, 2008 -> 0:26:11"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	selector handles: exception! !

"May 30, 2008 -> 0:26:25"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"May 30, 2008 -> 0:27:3"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #testShouldPassExceptionToHandlesBlock ifAbsent: [] !


"May 30, 2008 -> 0:27:6"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #testShouldHandleWhenHandleBlockReturnsTrue ifAbsent: [] !


"May 30, 2008 -> 0:27:9"!

(Delta mirrorFor: #BlockExceptionSelector) classSide removeMethod: #test ifAbsent: [] !


"May 30, 2008 -> 0:28:57"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"May 30, 2008 -> 0:29:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex isNested]]
		on: TestException
		do: [:ex|].
	[result not] verify! !

"May 30, 2008 -> 0:32:11"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:32:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:32:58"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle ifAbsent: [] !


"May 30, 2008 -> 0:33:16"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	[exception isNested not] verify! !

"May 30, 2008 -> 0:33:33"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"May 30, 2008 -> 0:33:44"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeFalseWithNoHandler ifAbsent: [] !


"May 30, 2008 -> 0:35:16"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"May 30, 2008 -> 0:35:26"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeTrueWhenOuterHandlerHandles ifAbsent: [] !


"May 30, 2008 -> 0:36:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"May 30, 2008 -> 0:37:6"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles ifAbsent: [] !


"May 30, 2008 -> 0:37:19"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| outer := ex outer.
			result := #returned].
	[result == #returned] verify.
	[outer == #result] verify.! !

"May 30, 2008 -> 0:41:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex| self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned! !

"May 30, 2008 -> 0:41:58"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned! !

"May 30, 2008 -> 0:42:28"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterShouldInvokeAndReturnDefaultActionWhenResumable ifAbsent: [] !


"May 30, 2008 -> 0:42:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self shouldNotHappen]) == #result] verify! !

"May 30, 2008 -> 0:43:35"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	[([|result|
	result := (TestException defaultActionBlock: [#result])
		signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex outer.
			self signalFailure: 'outer should not return']) == #result] verify! !

"May 30, 2008 -> 0:53:13"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [#defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 30, 2008 -> 1:13:13"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]! !

"May 30, 2008 -> 1:22:10"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"May 30, 2008 -> 1:38:49"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"May 30, 2008 -> 1:39:10"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	definitions add: class! !

"May 30, 2008 -> 1:39:28"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private - initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new.
	definitions := Set new! !

"May 30, 2008 -> 1:39:55"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	(classes includes: class) ifTrue: [^self].
	definitions add: class! !

"May 30, 2008 -> 1:40:30"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class ifAbsent: []! !

"May 30, 2008 -> 1:41:33"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class
		ifAbsent: []! !

"May 30, 2008 -> 1:52:49"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	|allDefinitions|
	(allDefinitions := Set new)
		addAll: classes;
		addAll: definitions.
	^allDefinitions asSortedCollection: [:class1 :class2|
			((self superclassesFor: class1) includes: class2) not]! !

"May 30, 2008 -> 1:53:21"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionSortBlock

	^[:class1 :class2| ((self superclassesFor: class1) includes: class2) not]! !

"May 30, 2008 -> 1:53:45"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	|allDefinitions|
	(allDefinitions := Set new)
		addAll: classes;
		addAll: definitions.
	^allDefinitions asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 1:53:53"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 1:54:52"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
allDefinitions

	^Set new
		addAll: classes;
		addAll: definitions;
		yourself! !

"May 30, 2008 -> 1:55:18"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	^self allDefinitions asSortedCollection: self definitionSortBlock! !

"May 30, 2008 -> 2:0:10"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self definitionsForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"May 30, 2008 -> 2:11:26"!

"System saved" !
"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldDeferToOuterHandler ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldNotReturn ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:40"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:40"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:41"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:41"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:42"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:42"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:43"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:44"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:45"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:46"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:46"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:47"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:47"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:48"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:48"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:49"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:49"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:50"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: ["self halt." #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	"|exception result|
	exception := TestException defaultActionBlock: [self halt. #defaultResult].
	
	result := [self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult"! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass]]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[Exception signal]
		on: Exception
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: Exception
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	
	
	result := [exception := TestException defaultActionBlock: ["self halt." #defaultResult].
					self assert: #defaultResult == exception signal.
					#protecteeResult]
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result == #protecteeResult! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable

	|exception result|
	result := [exception := TestException defaultActionBlock: [#defaultResult].
					exception signal.
					self signalFailure: 'signal should not return']
						on: TestException
						do: [:ex| ex outer.
								self signalFailure: 'outer should not return'].
	self assert: result isNil! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaulActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler defaultActionBlock.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultActionBlockShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		pushHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultActionBlockShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReturnFromSignal

	|result|
	Processor activeProcess
		defaultHandler: BlockExceptionHandler default.
	result := (TestException defaultActionBlock: [#result]) signal.
	self assert: #result == result! !

"May 31, 2008 -> 12:21:51"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #testDefaultHandlerShouldReturnFromSignal ifAbsent: [] !


"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| ex returnWith: ex defaultAction]! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Running' !
isLogging
	"By default, we're not logging failures. If you override this in 
	a subclass, make sure that you override #failureLog"
	^true
			! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self logFailure: (signal printString).
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:21:51"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								[self logFailure: (signal printString)]
									suniton: Exception
									do: [].
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:22:26"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:43:54"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"May 31, 2008 -> 12:51:15"!

"System saved" !
"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText tag handler resumeBlock passBlock resignalBlock')) !


"June 1, 2008 -> 2:45:39"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[self installContextAndDo: action]].
	result := aBlock value.
	^[result]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result]
		on: TestException
		do: [:ex| ex resume: #resume]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	resumeBlock := [:result| ^[result]].
	passBlock := [^[handler pass: self]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						aTestCase printOn: Transcript.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[
			[
				aTestCase runCase.
				true]
					sunitOn: self class failure
					do: [:signal |
						aTestCase printOn: (Transcript cr; yourself).
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
								signal class printOn: Transcript.
								self errors add: aTestCase.
								signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString]
		on: TestException
		do: [:ex| ex resume: #resume]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	(contextBlock value: [resumptionValue]) value! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

"	|wasResumed|
	wasResumed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed"! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| self assert: ex outer = 'result'.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	self installContextAndDo: [	(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^self installContextAndDo: [	(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	passBlock := [^[handler pass: self]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resumeBlock
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new
			signal]
		on: TestException
		do: [:ex| ex pass.
			self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:40"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
			self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	resignalBlock := [:ex| ^[ex signal]].
	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
passBlock
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	[([|result|
	result := (TestException defaultActionBlock: [#result])
					resumable: true;
					signal.
	[result == #result] verify.
	result]
		on: TestException
		do: [:ex| ex pass.
			self shouldNotHappen]) == #result] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: [#result])
						resumable: true;
						signal.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| |result|
										result :=  ex defaultAction.
										ex isResumable ifFalse: [self halt].
										ex resume: result]! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testPassShouldInvokeDefaultActionWithoutReturning ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
			ex outer]]
		on: TestException
		do: [:ex| count := count + 1].
	[count == 2] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[(TestException defaultActionBlock: [-1])
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterTwiceShouldInvokeSurroundingHandlerTwice ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
		on: Exception
		do: [:ex| ex resume: #result].
	[result == #result] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeShouldReturnAsValueOfOuter ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu|
				Transcript cr; show: mnu message printString.
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume]
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu| | message |
				message := mnu message.
				Transcript cr;
					show: (message receiver printString);
					cr; show: (message selector).
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	[|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal']
		on: MessageNotUnderstood
		do: [:mnu| | message |
				message := mnu message.
				Transcript cr;
					show: (message receiver printString);
					cr; show: (message selector).
				mnu pass]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeShouldReturnFromSignal ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResumeWithValueShouldReturnFromSignal ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
		on: Exception
		do: [:ex| [log nextPutAll: 'signal '.
			ex resignalAs: TestException new]
				ifCurtailed: [log nextPutAll: 'curtail ']].
	[log contents = 'signal curtail resignal'] verify! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
					ex resignalAs: TestException new]
						ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 1, 2008 -> 2:45:41"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testResignalAsShouldRestoreSignalEnvironment ifAbsent: [] !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
resignalBlock
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please do!!"
	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]! !

"June 1, 2008 -> 2:45:41"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please use it!!"
	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]! !

"June 1, 2008 -> 2:46:32"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable
" This is nasty (in that it replaces the stopHandler temporarily). Not safe to do in a
  multi-processing environment!! If you can think of something better, please use it!!"
"	| error oldStopHandler completed |
	
	completed := Semaphore new.
	oldStopHandler := Processor stopHandler.
	[Processor stopHandler: [:process| error := process processError msg.
													completed signal].
	[[(TestException defaultActionBlock: [#defaultResult])  signal.
	self shouldNotHappen]
		on: TestException
		do: [:ex| ex outer.
				self shouldNotHappen].
	error := 'handler returned'.
	completed signal] fork,
	completed wait.
	self assert: 'Default action should not return' = error description: error printString]
		ensure: [Processor stopHandler: oldStopHandler]"! !

"June 1, 2008 -> 3:2:37"!

"System saved" !
"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| |result|
										result :=  ex defaultAction.
										ex isResumable ifFalse: [self defaultActionReturnError].
										ex resume: result]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #ExceptionTest) removeMethod: #testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase printOn: (Transcript cr; yourself).
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												signal class printOn: Transcript.
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testOuterShouldInvokeDefaultActionWithoutReturningWhenNonResumable ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testRetryShouldReevaluateProtectee ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testRetryUsingShouldReplaceProtectee ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testReturnShouldDelegateToHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #testSignalShouldInvokeProcessHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #Exception) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testHandlerShouldSetHandlerOnException ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testPassShouldDeferToNextHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testReturnShouldEvaluateReturnBlock ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldDelegateToNextHandlerWhenNoMatch ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldInvokeExceptionsDefaultActionWhenNoNextHandler ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue! !

"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #testShouldInvokeHandleBlockWhenExceptionMatches ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

(Delta mirrorFor: #LinkedExceptionHandler) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 18:29:2"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 18:29:2"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	"resume"! !

"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:2"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock handlerBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 1, 2008 -> 18:29:3"!

(Delta mirrorFor: #Process) classSide removeMethod: #testHandleShouldInvokeDefaultAction ifAbsent: [] !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 1, 2008 -> 18:29:3"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch ifAbsent: [] !


"June 1, 2008 -> 18:29:3"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									descriptor: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]
! !

"June 1, 2008 -> 18:29:49"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]
! !

"June 1, 2008 -> 18:53:25"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch ifAbsent: [] !


"June 1, 2008 -> 18:53:46"!

"System saved" !
"June 1, 2008 -> 19:10:46"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 1, 2008 -> 19:11:27"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process exceptionSelector wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exceptionSelector := BlockExceptionSelector handlesBlock: [:ex| true].
	[process pushHandler: (LinkedExceptionHandler
							on: exceptionSelector
							do: [:ex| wasInvoked := true]).
	process handle: exception.
	[wasInvoked] verify]
		ensure: [process popHandler]! !

"June 1, 2008 -> 19:13:17"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception.
	self assert: wasInvoked description: 'Handler should be invoked']
		ensure: [process popHandler]! !

"June 1, 2008 -> 19:14:50"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 1, 2008 -> 19:14:59"!

(Delta mirrorFor: #Process) classSide removeMethod: #testPushHandlerShouldReplaceDefaultHandler ifAbsent: [] !


"June 1, 2008 -> 19:15:1"!

(Delta mirrorFor: #Process) classSide removeMethod: #test ifAbsent: [] !


"June 1, 2008 -> 19:15:17"!

"System saved" !
"June 1, 2008 -> 20:0:30"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 1, 2008 -> 20:1:17"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	[wasHandled] verify
! !

"June 1, 2008 -> 20:1:53"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'
! !

"June 1, 2008 -> 20:5:40"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldInvokeDoWhenExceptionSignalled ifAbsent: [] !


"June 1, 2008 -> 20:5:47"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self 
		testOnDoShouldPopHandler;
		testOnDoShouldInvokeNestedHandler! !

"June 1, 2008 -> 20:5:57"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 1, 2008 -> 20:6:3"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked falseSelector outerInvoked|
	falseSelector := BlockExceptionSelector handlesBlock: [:ex| false].
	innerInvoked := false.
	outerInvoked := false.
	[[[Exception signal]
		on: falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	[innerInvoked not] verify.
	[outerInvoked] verify]
		ensure: [Processor activeProcess resetHandlers]! !

"June 1, 2008 -> 20:8:12"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 1, 2008 -> 20:8:21"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldInvokeNestedHandler ifAbsent: [] !


"June 1, 2008 -> 20:8:32"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].
	self 
		testOnDoShouldPopHandler! !

"June 1, 2008 -> 20:8:46"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor selector defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	selector := BlockExceptionSelector handlesBlock: [:ex| true].
	[Exception signal]
		on: selector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	! !

"June 1, 2008 -> 20:9:35"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	Processor activeProcess resetHandlers.
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	[handlerInvoked not] verify.
	[defaultInvoked] verify	! !

"June 1, 2008 -> 20:12:59"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor defaultActionBlock: [defaultInvoked := true].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	Processor activeProcess handle: descriptor.
	self deny: handlerInvoked
			description: 'Handler should have been popped'.
	self assert: defaultInvoked
			description: 'Default action should have been invoked'! !

"June 1, 2008 -> 20:21:34"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 1, 2008 -> 20:24:1"!

(Delta mirrorFor: #BlockWithoutArguments) classSide removeMethod: #testOnDoShouldPopHandler ifAbsent: [] !


"June 1, 2008 -> 20:24:10"!

! (Delta mirrorFor: #BlockWithoutArguments) classSide methodsFor: 'testing' !
test

	| v <Boolean> |
	
	[ v := false ] ensure: [ v := true ].
	self assert: [ v ].

	[ v := false ] ifCurtailed: [ v := true ].
	self assert: [ v not ].

	self testForUnwind: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ].

	self testForEnsure: [ v := false ] onUnwind: [ v := true ].
	self assert: [ v ]! !

"June 1, 2008 -> 20:24:41"!

"System saved" !
"June 1, 2008 -> 20:45:57"!

"System saved" !
"June 2, 2008 -> 3:49:54"!

! (Delta mirrorFor: #TestCase) classSide methodsFor: 'Instance Creation' !
runAll

	[self suite run printOn: (Transcript cr; yourself)] fork! !

"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #ProcessExceptionHandlingTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #LinkedExceptionHandlerTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #ExceptionTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #MessageNotUnderstoodTest)
comment: 
''!


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 2, 2008 -> 3:50:54"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"June 2, 2008 -> 3:50:54"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #ErrorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionSelectorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionHandlerTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'TestCase' instanceVariables: 'exception')) !


"June 2, 2008 -> 3:50:55"!

(Delta mirrorFor: #BlockExceptionDescriptorTest)
comment: 
''!


"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironment

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[original signal]
		on: Error
		do: [:ex| wasHandled := true].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 2, 2008 -> 3:50:55"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'restricted - exception handling' !
inContextDo: aBlock

	^aBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'private - initialization' !
handlesBlock: block

	handlesBlock := block ! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testShouldUnwindExceptionHandlersWhenHandlingException

	| wasInvoked |
	wasInvoked := false.
	[[[Notification signal]
			on: Error
			do: [:ex| self signalFailure: 'Should be caught by outer handler']]
				on: Notification
				do: [:ex| self error: 'Provoke outer handler']]
					on: Error
					do: [:ex| wasInvoked:= true].
	self assert: wasInvoked description: 'Outer handler should be invoked'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	"%todo - after signalling environment restoration test for exception"
	self halt.! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testErrorShouldSignalError

	| wasSignalled |
	wasSignalled := true.
	[self error: 'error message'.
	self signalFailure: 'should not return']
		on: Error
		do: [:ex| wasSignalled := true.
				self assert: 'error message' = ex messageText
						description: ex messageText printString].
	self assert: wasSignalled
			description: 'Error should be signalled'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testShouldNotBeResumable

	self deny: Error new isResumable! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testShouldBeResumable

	self assert: MessageNotUnderstood new isResumable! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block

	^self new
			defaultActionBlock: block;
			yourself! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"June 2, 2008 -> 3:50:56"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"June 2, 2008 -> 3:59:26"!

"System saved" !
"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #DefinitionReader as: (
(Class subclassOf: 'DefinitionFiler' instanceVariables: 'category visibility ')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #DefinitionReader)
comment: 
'(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license.'!


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #CommentReader as: (
(Class subclassOf: 'DefinitionReader' instanceVariables: '')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #CommentReader)
comment: 
''!


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

Delta define: #FileOutSet as: (
(Class subclassOf: 'Object' instanceVariables: 'classes
classCategories
definitions')) !


"June 2, 2008 -> 22:17:16"!

(Delta mirrorFor: #FileOutSet)
comment: 
'Simple tool to help organize file outs. Acts as a collection for classes
and method categories.

Add classes using addClass: and method categories using
addClass:category:. When adding method categories, you must add those
for class and instance side separately. When adding whole classes, just add
the instance side. File out the results using fileOutOn:.

Files out definitions of all classes before any methods are filed out to
ensure that there are no undefined symbols, even if there are circular
references between classes.'!


"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) classSide methodsFor: 'Unclassified' !
for: m <Mirror> category: c <Symbol>  ^ <Instance>
	^(self for: m) category: c
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
category ^ <Str>
	^category isNil 
		ifTrue: ['Unclassified']
		ifFalse: [category]
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
category: c <Str>
	category := c.
	('*private*' match: c)
		ifTrue: [ visibility := #private ]
		ifFalse: [ visibility := #public ]
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
fileInFrom: stream <ReadStream>
	| source <String> |
	[(source := stream nextChunk) isEmpty]
		whileFalse: [self fileInMethod: source].
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
fileInMethod: source <Str>
	| pt <ParseTree> ast <DeltaMethod> |
	pt := self mirror addMethod: source visibility: self visibility category: self category ifFail: [ :msg <String> :pos <Int> |
		^Transcript 
			nextPutAll: '"<< Method filein error in ';
			nextPutAll: self mirror name; 
			nextPutAll: ' category ';
			nextPutAll: self category; 
			nextPut: $"; cr;
			nextPutAll: (source copyFrom: 1 to: pos); cr;
			nextPutAll: '"<< ';
			nextPutAll: msg;
			nextPutAll: ' <<"'; cr;
			nextPutAll: (source copyFrom: pos + 1 to: source size); cr ].
	
	ast := pt body.
	ast clearBody. 			"Clear the body part of the ast. 
											This will go away once the type information no longer stores DeltaMethods."
! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #DefinitionReader) methodsFor: 'Unclassified' !
visibility ^ <Symbol>
	^visibility! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #CommentReader) methodsFor: 'Unclassified' !
fileInFrom: stream <ReadStream>

	self mirror comment: stream nextChunk! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) classSide methodsFor: 'instance creation' !
new

	^(super new)
		initialize;
		yourself! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class

	classes add: class.
	classCategories
		removeKey: class
		ifAbsent: [].
	classCategories
		removeKey: class class
		ifAbsent: [].
	definitions
		remove: class
		ifAbsent: []! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addClass: class category: category

	(classes includes: class)
		ifTrue: [^self].
	classCategories
		at: class
		ifPresent: [:categories| categories add: category]
		ifAbsentPut: [Set with: category]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'adding' !
addDefinition: class

	(classes includes: class) ifTrue: [^self].
	definitions add: class! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
definitionWriterFor: class

	^(DefinitionWriter for: (ClassMirror on: class))! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutCategoriesOn: stream

	classCategories keysAndValuesDo: [:class :categories|
		| definitionWriter |
		definitionWriter := self definitionWriterFor: class.
		categories do: [:category|
			definitionWriter fileOutCategory: category on: stream]]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassHeadersOn: stream

	self definitionsForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutHeaderOn: stream]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutClassMethodsOn: stream

	self classesForFileOut do: [:class|
		(self definitionWriterFor: class)
			fileOutMethodsOn: stream]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'filing out' !
fileOutOn: stream

	self fileOutClassHeadersOn: stream.
	self fileOutClassMethodsOn: stream.
	self fileOutCategoriesOn: stream! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
allDefinitions

	^Set new
		addAll: classes;
		addAll: definitions;
		yourself! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classSortBlock

	^[:class1 :class2| ((self superclassesFor: class2) includes: class1)
											or: [class1 name <= class2 name
														and: [((self superclassesFor: class1) includes: class2) not]]]! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
classesForFileOut

	^classes asSortedCollection: self classSortBlock! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
definitionsForFileOut

	^self allDefinitions asSortedCollection: self classSortBlock! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private -  filing out' !
superclassesFor: aClass

	|superclasses|
	superclasses := Set new.
	aClass superclassesDo: [:class| superclasses add: class].
	^superclasses! !

"June 2, 2008 -> 22:17:16"!

! (Delta mirrorFor: #FileOutSet) methodsFor: 'private - initialization' !
initialize

	classes := Set new.
	classCategories := Dictionary new.
	definitions := Set new! !

"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Error)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Notification)
comment: 
''!


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 2, 2008 -> 22:17:22"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| 
										ex inContextDo: [|result|
																		result :=  ex defaultAction.
																		ex isResumable ifFalse: [self defaultActionReturnError].
																		ex resume: result]]! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"June 2, 2008 -> 22:17:22"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	contextBlock isNil
		ifTrue: [^aBlock value].
	contextBlock value: aBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Error) methodsFor: 'exception descriptor' !
isResumable

	^false! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	handlerChain := self handlerChain nextHandler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotHappen ^<BottomType>

	self error: 'This shouldn''t happen'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotImplement ^<BottomType>

	self error: 'A message that cannot be supported by this class has been sent to an instance'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
subclassResponsibility ^<BottomType>

	"Note: In the Strongtalk language, a method whose body consists of only 
	 'self subclassResponsibility' is considered a declaration, which subclasses
	  must implement for concrete subclasses"

	self error: 'A message that should be implemented but is not has been sent to this object'.! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
unimplemented ^<BottomType>

	self error: 'A hook for unimplemented code has been encountered'! !

"June 2, 2008 -> 22:17:23"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"June 2, 2008 -> 22:23:31"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 2, 2008 -> 22:24:26"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'Running' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:24:52"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:2"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:12"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:24"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:34"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:52"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:25:59"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:26:8"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:26:18"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
tearDown

	Processor activeProcess resetHandlers! !

"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:21"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:31"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:42"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:28:49"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:9"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:15"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:21"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:27"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:29:34"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 2, 2008 -> 22:30:18"!

(Delta mirrorFor: #BlockExceptionDescriptorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:3"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) classSide methodsFor: 'Testing' !
isAbstract

	^true! !

"June 2, 2008 -> 22:31:17"!

(Delta mirrorFor: #BlockExceptionHandlerTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:33"!

(Delta mirrorFor: #BlockExceptionSelectorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:40"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:46"!

(Delta mirrorFor: #ErrorTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:53"!

(Delta mirrorFor: #ExceptionTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:31:59"!

(Delta mirrorFor: #LinkedExceptionHandlerTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:32:6"!

(Delta mirrorFor: #MessageNotUnderstoodTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:32:12"!

(Delta mirrorFor: #ProcessExceptionHandlingTest) removeMethod: #tearDown ifAbsent: [] !


"June 2, 2008 -> 22:33:32"!

"System saved" !
"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #BlockExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'handleBlock passBlock returnBlock')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #BlockExceptionHandler)
comment: 
'Exception handler for an exception. Handles the exception by invoking its handleBlock.'!


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Exception)
comment: 
'Base class of the exception hierarchy. Implements the core of the ANSI exception handling protocols'!


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #Error as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Error)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #Halt as: (
(Class subclassOf: 'Error' instanceVariables: '')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #Halt)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #LinkedExceptionHandler as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptionSelector handleBlock nextHandler returnBlock protectee retryBlock')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #LinkedExceptionHandler)
comment: 
'Exception handler for an exception. Invokes its handleBlock when asked to handle an exceptionthat matches its exceptionSelector. If the exception does not match its exceptionSelector it passesthe exception on to the nextHandler. If the nextHandler is undefined signal an UnhandledExceptionError.This class is internal to the exception handling framework. There should be no need for code outside of thisframework to interact with instances of ExceptionHandler.'!


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

Delta define: #MessageNotUnderstood as: (
(Class subclassOf: 'Error' instanceVariables: 'message')) !


"June 3, 2008 -> 11:34:13"!

(Delta mirrorFor: #MessageNotUnderstood)
comment: 
''!


"June 3, 2008 -> 11:34:13"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Notification as: (
(Class subclassOf: 'Exception' instanceVariables: '')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #Notification)
comment: 
''!


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

Delta define: #Process as: (
(Class subclassOf: 'Object' instanceVariables: 'priority <Int>
body <[]>
win32Handle <Win32Handle>
	"the thread id"
processError <ProcessError>
	"Description of why process stopped running"
handlerChain
	"Chain of registered exception handlers for this process"')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #Process)
comment: 
'Tags: %BlueBook %User

(c) 1995-1997 Sun Microsystems, Inc. ALL RIGHTS RESERVED. 
Use and distribution of this software is subject to the terms of the attached source license
'!


"June 3, 2008 -> 11:34:14"!

Delta define: #ZeroDivide as: (
(Class subclassOf: 'Error' instanceVariables: 'dividend')) !


"June 3, 2008 -> 11:34:14"!

(Delta mirrorFor: #ZeroDivide)
comment: 
''!


"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
default

	^self handleBlock: [:ex| 
										ex inContextDo: [|result|
																		result :=  ex defaultAction.
																		ex isResumable ifFalse: [self defaultActionReturnError].
																		ex resume: result]]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
defaultActionReturnError

	self error: 'Return from non-resumable default action is not supported'! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
handleBlock: block

	^self new
		handleBlock: block;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) classSide methodsFor: 'instantiation' !
new

	^super new initialize! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^false! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	^handleBlock value: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aBlock

	aBlock value: (handleBlock value: exception)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
nextHandler: ignored! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	passBlock value: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
passBlock: block

	passBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
return: value

	returnBlock value: value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'exception handler' !
returnBlock: block

	returnBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
handleBlock: block

	handleBlock := block! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #BlockExceptionHandler) methodsFor: 'private initialization' !
initialize

	handleBlock := [:exception|].
	passBlock := [:exception|].! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'Camp Smalltalk' !
sunitSignalWith: aString
  
        ^self signal: aString! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal
"Signal the occurrence of an exceptional condition."
	^ self new signal! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a specified textual description."
	^ self new signal: signalerText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."
"
	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself"! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
handles: exception
"Determine whether an exception handler will accept a signaled exception."
	^ exception isKindOf: self! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'Camp Smalltalk' !
sunitExitWith: aValue
 
        self return: aValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionBuilder' !
tag: t
"This message is not specified in the ANSI protocol,
but that looks like an oversight because #tag is specified,
and the spec states that the signaler may store the tag value."
	tag := t! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'exceptionDescription' !
tag
"Return an exception's tag value."
	^tag == nil
		ifTrue: [self messageText]
		ifFalse: [tag]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
isNested
"Determine whether the current exception handler is within 
the scope of another handler for the same exception."
	^ handler notNil and: [handler nextHandler canHandleSignal: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	[oldContext := contextBlock.
	^(self installContextAndDo: [(oldHandler := handler)
															outer: self return: [:value| ^value]]) value]
		ensure: [handler := oldHandler.
						contextBlock := oldContext]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
pass
"Yield control to the enclosing exception action for the receiver."
	contextBlock value: [handler pass: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resignalAs: replacementException
"Signal an alternative exception in place of the receiver."
	contextBlock value: [replacementException signal]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume
"Return from the message that signaled the receiver."
	self resume: nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	contextBlock value: [resumptionValue]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retry
"Abort an exception handler and re-evaluate its protected block."
	handler retry! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
retryUsing: alternativeBlock
"Abort an exception handler and evaluate a new block 
in place of the handler's protected block."
	handler retryUsing: alternativeBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return
"Return nil as the value of the block protected 
by the active exception handler."
	self return: nil! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
return: returnValue
"Return the argument as the value of the block protected 
by the active exception handler."
	handler return: returnValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
description
"Return a textual description of the exception."
	| desc mt |
	desc := self class name asString.
	^(mt := self messageText) == nil
		ifTrue: [desc]
		ifFalse: [desc, ': ', mt]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
messageText
"Return an exception's message text."
	^messageText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'printing' !
printOn: stream

	stream nextPutAll: self description! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
defaultAction
"The default action taken if the exception is signaled."
	self subclassResponsibility! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
handler: aHandler

	handler := aHandler! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'priv handling' !
isResumable
"Determine whether an exception is resumable."
	^ true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'private signal handling' !
installContextAndDo: aBlock
	"sets up a new context used as the target of a non-local return whenever an exception
	handling action needs to return to the signalling context. The context reference is cached
	in contextBlock. Whenever this block gets evaluated, its context will be consumed, so a
	new one needs to be set up. This is the purpose of the recursive call in the innermost block"
	|result|
	contextBlock := [:action| ^[(self installContextAndDo: action) value]].
	result := aBlock value.
	^[result]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	contextBlock isNil
		ifTrue: [^aBlock value].
	contextBlock value: aBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
messageText: signalerText
"Set an exception's message text."
	messageText := signalerText! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [Processor activeProcess handle: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal

	^self privateSignal value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
signal: signalerText
"Signal the occurrence of an exceptional condition with a 
specified textual description."
	self messageText: signalerText.
	^ self signal! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Error) methodsFor: 'exception descriptor' !
isResumable

	^false! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Error) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessExplicitError new msg: messageText)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Halt) methodsFor: 'testing' !
defaultAction

		Processor stopWithError: ProcessHaltError new! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Halt) methodsFor: 'testing' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: [:value|]
		outer: nil;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: nil;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) classSide methodsFor: 'exceptionBuilder' !
on: anExceptionSelector do: handleBlock return: returnBlock outer: outerBlock

	^self new
		on: anExceptionSelector
		do: handleBlock
		return: returnBlock
		outer: outerBlock;
		yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
canHandleSignal: exception

	^(exceptionSelector handles: exception)
		or: [nextHandler notNil
			and: [nextHandler canHandleSignal: exception]]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
evaluateProtectee: aBlock

	|result|
	protectee := aBlock.
	retryBlock := [^[self evaluateProtectee: protectee]]."fix this - should evaluate the returned block"
	result := protectee value.
	^[result]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception

	self handle: exception
		return: returnBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						aReturnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
nextHandler

	^nextHandler! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	^nextHandler handle: exception return: aReturnBlock! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
pass: exception

	^nextHandler handle: exception! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
protect: aBlock

	Processor activeProcess pushHandler: self.
	^[(self evaluateProtectee: aBlock) value]
		ensure: [Processor activeProcess popHandler]! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retry

	retryBlock value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
retryUsing: aBlock

	protectee := aBlock.
	retryBlock value! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
return: aValue

	returnBlock value: aValue! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
nextHandler: exceptionHandler

	nextHandler := exceptionHandler ! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'private - initialization' !
on: anExceptionSelector do: block return: aReturnBlock outer: outerBlock

	exceptionSelector := anExceptionSelector.
	handleBlock := block.
	returnBlock := aReturnBlock.
	nextHandler := BlockExceptionHandler default! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) classSide methodsFor: 'instance creation' !
message: aMessage

	^self new message: aMessage; yourself! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
message

	^message! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'accessing' !
receiver

	^message receiver! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'priv handling' !
defaultAction

	Processor stopWithError: (ProcessDoesNotUnderstandError new message: message)! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #MessageNotUnderstood) methodsFor: 'private initialization' !
message: aMessage

	message := aMessage! !

"June 3, 2008 -> 11:34:14"!

! (Delta mirrorFor: #Notification) methodsFor: 'exception description' !
defaultAction

	^nil! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) classSide methodsFor: 'Instance creation' !
dividend: dividend

	^self new
		dividend: dividend;
		yourself! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'accessing' !
dividend

	^dividend! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'private - initialization' !
dividend: aValue

	dividend := aValue.
	messageText := 'divide by zero'! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #ZeroDivide) methodsFor: 'testing' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handle: exception

	^self handlerChain handle: exception! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain

	handlerChain isNil
		ifTrue: [handlerChain := BlockExceptionHandler default].
	^handlerChain! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
popHandler

	| poppedHandler |
	handlerChain := (poppedHandler := self handlerChain) nextHandler.
	^poppedHandler! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
pushHandler: handler

	handler nextHandler: self handlerChain.
	handlerChain := handler ! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetExceptionEnvironment

	handlerChain := nil

! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
resetHandlers

	handlerChain := nil

! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
doesNotUnderstand: m <Message> ^<BottomType>
	"Processor stopWithError: (ProcessDoesNotUnderstandError new message: m)"
	(MessageNotUnderstood message: m) signal! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
error: msg <Str> ^<BottomType>

	"Processor stopWithError: (ProcessExplicitError new msg: msg)"
	Error signal: msg! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
halt

	"Processor stopWithError: ProcessHaltError new."
	Halt signal
! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotHappen ^<BottomType>

	self error: 'This shouldn''t happen'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
shouldNotImplement ^<BottomType>

	self error: 'A message that cannot be supported by this class has been sent to an instance'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
subclassResponsibility ^<BottomType>

	"Note: In the Strongtalk language, a method whose body consists of only 
	 'self subclassResponsibility' is considered a declaration, which subclasses
	  must implement for concrete subclasses"

	self error: 'A message that should be implemented but is not has been sent to this object'.! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #Object) methodsFor: 'private-error handling' !
unimplemented ^<BottomType>

	self error: 'A hook for unimplemented code has been encountered'! !

"June 3, 2008 -> 11:34:15"!

! (Delta mirrorFor: #BlockWithoutArguments) methodsFor: 'exceptions' !
on: exception do: handlerBlock

	^(LinkedExceptionHandler
		on: exception
		do: handlerBlock
		return: [:value | ^ value]) protect: self
! !

"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #AbstractExceptionHandlingTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #AbstractExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptor as: (
(Class subclassOf: 'Object' instanceVariables: 'defaultBlock
handlerBlock
resumeBlock')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionDescriptor)
comment: 
'Implements the <exceptionDescriptor> protocol from the ANSI standard using configurable actionsdefined as blocks. Intended to be used primarily as a testing aid.'!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionDescriptorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exception')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionDescriptorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionHandlerTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelector as: (
(Class subclassOf: 'Object' instanceVariables: 'handlesBlock')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionSelector)
comment: 
'Determines whether an exception can be handled by evaluating the handlesBlock.'!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockExceptionSelectorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockExceptionSelectorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #BlockWithoutArgumentsExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ErrorTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'handlers')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #ErrorTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #ExceptionTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #ExceptionTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #HaltTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

(Delta mirrorFor: #HaltTest)
comment: 
''!


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:22"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #LinkedExceptionHandlerTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #LinkedExceptionHandlerTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #MessageNotUnderstoodTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #MessageNotUnderstoodTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #NotificationTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #NotificationTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #ProcessExceptionHandlingTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #ProcessExceptionHandlingTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

Delta define: #TestException as: (
(Class subclassOf: 'Exception' instanceVariables: 'defaultActionBlock resumable')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #TestException)
comment: 
'Concrete exception class that can be used for testing'!


"June 3, 2008 -> 11:34:23"!

Delta define: #WarningTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #WarningTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

Delta define: #ZeroDivideTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 3, 2008 -> 11:34:23"!

(Delta mirrorFor: #ZeroDivideTest)
comment: 
''!


"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) classSide methodsFor: 'Testing' !
isAbstract

	^name = #AbstractExceptionHandlingTest! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'Running' !
tearDown
"	some of these tests do nasty things to the exception
	environment so best clean up after them by resetting it"
	Processor activeProcess resetExceptionEnvironment! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #AbstractExceptionHandlingTest) methodsFor: 'test support' !
withStopHandler: stopHandler do: aBlock

	| oldHandler |
	oldHandler := Processor stopHandler.
	Processor stopHandler: stopHandler.
	aBlock
		ensure: [Processor stopHandler: oldHandler]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
new

	^super new
		initialize;
		yourself! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
defaultActionBlock: block

	defaultBlock := block! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handler: handler

	handlerBlock value: handler ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
handlerBlock: block

	handlerBlock := block ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'configuring' !
resumeBlock: aBlock

	resumeBlock := aBlock! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
defaultAction

	^defaultBlock value! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
isResumable

	^true! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'exception descriptor' !
resume: aValue

	resumeBlock value: aValue! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'initialization' !
initialize

	defaultBlock := [nil].
	handlerBlock := [:ignore|].
	resumeBlock := [:ignore|]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptor) methodsFor: 'restricted - exception handling' !
inContextDo: aBlock

	^aBlock value! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'Running' !
setUp

	super setUp.
	exception := BlockExceptionDescriptor new! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultActionShouldInvokeDefaultActionBlock

	|wasInvoked|
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	exception defaultActionBlock: [wasInvoked := true].
	exception defaultAction.
	self assert: wasInvoked! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testDefaultDefault

	self assert: exception defaultAction isNil! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionDescriptorTest) methodsFor: 'testing' !
testHandlerShouldDelegateToHandlerBlock

	|actualHandler|
	exception handlerBlock: [:handler| actualHandler := handler].
	exception handler: #handler.
	self assert: (actualHandler == #handler)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[handler handle: exception.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testShouldInvokeHandlerBlockWithException

	|handled exception|
	handled := false.
	exception = Object new.
	(BlockExceptionHandler
		handleBlock: [:ex| self assert: (ex == exception).
									handled := true])
		handle: exception.
	self assert: handled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
falseSelector

	^BlockExceptionSelector handlesBlock: [:ex| false]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
handlesBlock: block

	^self new
		handlesBlock: block;
		yourself! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) classSide methodsFor: 'instantiation' !
trueSelector

	^BlockExceptionSelector handlesBlock: [:ex| true]! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'exception selector' !
handles: exceptionDescriptor

	^handlesBlock value: exceptionDescriptor! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelector) methodsFor: 'private - initialization' !
handlesBlock: block

	handlesBlock := block ! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldHandleWhenHandleBlockReturnsTrue

	|canHandle selector|
	selector := BlockExceptionSelector handlesBlock: [:ex| canHandle].
	canHandle := true.
	self assert: (selector handles: nil).
	canHandle := false.
	self deny: (selector handles: nil)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockExceptionSelectorTest) methodsFor: 'Testing' !
testShouldPassExceptionToHandlesBlock

	|exception selector|
	exception := Object new.
	selector := BlockExceptionSelector handlesBlock: [:ex| self assert: (ex == exception). true].
	self assert: (selector handles: exception)! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeDoWhenExceptionSignalled

	|wasHandled|
	wasHandled := false.
	[Exception signal]
		on: Exception
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Signalled exception should be handled'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldInvokeNestedHandler

	|innerInvoked outerInvoked|
	innerInvoked := false.
	outerInvoked := false.
	[[Exception signal]
		on: BlockExceptionSelector falseSelector
		do: [:ex| innerInvoked := true]]
			on: Exception
			do: [:ex| outerInvoked := true].
	self deny: innerInvoked
			description: 'Inner handler should not be invoked'.
	self assert: outerInvoked
			description: 'Outer handler should be invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testOnDoShouldPopHandler

	|handlerInvoked descriptor defaultInvoked|
	descriptor := BlockExceptionDescriptor new.
	descriptor
		defaultActionBlock: [defaultInvoked := true];
		resumeBlock: [:value| ^self " force NLR"].
	[Exception signal]
		on: BlockExceptionSelector trueSelector
		do: [:ex| handlerInvoked := true].
	defaultInvoked := false.
	handlerInvoked := false.
	[Processor activeProcess handle: descriptor]
		ensure: [self deny: handlerInvoked
								description: 'Handler should have been popped'.
						self assert: defaultInvoked
								description: 'Default action should have been invoked']! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #BlockWithoutArgumentsExceptionHandlingTest) methodsFor: 'testing' !
testShouldUnwindExceptionHandlersWhenHandlingException

	| wasInvoked |
	wasInvoked := false.
	[[[Notification signal]
			on: Error
			do: [:ex| self signalFailure: 'Should be caught by outer handler']]
				on: Notification
				do: [:ex| self error: 'Provoke outer handler']]
					on: Error
					do: [:ex| wasInvoked:= true].
	self assert: wasInvoked description: 'Outer handler should be invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testDefaultActionShouldPassToStopHandler

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
													processError := p processError]
			do: 	[[self error: 'this is an error'] fork.
					Processor yield].
	self assert: wasHandled
			description: 'defaultAction should invoke the stopHandler'.
	self assert: (processError isKindOf: ProcessExplicitError)
			description: 'Process stopped with wrong kind of error', processError printString.
	self assert: 'this is an error' = processError msg
			description: 'Process stopped with wrong message: ', processError msg! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testErrorShouldSignalError

	| wasSignalled |
	wasSignalled := true.
	[self error: 'error message'.
	self signalFailure: 'should not return']
		on: Error
		do: [:ex| wasSignalled := true.
				self assert: 'error message' = ex messageText
						description: ex messageText printString].
	self assert: wasSignalled
			description: 'Error should be signalled'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ErrorTest) methodsFor: 'testing' !
testShouldNotBeResumable

	self deny: Error new isResumable! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironment

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[original signal]
		on: Error
		do: [:ex| wasHandled := true].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironmentAfterResumableOuter

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[[original signal]
		on: Error
		do: [:ex| wasHandled := true]]
			on: TestException
			do: [:ex| ex outer].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWhenOuterHandlerDoesntHandle

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self deny: ex isNested.
				wasHandled := true]]
		on: TestException
		do: [:ex|].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeFalseWithNoHandler

	|exception|
	exception := Exception new.
	self deny: exception isNested! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled:= true]]
		on: Exception
		do: [:ex| self shouldNotHappen].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testIsNestedShouldBeTrueWhenOuterOuterHandlerHandles

	|wasHandled|
	wasHandled := false.
	[[[Exception signal]
		on: Exception
		do: [:ex| self assert: ex isNested.
				wasHandled := true]]
			on: TestException
			do: [:ex|]]
				on: Exception
				do: [:ex|].
	self assert: wasHandled! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldInvokeAndReturnDefaultActionWhenResumable

	|outer result|
	[(TestException defaultActionBlock: [#result])
		resumable: true;
		signal]
			on: TestException
			do: [:ex|
					self assert: ex outer == #result description: 'outer returned wrong result'.
					result := #returned].
	self assert: result == #returned description: 'outer did not return'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterShouldReturnResumptionValueWhenResumed

	|wasResumed|
	wasResumed := false.
	[[TestException new resumable: true; signal]
		on: TestException
		do: [:ex| |result|
				result := ex outer.
				self assert: 'result' = result description: result printString.
				wasResumed := true]]
					on: TestException
					do: [:ex| ex resume: 'result'.
							self signalFailure: 'Resume should not return'].
	self assert: wasResumed description: 'not resumed'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldDeferToOuterHandler

	|wasPassed|
	wasPassed := false.
	[[TestException signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'pass should not return']]
		on: TestException
		do: [:ex| wasPassed := true].
	self assert: wasPassed! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeDefaultActionWithoutReturning

	| signalReturned |
	signalReturned := false.
	[|result|
	result := (TestException defaultActionBlock: ['result'])
						resumable: true;
						signal.
	self assert: result = 'result' description: result printString.
	signalReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return'].
	self assert: signalReturned description: 'Signal did not return'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testPassShouldInvokeSurroundingHandler

	| wasPassed |
	wasPassed := false.
	[[TestException new signal]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| wasPassed := true].
	self assert: wasPassed description: 'Outer handler not invoked'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResignalAsShouldRestoreSignalEnvironment

	|log|
	log := String new writeStream.
	[[Exception signal]
		on: TestException
		do: [:ex| log nextPutAll: 'resignal']]
			on: Exception
			do: [:ex| [log nextPutAll: 'signal '.
							ex resignalAs: TestException new]
								ifCurtailed: [log nextPutAll: 'curtail ']].
	self assert: log contents = 'signal curtail resignal' description: log contents! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeAfterPassShouldReturnResultFromSignal

	| wasReturned |
	wasReturned := false.
	[[|result|
	result := TestException new resumable: true; signal.
	self assert: 'result' = result description: result printString.
	wasReturned := true]
		on: TestException
		do: [:ex| ex pass.
				self signalFailure: 'Pass should not return']]
				on: TestException
				do: [:ex| ex resume: 'result'].
	self assert: wasReturned description: 'Resume did not return from signal'! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnAsValueOfOuter

	|result|
	[[Exception signal]
		on: Exception
		do: [:ex| result := ex outer]]
			on: Exception
			do: [:ex| ex resume: #result].
	self assert: result == #result description: result printString! !

"June 3, 2008 -> 11:34:23"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testResumeShouldReturnValueAsResultOfSignal

	|wasResumed|
	wasResumed := false.
	[|result|
	result := TestException new
						resumable: true;
						signal.
	self assert: #resume == result description: result printString.
	wasResumed := true]
		on: TestException
		do: [:ex| ex resume: #resume].
	self assert: wasResumed description: 'Should have resumed after signal'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryShouldReevaluateProtectee

	|count|
	count := 0.
	[count := count + 1.
	count == 1 ifTrue:[Exception signal]]
		on: Exception
		do: [:ex| ex retry].
	self assert: count == 2 description: 'Count was ' , count printString! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testRetryUsingShouldReplaceProtectee

	|log count|
	log := String new writeStream.
	count := 0.
	[[Exception signal]
		ensure: [log nextPutAll: 'unwind ']]
			on: Exception
			do: [:ex|
					log nextPutAll: 'handle '.
					count := count + 1.
					count = 1 ifTrue: [ex retryUsing: [log nextPutAll: 'using '.
													Exception signal]]].
	self assert: log contents = 'handle unwind using handle '
			description: log contents! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldDelegateToHandler

	|exception handler result|
	exception := Exception new.
	handler := BlockExceptionHandler new.
	result := #invalid.
	handler returnBlock: [:value| result := value].
	exception handler: handler.
	exception return.
	self assert: result isNil description: 'Return should pass back nil'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testSignalShouldInvokeProcessHandler

	|wasInvoked|
	wasInvoked := false.
	Processor activeProcess
		pushHandler: (LinkedExceptionHandler
										on: Exception
										do: [:ex| wasInvoked := true]).
	Exception signal.
	[self assert: wasInvoked description: 'Should invoke exception handler']
		ensure: [Processor activeProcess popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testDefaultActionShouldStopWithProcessHaltError

	| wasHandled processError |
	wasHandled := false.
	self withStopHandler: [:p| wasHandled := true.
													processError := p processError]
			do: [[self halt] fork.
					Processor yield].
	self assert: wasHandled
			description: 'Halt should have been handled'.
	self assert: (processError isKindOf: ProcessHaltError)
			description: 'Wrong kind of error reported'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testHaltShouldSignalHalt

	| wasSignalled |
	wasSignalled := false.
	[self halt]
		on: Halt
		do: [:ex| wasSignalled := true].
	self assert: wasSignalled! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testHandlerShouldSetHandlerOnException

	|handler exception assignedHandler|
	exception := BlockExceptionDescriptor new.
	exception handlerBlock: [:handler| assignedHandler := handler].
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	self assert: assignedHandler ~~ handler
			description: 'Handler should not have been assigned yet'.
	handler handle: exception.
	self assert: assignedHandler == handler
			description: 'Handler should have been assigned'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testPassShouldDeferToNextHandler

	|handler trueSelector exception wasPassed nextHandler|
	exception := BlockExceptionDescriptor new.
	handler := LinkedExceptionHandler
							on: BlockExceptionSelector trueSelector
							do: [:ex| ].
	nextHandler := BlockExceptionHandler handleBlock: [:ex| wasPassed := true].
	handler nextHandler: nextHandler.
	wasPassed := false.
	handler pass: exception.
	self assert: wasPassed
			description: 'Handler should defer pass to nextHandler'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testReturnShouldEvaluateReturnBlock

	|handler result |
	handler := LinkedExceptionHandler
			on: nil
			do: [:ex| ]
			return: [:returnValue| result := returnValue].
	handler return: #value.
	self assert: result == #value
			description: 'Should have invoked return'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldDelegateToNextHandlerWhenNoMatch

	|handled exception nextHandler|
	handled := false.
	exception := BlockExceptionDescriptor new.
	nextHandler := BlockExceptionHandler
										handleBlock: [:ex| self assert: ex == exception
																					description: 'Handler invoked with wrong exception'.
																	handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self signalFailure: 'Should not invoke hander'])
			nextHandler: nextHandler;
			handle: exception.
	self assert: handled
			description: 'Next handler not invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeExceptionsDefaultActionWhenNoNextHandler

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [handled := true].
	(LinkedExceptionHandler
		on: BlockExceptionSelector falseSelector
		do: [:ex| self shouldNotHappen])
			handle: exception.
	self assert: handled
			description: 'Default action not invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #LinkedExceptionHandlerTest) methodsFor: 'testing' !
testShouldInvokeHandleBlockWhenExceptionMatches

	|handled exception|
	handled := false.
	exception := BlockExceptionDescriptor new.
	(LinkedExceptionHandler
		on: BlockExceptionSelector trueSelector
		do: [:ex|
				self assert: ex == exception
						description: 'Handler invoked with wrong exception'.
				handled := true])
		handle: exception.
	self assert: handled
			description: 'Exception not handled by handler'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testMessageShouldReturnMessageThatWasNotUnderstood

	| message |
	message := Message
								receiver: 1
								selector: #zork
								arguments: #().
	[(MessageNotUnderstood message: message)
			signal.]
		on: MessageNotUnderstood
		do: [:ex| self assert: message = ex message
								description: 'Wrong message']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testReceiverShouldReturnReceiverOfMessage

	| message |
	message := Message
								receiver: 1
								selector: #zork
								arguments: #().
	[(MessageNotUnderstood message: message)
			signal.]
		on: MessageNotUnderstood
		do: [:ex| self assert: 1 = ex receiver
								description: 'Wrong receiver']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testResumeShouldReturnResultFromSignal
"	note that until doesNotUnderstand: is fixed in the VM
	we cannot use the more obvious test of sending a
	message to an object that cannot understand it"
	|result|
	[result := (MessageNotUnderstood
							message: (Message
														receiver: 1
														selector: #zork
														arguments: #()))
							signal.]
		on: MessageNotUnderstood
		do: [:ex| ex resume: 5].
	self assert: result = 5
			description: 'Result not returned'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #MessageNotUnderstoodTest) methodsFor: 'testing' !
testShouldBeResumable

	self assert: MessageNotUnderstood new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #NotificationTest) methodsFor: 'Testing' !
testDefaultActionReturnsNil

	self assert: Notification signal isNil! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #NotificationTest) methodsFor: 'Testing' !
testIsResumable

	self assert: Notification new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testHandleShouldInvokeDefaultAction

	|exception wasInvoked|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [wasInvoked := true];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	[Processor activeProcess handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToDefaultHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception|
	exception := BlockExceptionDescriptor new.
	exception defaultActionBlock: [wasInvoked := true].
	process := Processor activeProcess.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	wasInvoked := false.
	[[process handle: exception]
		ensure: [self assert: wasInvoked
								description: 'Default action not invoked']]
			ensure: [process popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldDeferToOuterHandlerWhenExceptionDoesntMatch

	|process wasInvoked exception outerHandler|
	wasInvoked := false.
	exception := BlockExceptionDescriptor new.
	exception
		defaultActionBlock: [];
		resumeBlock: [:value|^self "force NLR to prevent problems with test infrastructure"].
	outerHandler := (LinkedExceptionHandler
										on: BlockExceptionSelector trueSelector
										do: [:ex| wasInvoked := true]).
	process := Processor activeProcess.
	process pushHandler: outerHandler.
	process pushHandler: (LinkedExceptionHandler
														on: BlockExceptionSelector falseSelector
														do: [:ex| ]).
	[[process handle: exception]
			ensure: [self assert: wasInvoked
									description: 'Outer handler should have been invoked']]
				ensure: [process popHandler.
								process popHandler]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ProcessExceptionHandlingTest) methodsFor: 'testing' !
testPushedHandlerShouldReplaceDefaultHandler

	|process wasInvoked exception|
	process := Processor activeProcess.
	exception := BlockExceptionDescriptor new.
	wasInvoked := false.
	process pushHandler: (LinkedExceptionHandler
													on: BlockExceptionSelector trueSelector
													do: [:ex| wasInvoked := true]).
	[wasInvoked := false.
	process handle: exception]
		ensure: [process popHandler].
	self assert: wasInvoked description: 'Handler should be invoked'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) classSide methodsFor: 'test support' !
defaultActionBlock: block

	^self new
			defaultActionBlock: block;
			yourself! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultAction	^defaultActionBlock value! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
defaultActionBlock: block	defaultActionBlock := block! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
isResumable	^resumable isNil		ifTrue: [false]		ifFalse: [resumable]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #TestException) methodsFor: 'test support' !
resumable: boolean	^resumable := boolean! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Warning new isResumable! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testDivideByZeroShouldSignalZeroDivide

	| wasSignalled |
	wasSignalled := false.
	[1/0]
		on: ZeroDivide
		do: [:ex| wasSignalled := true.
						self assert: 1 = ex dividend
								description: 'Wrong dividend:', ex dividend printString.
						self assert: 'divide by zero' = ex messageText
								description: 'Wrong message: ', ex messageText printString].
	self assert: wasSignalled
			description: 'Should have signalled'! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testDividendShouldReturnDividendThatCreatedException

	[(ZeroDivide dividend: 1) signal]
		on: ZeroDivide
		do: [:ex| self assert: 1 = ex dividend]! !

"June 3, 2008 -> 11:34:24"!

! (Delta mirrorFor: #ZeroDivideTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: ZeroDivide new isResumable! !

"June 3, 2008 -> 11:37:37"!

Delta define: #Warning as: (
(Class subclassOf: 'Notification' instanceVariables: '')) !


"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Warning new isResumable! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'	
							! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:37:37"!

! (Delta mirrorFor: #Warning) methodsFor: 'exception descriptor' !
defaultAction

	self halt! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Warning) methodsFor: 'exception descriptor' !
defaultAction

	self halt! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testDefaultActionShouldExecuteInSignallingEnvironmentAfterResumableOuter

	| original wasHandled |
	original := TestException defaultActionBlock: [self error: ''].
	original resumable: true.
	wasHandled := false.
	[[original signal]
		on: Error
		do: [:ex| wasHandled := true]]
			on: TestException
			do: [:ex| ex outer].
	self assert: wasHandled! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	["oldContext := contextBlock."
	"^(self installContextAndDo: ["
	(oldHandler := handler)
			outer: self return: [:value| ^value]
															"]) value"
															]
		ensure: [handler := oldHandler.
						"contextBlock := oldContext"]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
withResume: resumeBlock do: aBlock

	| oldResume |
	aBlock value! !

"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
new

	^super new initialize; yourself! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionInstantiator' !
new

	^super new
			initialize;
			yourself! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
initialize

	resumeBlock := [:resumptionValue| contextBlock value: [resumptionValue]]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
withResume: aResumeBlock do: aBlock

	| oldResume |
	oldResume := resumeBlock.
	resumeBlock := aResumeBlock.
	aBlock
		ensure: [resumeBlock := oldResume]! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
resume: resumptionValue
"Return resumptionValue as the value of the signal message."
	resumeBlock value: resumptionValue! !

"June 3, 2008 -> 11:39:28"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	nextHandler handle: exception return: aReturnBlock! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
outer: exception return: aReturnBlock

	exception
		withResume: [:value| ^value]
		do: [nextHandler handle: exception return: aReturnBlock]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'handling' !
outer
"Evaluate the enclosing exception action and return to here 
instead of signal if it resumes (see #resumeUnchecked:)."
	| oldHandler oldContext |
	self isResumable
		ifFalse: [self pass].
	["oldContext := contextBlock."
	"^(self installContextAndDo: ["
	^(oldHandler := handler)
			outer: self return: [:value| ^value]
															"]) value"
															]
		ensure: [handler := oldHandler.
						"contextBlock := oldContext"]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #LinkedExceptionHandler) methodsFor: 'exception handler' !
handle: exception return: aReturnBlock

	Processor activeProcess popHandler.
	[^(exceptionSelector handles: exception)
		ifTrue: [	exception handler: self.
						returnBlock value: (handleBlock value: exception)]
		ifFalse: [nextHandler handle: exception return: aReturnBlock]]
			ensure: [Processor activeProcess pushHandler: self]! !

"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

Delta define: #Exception as: (
(Class subclassOf: 'Object' instanceVariables: 'messageText
tag
handler
signalledHandler "this was the first handler when the exception was originally signalled"
contextBlock	"used to mark the signalling context - should be restored whenever evaluated"
resumeBlock')) !


"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'signaling' !
privateSignal

	^self installContextAndDo: [signalledHandler := Processor activeProcess handlerChain.
														signalledHandler handle: self]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
handlerChain: aHandler

	handlerChain := aHandler! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Process) methodsFor: 'exception support' !
inEnvironment: aHandler do: block

	| oldHandler |
	oldHandler := self handlerChain.
	handlerChain := aHandler.
	block
		ensure: [handlerChain := oldHandler]! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #Exception) methodsFor: 'restricted exception handling' !
inContextDo: aBlock

	Processor activeProcess
		inEnvironment: signalledHandler
		do: aBlock
	! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #BlockExceptionHandlerTest) methodsFor: 'Testing' !
testDefaultHandlerShouldReportErrorAfterReturnFromNonResumableDefaultAction

	| handler exception wasHandled |
	handler := BlockExceptionHandler default.
	exception := TestException defaultActionBlock: [].
	exception resumable: false.
	[exception signal.
	self signalFailure: 'Handler should not return']
		on: Error
		do: [:error| self assert: 'Return from non-resumable default action is not supported' = error messageText
									description: error messageText.
				wasHandled := true].
	self assert: wasHandled description: 'Handler should report error'! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1
							ex resume].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testOuterTwiceShouldInvokeSurroundingHandlerTwice

	|count|
	count := 0.
	[[TestException new
		resumable: true;
		signal]
		on: TestException
		do: [:ex| ex outer.
				ex outer]]
			on: TestException
			do: [:ex| count := count + 1.
							ex resume].
	self assert: count == 2 description: 'Count was ', count printString! !

"June 3, 2008 -> 11:39:29"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase echo.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									aTestCase echo.
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												self halt.
												aTestCase echo.
												Transcript cr.
												signal class printOn: Transcript.
												signal messageText isNil
													ifFalse: [Transcript space; show: signal messageText].
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 3, 2008 -> 11:42:19"!

! (Delta mirrorFor: #WarningTest) methodsFor: 'Testing' !
testDefaultActionShouldProvokeHalt

	| wasHalted wasSignalled |
	wasHalted := wasSignalled := false.
	[[Warning signal]
		on: Halt
		do: [:ex| wasHalted := true]]
				on: Warning
				do: [:ex| wasSignalled := true.
								ex outer].
	self assert: wasSignalled
			description: 'Should have signalled Warning'.	
	self assert: wasHalted
			description: 'Default action should have halted'! !

"June 3, 2008 -> 11:45:34"!

! (Delta mirrorFor: #TestCase) methodsFor: 'Printing' !
echo

	Transcript cr.
	self printOn: Transcript! !

"June 3, 2008 -> 11:47:26"!

! (Delta mirrorFor: #RationalNumber) classSide methodsFor: 'instance creation' !
numerator: n <Int> denominator: d <Int> ^<RationalNumber>

	| gcd <Int> num <Int> denom <Int> |
	d < 0
		ifFalse: [ d == 0
					ifTrue: [ (ZeroDivide dividend: n) signal ]
					ifFalse: [ num := n. denom := d ]	]
		ifTrue: [ num := n negated. denom := d negated ].
	gcd := num gcd: denom.
	num := num // gcd.
	^gcd == denom
		ifTrue: [ num ]
		ifFalse: [	Fraction
							numerator: num
							denominator: denom // gcd ]! !

"June 3, 2008 -> 11:51:15"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						aTestCase echo.
						Transcript cr; tab; show: signal messageText.
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: MessageNotUnderstood
							do: [:signal | |message|
									aTestCase echo.
									message := signal message.
									message receiver printOn: (Transcript cr; yourself).
									Transcript space; show: message selector.
									signal pass]]
										sunitOn: self class error
										do: [:signal |
												aTestCase echo.
												Transcript cr.
												signal class printOn: Transcript.
												signal messageText isNil
													ifFalse: [Transcript space; show: signal messageText].
												self errors add: aTestCase.
												signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 3, 2008 -> 11:52:4"!

"System saved" !
"June 3, 2008 -> 23:53:37"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueAsResutlOfOnDo

	| result |
	result := [Error signal]
						on: Error
						do: [:ex| ex return: #value.
										self signalFailure: 'return: should not return!!'].
	self assert: result = #value
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:56:28"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromInnerHandler

	| result |
	[result := [Error signal]
						on: Error
						do: [:ex| ex return: #value1]]
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value1
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:57:4"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromOuterHandler

	| result |
	result := [[Error signal]
						on: Error
						do: [:ex| ex outer]]
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value2
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:57:50"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testReturnShouldReturnValueFromOuterHandler

	| result |
	result := [[Error signal]
						on: Error
						do: [:ex| ex outer].
					self signalFailure: 'Block should not complete']
							on: Error
							do: [:ex| ex return: #value2].
	self assert: result = #value2
			description: 'Wrong result returned:', result! !

"June 3, 2008 -> 23:58:55"!

"System saved" !
"June 4, 2008 -> 0:3:14"!

! (Delta mirrorFor: #ExceptionTest) methodsFor: 'Testing' !
testExceptionSetForWarningAndHaltHandlesBoth

	| exceptionSet |
	exceptionSet := Warning, Halt.
	self assert: (exceptionSet handles: Warning new)
			description: 'Should handle Warning'.
	self assert: (exceptionSet handles: Halt new)
			description: 'Should handle Halt'.
	self deny: (exceptionSet handles: Error new)
			description: 'Shouldn''t handle Error'.! !

"June 4, 2008 -> 0:5:0"!

Delta define: #ExceptionSet as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 4, 2008 -> 0:5:19"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."

	^ExceptionSet new
		add: self;
		add: anotherException;
		yourself! !

"June 4, 2008 -> 0:5:56"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
add: exceptionSelector

	! !

"June 4, 2008 -> 0:7:1"!

! (Delta mirrorFor: #Exception) classSide methodsFor: 'exceptionSelector' !
, anotherException
"Create an exception set."

	^(ExceptionSet with: self)
			,  anotherException! !

"June 4, 2008 -> 0:7:39"!

! (Delta mirrorFor: #ExceptionSet) classSide methodsFor: 'instance creation' !
with: exceptionClass

	^self new , exceptionClass! !

"June 4, 2008 -> 0:7:57"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize! !

"June 4, 2008 -> 0:8:5"!

Delta define: #ExceptionSet as: (
(Class subclassOf: 'Object' instanceVariables: 'exceptions')) !


"June 4, 2008 -> 0:8:17"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize

	exceptions  := Set new! !

"June 4, 2008 -> 0:8:23"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'initialization' !
initialize

	exceptions := Set new! !

"June 4, 2008 -> 0:8:36"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
, exceptionClass! !

"June 4, 2008 -> 0:9:29"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'accessing' !
, exceptionClass

	exceptions add: exceptionClass! !

"June 4, 2008 -> 0:10:4"!

! (Delta mirrorFor: #ExceptionSet) classSide methodsFor: 'instance creation' !
with: exceptionClass

	^self new initialize , exceptionClass! !

"June 4, 2008 -> 0:10:50"!

! (Delta mirrorFor: #ExceptionSet) methodsFor: 'exception selector' !
handles: anException

	^exceptions includes: anException class! !

"June 4, 2008 -> 0:11:48"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: '')) !


"June 4, 2008 -> 0:14:21"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| exceptionSelector wasHandled |
	exceptionSelector := Warning, Halt.
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:15:20"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exceptionSelector')) !


"June 4, 2008 -> 0:15:29"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
setUp
! !

"June 4, 2008 -> 0:16:22"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Running' !
setUp

	super setUp.
	exceptionSelector := Warning, Halt.
! !

"June 4, 2008 -> 0:17:7"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| wasHandled |
	exceptionSelector := Warning, Halt.
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:15"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsMatchingException

	| wasHandled |
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:33"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	| wasHandled |
	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:17:36"!

(Delta mirrorFor: #ExceptionSetTest) removeMethod: #testExceptionSetSelectsMatchingException ifAbsent: [] !


"June 4, 2008 -> 0:17:49"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	| wasHandled |
	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'	! !

"June 4, 2008 -> 0:18:52"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	[Notification signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:7"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:35"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	| wasHandled |
	wasHandled := false.
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:43"!

Delta define: #ExceptionSetTest as: (
(Class subclassOf: 'AbstractExceptionHandlingTest' instanceVariables: 'exceptionSelector
wasHandled')) !


"June 4, 2008 -> 0:19:48"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	wasHandled := false.
	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:19:58"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Running' !
setUp

	super setUp.
	exceptionSelector := Warning, Halt.
	wasHandled := false! !

"June 4, 2008 -> 0:20:12"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'	! !

"June 4, 2008 -> 0:20:17"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	[Warning signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:20:25"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'	! !

"June 4, 2008 -> 0:20:30"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	[Halt signal.
	self error: '']
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self assert: wasHandled
			description: 'Should have caught Halt'! !

"June 4, 2008 -> 0:20:54"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	[Notification signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:21:49"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
signal: exceptionClass

	[exceptionClass signal]
		on: exceptionSelector
		do: [:ex| wasHandled := true].! !

"June 4, 2008 -> 0:22:8"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsHalt

	self signal: Halt.
	self assert: wasHandled
			description: 'Should have caught Halt'! !

"June 4, 2008 -> 0:22:23"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	self signal: Warning
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:22:33"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetSelectsWarning

	self signal: Warning.
	self assert: wasHandled
			description: 'Should have caught Warning'! !

"June 4, 2008 -> 0:22:55"!

! (Delta mirrorFor: #ExceptionSetTest) methodsFor: 'Testing' !
testExceptionSetShouldntSelectNotification

	self signal: Notification.
	self deny: wasHandled
			description: 'Shouldn''t have caught Notification'	! !

"June 4, 2008 -> 0:25:22"!

"System saved" !
"June 4, 2008 -> 23:36:55"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'private' !
fractionFor: index <Integer> ^<Float>
	
	^total = 0
		ifTrue: [0.0d]
		ifFalse: [(data at: index) asFloat / total]
	! !

"June 4, 2008 -> 23:54:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
objectMemorySize

	^{{self primitiveObjectMemorySize}}! !

"June 4, 2008 -> 23:54:53"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'private' !
fractionFor: index <Integer> ^<Float>
	
	^total = 0
		ifTrue: [0.0d]
		ifFalse: [(data at: index) asFloat / total]! !

"June 4, 2008 -> 23:55:46"!

! (Delta mirrorFor: #SystemMonitorData) methodsFor: 'accessing' !
objectMemory

	^VM objectMemorySize! !

"June 4, 2008 -> 23:56:8"!

"System saved" !
"June 4, 2008 -> 23:57:17"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private  - initialization' !
entriesDo: blk <[Str, [^Float]]>
	"Iterates over all entries for the table"
	
	blk value: 'Optimized code'		value: [ self monitorData inCompiledCode ].
	blk value: 'Interpreted code'		value: [ self monitorData inInterpretedCode ].
	blk value: 'PIC code' 					value: [ self monitorData inPICCode ].
	blk value: 'Compiling' 					value: [ self monitorData inCompiler ].
	blk value: 'Garbage Collector'	value: [ self monitorData inGarbageCollector ].
	blk value: 'Stub code'					value: [ self monitorData inStubCode ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ]! !

"June 4, 2008 -> 23:57:27"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private' !
buildBareVisualTop: top <Boolean> ^ <Visual>

	self table: (Table rows: 8 columns: 2).
	self addConstantEntriesToTable.
	self startUpdateProcess.
	^self table imbeddedVisual" withBorder: (Border standard3DWithColor: Paint gray raised: false)"
! !

"June 4, 2008 -> 23:58:58"!

"System saved" !
"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #SystemMonitor) methodsFor: 'private  - initialization' !
entriesDo: blk <[Str, [^Float]]>
	"Iterates over all entries for the table"
	
	blk value: 'Optimized code'		value: [ self monitorData inCompiledCode ].
	blk value: 'Interpreted code'		value: [ self monitorData inInterpretedCode ].
	blk value: 'PIC code' 					value: [ self monitorData inPICCode ].
	blk value: 'Compiling' 					value: [ self monitorData inCompiler ].
	blk value: 'Garbage Collector'	value: [ self monitorData inGarbageCollector ].
	blk value: 'Stub code'					value: [ self monitorData inStubCode ].
	blk value: 'Primitives/DLL'			value: [ self monitorData inVM ].
	blk value: 'Object Memory'		value: [ self monitorData objectMemory ]! !

"June 6, 2008 -> 0:37:28"!

Delta define: #Model as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:28"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Model' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
errorLog
	^SUnitNameResolver defaultLogDevice! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResult

	self errorLog cr;cr; show: '==== SUnit ======== Start ===='.
	self
		showResultSummary;
		showResultDefects.
	self errorLog cr; show: '==== SUnit ========== End ===='; cr.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultDefects

	(self result failureCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ----- Failures ----'.
			self result failures do: [:failure |
				self errorLog crtab; show: failure printString]].
	(self result errorCount > 0)
		ifTrue: [
			self errorLog cr; show: '---- SUnit ------- Errors ----'.
			self result errors do: [:error |
				self errorLog crtab; show: error printString]].! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'test processing' !
showResultSummary

	| message summary |
	message := (self result runCount = self result correctCount)
		ifTrue: [self successMessage]
		ifFalse: [self failureMessage].
	self errorLog crtab; show: message.
	summary :=
		self result runCount printString, ' run, ',
		self result failureCount printString, ' failed, ',
		self result errorCount printString, ' errors (',
		self duration printString, ' ms)'.
	self errorLog crtab; show: summary.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugButtonLabel
        ^ 'DEBUG'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
debugState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Color red! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Color yellow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Color green! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonLabel
        ^ 'REFRESH'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
resetColor
        ^ Color white! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonColor
        ^ Color yellow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonLabel
        ^ 'RUN ALL'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonState

        ^true! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runOneButtonLabel
        ^ 'RUN'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
windowLabel

        ^'SUnit Camp Smalltalk ', TestCase sunitVersion, ' Test Runner'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        Cursor execute showWhile:
                [testSuite notNil
                        ifTrue:
                                [self runWindow.
                                result _ testSuite asSymbol sunitAsClass suite run.
                                self updateWindow: result]
                        ifFalse:
                                [self runWindow.
                                self displayPassFail: 'No Test Suite Selected']]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runTests
	Cursor execute showWhile:[
		self runWindow.
		result := TestResult new.
		self suite tests do:[:each|
			self displayPassFail: 'Running ', each name.
			World displayWorld.
			each run: result.
			self updateWindow: result.
		].
	].
! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedErrorTest
        ^selectedErrorTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedFailureTest

        ^selectedFailureTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite

        ^selectedSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
openAsMorph
        "TestRunner new openAsMorph"
        "=== build the parts ... ==="
        | topWindow runButton errorsList failuresList runOneButton
refreshButton |
        Smalltalk isMorphic
                ifFalse: [^self open].
        (topWindow _ SystemWindow labelled: self windowLabel) model: self.
        runButton _ PluggableButtonMorph
                                on: self
                                getState: #runButtonState
                                action: #runTests
                                label: #runButtonLabel.
        runButton color: self runButtonColor.
        runButton onColor: self runButtonColor offColor: self runButtonColor.
        runOneButton _ PluggableButtonMorph
                                on: self
                                getState: #runButtonState
                                action: #runOneTest
                                label: #runOneButtonLabel.
        runOneButton color: self runButtonColor.
        runOneButton onColor: self runButtonColor offColor: self
runButtonColor.
        refreshButton _ PluggableButtonMorph
                                on: self
                                getState: #refreshButtonState
                                action: #refreshTests
                                label: #refreshButtonLabel.
        refreshButton color: self runButtonColor.
        refreshButton onColor: self runButtonColor offColor: self
runButtonColor.
        passFailText _ PluggableTextMorph
                                on: self
                                text: #passFail
                                accept: nil.
        passFailText retractable: true.
        detailsText _ PluggableTextMorph
                                on: self
                                text: #details
                                accept: nil.
        detailsText retractable: true.
        testsList _ PluggableListMorph
                                on: self
                                list: #tests
                                selected: #selectedSuite
                                changeSelected: #selectedSuite:.
        testsList autoDeselect: false.
        failuresList _ PluggableListMorph
                                on: self
                                list: #failuresList
                                selected: #selectedFailureTest
                                changeSelected: #debugFailureTest:.
        errorsList _ PluggableListMorph
                                on: self
                                list: #errorsList
                                selected: #selectedErrorTest
                                changeSelected: #debugErrorTest:.
        "=== assemble the whole ... ==="
        topWindow addMorph: refreshButton frame: (0.0 @ 0.0 extent: 0.2 @ 0.2).
        topWindow addMorph: testsList frame: (0.2 @ 0.0 extent: 0.6 @ 0.2).
        topWindow addMorph: runOneButton frame: (0.8 @ 0.0 extent: 0.2 @ 0.1).
        topWindow addMorph: runButton frame: (0.8 @ 0.1 extent: 0.2 @ 0.1).
        topWindow addMorph: passFailText frame: (0.0 @ 0.2 extent: 1.0 @ 0.1).
        topWindow addMorph: detailsText frame: (0.0 @ 0.3 extent: 1.0 @ 0.1).
        topWindow addMorph: failuresList frame: (0.0 @ 0.4 extent: 1.0 @ 0.3).
        topWindow addMorph: errorsList frame: (0.0 @ 0.7 extent: 1.0 @ 0.3).
        "=== open it ... ==="
        topWindow openInWorldExtent: 400 @ 200.
        self refreshWindow.
        ^ topWindow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
details

        ^details! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errors

        ^errors! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
errorsList

        ^self errors collect: [:error | error printString]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
failures

        ^failures! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
formatTime: aTime
        aTime hours > 0 ifTrue: [^aTime hours printString , 'h'].
        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].
        ^aTime seconds printString , ' sec'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
passFail

        ^passFail! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
suite
        ^TestCase buildSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests
        ^ tests! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
timeSinceLastPassAsString: aResult
        (lastPass isNil or: [aResult hasPassed not]) ifTrue: [^ ''].
        ^ ', ' , (self formatTime: (Time now subtractTime: lastPass)) , '
since last Pass'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayDetails: aString
        details := aString.
        self changed: #details! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayErrors: anOrderedCollection

        errors := anOrderedCollection.
        self changed: #errorsList! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayFailures: anOrderedCollection

        failures := anOrderedCollection.
        self changed: #failuresList! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
displayPassFail: aString
        passFail := aString.
        self changed: #passFail! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
failuresList

	^self failures collect: [:failure | failure printString]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow
        passFailText isMorph
                ifTrue:
                        [passFailText color: Color white.
                        detailsText color: Color white]
                ifFalse:
                        [passFailText insideColor: Color white.
                        detailsText insideColor: Color white].
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'N/A'.
        self displayDetails: '...'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
runWindow
        passFailText isMorph
                ifTrue:
                        [passFailText color: Color white.
                        detailsText color: Color white]
                ifFalse:
                        [passFailText insideColor: Color white.
                        detailsText insideColor: Color white].
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'Running...'.
        self displayDetails: '...'! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult
        self displayDetails: aTestResult printString , (self
timeSinceLastPassAsString: aTestResult).
        aTestResult hasPassed ifTrue: [lastPass _ Time now]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateErrors: aTestResult

        self displayErrors: aTestResult errors! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateFailures: aTestResult

        self displayFailures: aTestResult failures asOrderedCollection! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor
        passFailText isMorph
                ifTrue:
                        [passFailText color: aColor.
                        detailsText color: aColor]
                ifFalse:
                        [passFailText insideColor: aColor.
                        detailsText insideColor: aColor]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult
        | message |
        message _ aTestResult hasPassed
                                ifTrue: ['Pass']
                                ifFalse: ['Fail'].
        self displayPassFail: message! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult errors size + aTestResult failures size = 0
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult errors size > 0
                                ifTrue: [self updatePartColors: self
errorColor]
                                ifFalse: [self updatePartColors: self
failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
new

        ^super new initialize! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"TestRunner open"
        ^super new initialize openAsMorph! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
        tests := (TestCase allSubclasses collect: [:each | each name])
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugErrorTest: anInteger
        selectedErrorTest := anInteger.				"added rew"
        selectedFailureTest := 0.							"added rew"
        self changed: #selectedFailureTest.		"added rew"
        self changed: #selectedErrorTest.			"added rew"
        (anInteger ~= 0)
                ifTrue: [(result errors at: anInteger) debug]! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugFailureTest: anInteger

        (anInteger ~= 0)
                ifTrue: [(self failures at: anInteger) debugAsFailure].

        selectedFailureTest := anInteger.
        selectedErrorTest := 0.
        self changed: #selectedErrorTest.
        self changed: #selectedFailureTest! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
selectedSuite: anInteger
        anInteger ~= 0 ifTrue: [testSuite := tests at: anInteger].
        selectedSuite := selectedSuite = anInteger
                                        ifTrue:[0]
                                        ifFalse:[anInteger].
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew" 
        self changed: #selectedSuite! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses collect: [:each | each name])
		asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 6, 2008 -> 0:37:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
openAsMorph
        "TestRunner new openAsMorph"
        "=== build the parts ... ==="
        | topWindow runButton errorsList failuresList runOneButton refreshButton |
        Smalltalk isMorphic
                ifFalse: [^self open].
        (topWindow := SystemWindow labelled: self windowLabel) model: self.
        runButton := PluggableButtonMorph
                               		on: self
                                	getState: #runButtonState
                                	action: #runTests
                                	label: #runButtonLabel.
        runButton color: self runButtonColor.
        runButton onColor: self runButtonColor offColor: self runButtonColor.
        runOneButton := PluggableButtonMorph
                                			on: self
                                			getState: #runButtonState
                                			action: #runOneTest
                                			label: #runOneButtonLabel.
        runOneButton color: self runButtonColor.
        runOneButton onColor: self runButtonColor offColor: self runButtonColor.
        refreshButton := PluggableButtonMorph
                                			on: self
                                			getState: #refreshButtonState
                                			action: #refreshTests
                                			label: #refreshButtonLabel.
        refreshButton color: self runButtonColor.
        refreshButton onColor: self runButtonColor offColor: self runButtonColor.
        passFailText := PluggableTextMorph
                                			on: self
                                			text: #passFail
                                			accept: nil.
        passFailText retractable: true.
        detailsText := PluggableTextMorph
                                		on: self
                                		text: #details
                                		accept: nil.
        detailsText retractable: true.
        testsList := PluggableListMorph
                                on: self
                                list: #tests
                                selected: #selectedSuite
                                changeSelected: #selectedSuite:.
        testsList autoDeselect: false.
        failuresList := PluggableListMorph
                                		on: self
                                		list: #failuresList
                                		selected: #selectedFailureTest
                                		changeSelected: #debugFailureTest:.
        errorsList := PluggableListMorph
                                	on: self
                                	list: #errorsList
                                	selected: #selectedErrorTest
                                	changeSelected: #debugErrorTest:.
        "=== assemble the whole ... ==="
        topWindow addMorph: refreshButton frame: (0.0 @ 0.0 extent: 0.2 @ 0.2).
        topWindow addMorph: testsList frame: (0.2 @ 0.0 extent: 0.6 @ 0.2).
        topWindow addMorph: runOneButton frame: (0.8 @ 0.0 extent: 0.2 @ 0.1).
        topWindow addMorph: runButton frame: (0.8 @ 0.1 extent: 0.2 @ 0.1).
        topWindow addMorph: passFailText frame: (0.0 @ 0.2 extent: 1.0 @ 0.1).
        topWindow addMorph: detailsText frame: (0.0 @ 0.3 extent: 1.0 @ 0.1).
        topWindow addMorph: failuresList frame: (0.0 @ 0.4 extent: 1.0 @ 0.3).
        topWindow addMorph: errorsList frame: (0.0 @ 0.7 extent: 1.0 @ 0.3).
        "=== open it ... ==="
        topWindow openInWorldExtent: 400 @ 200.
        self refreshWindow.
        ^ topWindow! !

"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #TestRunner as: (
(Class subclassOf: 'Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess') !


"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]
! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	self needsNewGCProcess
		ifTrue: [GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
startGCProcess

	self needsNewGCProcess
		ifTrue: [self initializeGCProcess]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
initializeGCProcess

GCProcess := [| delay |
														delay := Delay forMilliseconds: 500.
														[delay wait.
														VM objectMemorySize > 0.95
															ifTrue: [VM collectGarbage]] repeat] fork! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
needsNewGCProcess

	^GCProcess isNil
		or: [(GCProcess running
					or: [GCProcess suspended]) not]! !

"June 6, 2008 -> 0:37:29"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
initializeGCProcess

GCProcess := [| delay |
							delay := Delay forMilliseconds: 500.
							[delay wait.
							VM objectMemorySize > 0.95
								ifTrue: [VM collectGarbage]] repeat] fork! !

"June 6, 2008 -> 0:37:30"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
stopGCProcess

	self needsNewGCProcess
		ifFalse: [GCProcess terminate]! !

"June 6, 2008 -> 0:42:10"!

"System saved" !
"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #Application) methodsFor: 'launching' !
launch ^<Window>

	| win <Window> sess <Session> winCreated <Semaphore> 
		notCreated |
	winCreated := Semaphore new.
	notCreated := false.
	sess := Session in: Screen default
		do: [ :sess <Session> |
					winCreated wait.
					notCreated ifFalse: [	win makeActive show]].
	[win := self windowIn: sess.
	winCreated signal.
	sess sessionWindow: win]
		ifCurtailed: [notCreated := true.
								winCreated signal].
	^win! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox new! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
							asSortedCollection:[:a :b| a name asString <= b name asString].
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #Application) methodsFor: 'launching' !
launch ^<Window>

	| win <Window> sess <Session> winCreated <Semaphore> 
		notCreated |
	winCreated := Semaphore new.
	notCreated := false.
	sess := Session in: Screen default
		do: [ :sess <Session> |
					winCreated wait.
					notCreated ifFalse: [	win makeActive show]].
	[win := self windowIn: sess.
	winCreated signal.
	sess sessionWindow: win]
		ifCurtailed: [notCreated := true.
								winCreated signal].
	^win! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	^ListBox forSingleSelection! !

"June 7, 2008 -> 3:36:7"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: TextView new
																											with: TextView new))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:36:20"!

"System saved" !
"June 7, 2008 -> 3:52:47"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: TextView forString imbeddedVisual
																											with: TextView forString imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:57:35"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^(TextView forString
			model: '';
			yourself)! !

"June 7, 2008 -> 3:58:8"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: (self textViewOn: '') imbeddedVisual
																											with: (self textViewOn: '') imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labelled: #'1' action: [:b|])
															with: (Button labelled: #'2' action: [:b|])
															with: (Button labelled: #'3' action: [:b|])
															with: (Button labelled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:58:48"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container |
	testsRow := Row holding: (OrderedCollection
															with: ListBox forSingleSelection
															with: ListBox forSingleSelection
															with: (Column holding: (OrderedCollection
																											with: (self textViewOn: '') imbeddedVisual
																											with: (self textViewOn: '') imbeddedVisual))).
	buttonBar := Row holding: (OrderedCollection
															with: (Button labeled: #'1' action: [:b|])
															with: (Button labeled: #'2' action: [:b|])
															with: (Button labeled: #'3' action: [:b|])
															with: (Button labeled: #'4' action: [:b|])).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	^container! !

"June 7, 2008 -> 3:59:20"!

"System saved" !
"June 7, 2008 -> 4:6:30"!

"System saved" !
"June 7, 2008 -> 14:56:46"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: (Row holding: (OrderedCollection
																																	with: self listbox
																																	with: self listbox)))
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: (self textViewOn: '') 
																																			with: (self textViewOn: ''))))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	self refreshWindow.
	^container! !

"June 7, 2008 -> 14:57:0"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
        tests := (TestCase allSubclasses "collect: [:each | each name]")
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 14:57:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^(TextView forString
			isMultiLine: true;
			model: '';
			yourself)
			imbeddedVisual with3DBorder! !

"June 7, 2008 -> 14:57:36"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listbox

	^ListBox forSingleSelection with3DBorder! !

"June 7, 2008 -> 14:58:0"!

"System saved" !
"June 7, 2008 -> 15:40:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	passFailText := self textViewOn: ''.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: self listbox)
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: passFailText imbeddedVisual with3DBorder
																																			with: self listbox
																																			with: self listbox)))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).
	"container changeAllocation: (Rectangle
																	corner: 0@0
																	corner: 400@200)
						at: 0@0."
	"self refreshWindow."
	^container! !

"June 7, 2008 -> 15:40:54"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aString

	^TextView forString
			isMultiLine: true;
			model: '';
			yourself! !

"June 7, 2008 -> 15:41:20"!

"System saved" !
"June 7, 2008 -> 17:32:59"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer textEqualizer resultsRow resultsColumn |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (self listbox 
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^Row holding: (OrderedCollection
										with: testsColumn
										with: resultsColumn)! !

"June 7, 2008 -> 17:33:19"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
oldbuildBareVisualTop: top

	| testsRow buttonBar container equalizer buttonEqualizer |
	equalizer := Equalizer new.
	buttonEqualizer := Equalizer new.
	passFailText := self textViewOn: ''.
	testsRow := Row holding: (OrderedCollection
															with: (equalizer for: (self listbox 
																									naturalHeight: 300;
																									naturalWidth: 200;
																									yStretchy: true;
																									xStretchy: true;
																									yourself) with3DBorder)
															with: (equalizer for: (Column holding: (OrderedCollection
																																			with: passFailText imbeddedVisual with3DBorder
																																			with: self listbox with3DBorder
																																			with: self listbox with3DBorder)))).
	buttonBar := Row holding: (OrderedCollection
															with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																															action: [:b|]))
															with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	container := Column holding: (OrderedCollection
																with: testsRow
																with: buttonBar).

	"self refreshWindow."
	^ApplicationInterceptor
			for: container
			application: self! !

"June 7, 2008 -> 17:33:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated
"self halt."
	"self inSessionProcessDo: [visual allocation: (Rectangle
																												corner: 0@0
																												corner: 400@200)
																	at: 0@0]."
	"self refreshWindow."! !

"June 7, 2008 -> 17:33:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
listbox

	^ListBox forSingleSelection! !

"June 7, 2008 -> 17:34:24"!

"System saved" !
"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:32:58"!

Delta define: #TestRunner as: (
(Class subclassOf: 'NotifyingObject mixin |> Application' instanceVariables: 'result details passFail failures errors tests testSuite passFailText detailsText lastPass testsList selectedFailureTest selectedErrorTest selectedSuite ')) !


"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow
        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: 'N/A'.
        self displayDetails: '...'! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer textEqualizer resultsRow resultsColumn |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (self listbox 
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

	self refreshWindow! !

"June 7, 2008 -> 19:33:33"!

! (Delta mirrorFor: #TextView) methodsFor: 'private-initialization' !
initialize

	super initialize.
	self setPainter: self defaultPainter copy.
	self autoIndent: true.
	self maxUndo: 0.
	self isMultiLine: true.
	self monoPainter: false.
	self modelOutOfDate: false.
	self oneShotModel: false.
	self scrollable: false.! !

"June 7, 2008 -> 22:6:20"!

"System saved" !
"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'NotifyingObject' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) classSide methodsFor: 'instance creation' !
on: model items: itemSelector selected: accessor select: mutator

	^self new
			on: model
			items: itemSelector
			select: accessor
			select: mutator
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: model items: selector selected: accessor select: mutator

	model addDependent: self.
	"itemSelector := selector."
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	| view |
	view := ListBox forSingleSelection.
	aModel addDependent: self.
	itemBlock := [view stringList: (aModel perform: selector)].
	selectionBlock := [view selections: (OrderedCollection
																		with: (aModel perform: accessor))].
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
changed: aspect

	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	itemAspect := selector.
	selectionAspect := accessor.
	selectionMutator := mutator.
	
	aModel addDependent: self.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	itemAspect := selector.
	selectionAspect := accessor.
	selectionMutator := mutator.
	
	model addDependent: self.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first]
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections first].
	^view
	! !

"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemBlock " a block that when evaluated updates the items in the view "
selectBlock " a block that informs the model when an item is selected "
selectionBlock " a block that queries the model for its selection " 
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "
selectionMutator " a mutator used to change the selection in the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

Delta define: #ListModel as: (
(Class subclassOf: 'Object' instanceVariables: 'view " the list box displaying the list items "
model " the model that provides the list items "
itemAspect " a selector used to retrieve the item strings from the model "
selectionAspect " a selector used to retrieve the selection from the model "')) !


"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selection
							select: #select:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																															action: [:b|]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																															action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #ListModel) classSide methodsFor: 'instance creation' !
on: model items: itemSelector selected: accessor select: mutator

	^self new
			on: model
			items: itemSelector
			selected: accessor
			select: mutator
	! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selection
							select: #select:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
		Transcript show: 'Refresh tests';cr.
        tests := (TestCase allSubclasses "collect: [:each | each name]")
		asSortedCollection:[:a :b| a name asString <= b name asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:27"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests
Transcript show: 'tests';cr.
        ^ tests! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
changed: aspect
Transcript show: ('Changed ', aspect); cr.
	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
Transcript show: 'changed ', attribute.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
Transcript show: ('changed ', attribute); cr.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>
self halt.
	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
update: aspect
Transcript show: ('Changed ', aspect); cr.
	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #NotifyingObject) methodsFor: 'private' !
changed: attribute <Object>

	self changed: attribute with: nil! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
tests

        ^ tests! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests
		Transcript show: 'Refresh tests';cr.
        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a asString <= b asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := (TestCase allSubclasses collect: [:each | each name])
							asSortedCollection:[:a :b| a asString <= b asString].
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'notification' !
update: aspect

	aspect == itemAspect
		ifTrue: [^view stringList: (model perform: itemAspect)].
	aspect == selectionAspect
		ifTrue: [^view selections: (OrderedCollection
																with: (model perform: selectionAspect))]! !

"June 7, 2008 -> 22:58:28"!

(Delta mirrorFor: #ListModel) removeMethod: #changed: ifAbsent: [] !


"June 7, 2008 -> 22:58:28"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 7, 2008 -> 22:58:43"!

"System saved" !
"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b|]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b|]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #Cursor) classSide methodsFor: 'instance creation' !
execute

	^self wait! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: ''.
	detailsText := self textViewOn: ''.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runOneTest
        "Cursor execute showWhile:
                ["
	testSuite notNil
		ifTrue: [self runWindow.
						result := testSuite asSymbol sunitAsClass suite run.
						self updateWindow: result]
 		ifFalse: [self runWindow.
						self displayPassFail: 'No Test Suite Selected']
       "]"! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
runTests
	"Cursor execute showWhile:["
	self runWindow.
	result := TestResult new.
	self suite tests
		do:[:each|
				self displayPassFail: 'Running ', each name.
				Processor yield.
				each run: result.
				self updateWindow: result]
	"]."
! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailText
        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailText.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow

        self refreshWindow: 'N/A'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
runWindow

        self refreshWindow:  'Running...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailText

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailText.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        passFailText paint: Paint white.
        detailsText paint: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult errors size + aTestResult failures size = 0
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult errors size > 0
									ifTrue: [self updatePartColors: self errorColor]
									ifFalse: [self updatePartColors: self failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint green! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint yellow! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint red! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText paint: aColor.
	detailsText color: aColor! !

"June 7, 2008 -> 23:28:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText paint: aColor.
	detailsText paint: aColor! !

"June 7, 2008 -> 23:28:54"!

"System saved" !
"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult

	| message |
	message := aTestResult hasPassed
								ifTrue: ['Pass']
								ifFalse: ['Fail'].
	self displayPassFail: message! !

"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult

	| detailString |
	detailString := aTestResult printString , (self timeSinceLastPassAsString: aTestResult).
	self displayDetails: detailString.
	aTestResult hasPassed
		ifTrue: [lastPass := Time now]! !

"June 7, 2008 -> 23:36:5"!

! (Delta mirrorFor: #Time) methodsFor: 'arithmetic' !
subtractTime: amt <Date|Time> ^<Instance>

	^self actualClass fromSeconds: self asSeconds - amt asSeconds! !

"June 7, 2008 -> 23:36:26"!

"System saved" !
"June 8, 2008 -> 1:17:40"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePassFail: aTestResult

	| message |
	message := aTestResult hasPassed
								ifTrue: ['Pass']
								ifFalse: ['Fail'].
	self displayPassFail: message! !

"June 8, 2008 -> 1:17:40"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateDetails: aTestResult

	| detailString |
	detailString := aTestResult printString , (self timeSinceLastPassAsString: aTestResult).
	self displayDetails: detailString.
	aTestResult hasPassed
		ifTrue: [lastPass := Time now]! !

"June 8, 2008 -> 1:17:41"!

! (Delta mirrorFor: #Time) methodsFor: 'arithmetic' !
subtractTime: amt <Date|Time> ^<Instance>

	^self actualClass fromSeconds: self asSeconds - amt asSeconds! !

"June 8, 2008 -> 1:23:1"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'accessing' !
formatTime: aTime
        aTime hour > 0 ifTrue: [^aTime hour printString , 'h'].
        aTime minutes > 0 ifTrue: [^aTime minutes printString , 'min'].
        ^aTime second printString , ' sec'! !

"June 8, 2008 -> 1:27:0"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 8, 2008 -> 1:27:40"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel text: selector

	^self new
			on: aModel
			text: selector! !

"June 8, 2008 -> 1:28:9"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel text: aspect

	^self new
			on: aModel
			text: aspect! !

"June 8, 2008 -> 1:29:47"!

Delta define: #TextModel as: (
(Class subclassOf: 'Object' instanceVariables: 'model " the model that provides the contents "
aspect "  the aspect of the model "
view " the view to be updated with the contents "')) !


"June 8, 2008 -> 1:30:46"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel text: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect! !

"June 8, 2008 -> 1:32:18"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel text: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:33:24"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [view model: (model perform: aspect)]! !

"June 8, 2008 -> 1:34:23"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual)
																			with: (textEqualizer for: detailsText imbeddedVisual)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 1:34:49"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
textViewOn: aspect

	^TextModel
			on: self
			aspect: aspect! !

"June 8, 2008 -> 1:36:44"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiline: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:36:47"!

! (Delta mirrorFor: #TextModel) classSide methodsFor: 'instance creation' !
on: aModel aspect: aspect

	^self new
			on: aModel
			aspect: aspect! !

"June 8, 2008 -> 1:37:39"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: ''.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 1:40:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: detailsText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: resultsRow)).
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 1:44:5"!

"System saved" !
"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [Transcript show: ('updated: ', aspect); cr.
					view model: (model perform: aspect)]! !

"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TextModel) classSide removeMethod: #on:text: ifAbsent: [] !


"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TextModel) removeMethod: #on:text: ifAbsent: [] !


"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: 'blank'.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: ["Transcript show: ('updated: ', aspect); cr."
					view model: (model perform: aspect).
					view visual invalidate]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [Transcript show: ('updated: ', aspect, ',', (model perform: aspect)); cr.
					view model: (model perform: aspect).
					view visual invalidate]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: 'blank';
		paint: Paint black.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 18:19:37"!

(Delta mirrorFor: #TestRunner)
comment: 
'(TestRunner new launch)'!


"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextView) methodsFor: 'accessing' !
paint: p <Paint>
Transcript cr. p  printOn: Transcript.
	self painter paint: p! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestSuite) methodsFor: 'Running' !
run: aResult 
	self tests do: [:each | 
		self sunitChanged: each.
		Processor yield.
		each run: aResult]
			! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
resetColor
        ^ Color black! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        "passFailText paint: Paint white.
        detailsText paint: Paint white."
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextModel) methodsFor: 'notification' !
update: anAspect

	anAspect == aspect
		ifTrue: [view model: (model perform: aspect)]! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TextView) methodsFor: 'accessing' !
paint: p <Paint>

	self painter paint: p! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated
Transcript show: 'allocated'.
	self refreshWindow! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'notificaition' !
visualAllocated

"	self refreshWindow"! !

"June 8, 2008 -> 18:19:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: passFailText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: detailsText imbeddedVisual with3DBorder)
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 18:33:37"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
errorColor
        ^ Paint red! !

"June 8, 2008 -> 18:33:45"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
failColor
        ^ Paint yellow! !

"June 8, 2008 -> 18:37:5"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateWindow: aTestResult
        aTestResult hasPassed
                ifTrue: [self updatePartColors: self passColor]
                ifFalse: [aTestResult hasErrors
									ifTrue: [self updatePartColors: self errorColor]
									ifFalse: [self updatePartColors: self failColor]].
        self updatePassFail: aTestResult.
        self updateDetails: aTestResult.
        self updateFailures: aTestResult.
        self updateErrors: aTestResult! !

"June 8, 2008 -> 18:41:57"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
passColor
        ^ Paint green! !

"June 8, 2008 -> 23:20:0"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
frameWithBorderAndBackdrop: visual

	^(visual with3DBorder)
			backdrop: (Painter new);
			yourself! !

"June 8, 2008 -> 23:21:35"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackDrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackDrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:24:59"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updatePartColors: aColor

	passFailText visual backgroundPainter paint: aColor.
	detailsText visual backgroundPainter paint: aColor! !

"June 8, 2008 -> 23:25:56"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:28:31"!

! (Delta mirrorFor: #TextModel) methodsFor: 'initialization' !
on: aModel aspect: anAspect

	view := TextView forString.
	view
		isMultiLine: true;
		model: '';
		paint: Paint black.
	model := aModel.
	aspect := anAspect.
	model addDependent: self.
	^view! !

"June 8, 2008 -> 23:31:31"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshWindow: passFailString

        self updatePartColors: Paint white.
        self updateErrors: TestResult new.
        self updateFailures: TestResult new.
        self displayPassFail: passFailString.
        self displayDetails: '...'! !

"June 8, 2008 -> 23:40:41"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
buildTests

	^(TestCase allSubclasses collect: [:each | each name])
			asSortedCollection:[:a :b| a asString <= b asString]! !

"June 8, 2008 -> 23:40:54"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
refreshTests

        tests := self buildTests.
        self changed: #tests.
        testSuite := nil.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.
        self changed: #selectedFailureTest.             "added rew"
        self changed: #selectedErrorTest.               "added rew"
        self changed: #selectedSuite.
        self refreshWindow! !

"June 8, 2008 -> 23:41:6"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'initialize' !
initialize
        result := TestResult new.
        passFail := 'N/A'.
        details := '...'.
        failures := OrderedCollection new.
        errors := OrderedCollection new.
        tests := self buildTests.
        selectedSuite := 0.
        selectedFailureTest := 0.
        selectedErrorTest := 0.! !

"June 8, 2008 -> 23:42:42"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:44:4"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #selectedFailureTest.
	self changed: #selectedErrorTest.
	self changed: #selectedSuite.
	self refreshWindow! !

"June 8, 2008 -> 23:44:55"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'updating' !
updateAll

	self changed: #tests.
	self changed: #details.
	self changed: #passFail.
	self refreshWindow! !

"June 8, 2008 -> 23:49:55"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: (testList
																														"naturalHeight: 300;
																														naturalWidth: 150;
																														yStretchy: true;
																														xStretchy: true;"
																														yourself) with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 8, 2008 -> 23:53:32"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:1:58"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:2:41"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:9:11"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view painter: (Painter new font: (Font forSpec: (FontSpec new points: 81; typeface: 'Times Roman')); yourself)
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:9:34"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view painter: Painter new.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:20:35"!

! (Delta mirrorFor: #ListModel) methodsFor: 'initialization' !
on: aModel items: selector selected: accessor select: mutator

	view := ListBox forSingleSelection.
	model := aModel.
	model addDependent: self.
	itemAspect := selector.
	selectionAspect := accessor.
	view onSelChange: [:lb | aModel	
														perform: mutator
														with: lb selections anElement].
	^view
	! !

"June 9, 2008 -> 0:22:9"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	testList painter font: self font.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:22:33"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
font

	^Font forSpec: (FontSpec new points: 8; typeface: 'Times Roman')! !

"June 9, 2008 -> 0:28:34"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: self listbox with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: self listbox with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:30:49"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"TestRunner open"
        ^super new launch! !

"June 9, 2008 -> 0:31:17"!

! (Delta mirrorFor: #TestRunner) classSide methodsFor: 'instance creation' !
open
	"(TestRunner open)"
        ^super new launch! !

"June 9, 2008 -> 0:32:59"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:35:12"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	self refreshWindow.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:35:24"!

(Delta mirrorFor: #TestRunner)
comment: 
'(TestRunner open)'!


"June 9, 2008 -> 0:38:44"!

"System saved" !
"June 9, 2008 -> 0:39:34"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'processing' !
debugFailureTest: anInteger

        (anInteger ~= 0)
                ifTrue: [[(self failures at: anInteger) debugAsFailure] fork].

        selectedFailureTest := anInteger.
        selectedErrorTest := 0.
        self changed: #selectedErrorTest.
        self changed: #selectedFailureTest! !

"June 9, 2008 -> 0:40:16"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 9, 2008 -> 0:41:8"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:41:24"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable
	self halt.
	self deny: Halt new isResumable! !

"June 9, 2008 -> 0:41:43"!

! (Delta mirrorFor: #HaltTest) methodsFor: 'Testing' !
testShouldBeResumable

	self assert: Halt new isResumable! !

"June 9, 2008 -> 0:43:46"!

! (Delta mirrorFor: #TestResult) methodsFor: 'Running' !
runCase: aTestCase

	| testCasePassed |

	testCasePassed :=
		[[aTestCase runCase.
			true]
				sunitOn: self class failure
				do: [:signal |
						self failures add: aTestCase.
						signal sunitExitWith: false]]
							sunitOn: self class error
							do: [:signal |
									self errors add: aTestCase.
									signal sunitExitWith: false].

	testCasePassed
		ifTrue: [self passed add: aTestCase]
			! !

"June 9, 2008 -> 0:44:29"!

"System saved" !
"June 9, 2008 -> 0:47:16"!

(Delta mirrorFor: #TestRunner) removeMethod: #oldbuildBareVisualTop: ifAbsent: [] !


"June 9, 2008 -> 0:47:19"!

(Delta mirrorFor: #TestRunner) removeMethod: #openAsMorph ifAbsent: [] !


"June 9, 2008 -> 0:47:49"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'interface opening' !
buildBareVisualTop: top

	| testsColumn failureColumn errorColumn listEqualizer buttonEqualizer
	  textEqualizer resultsRow resultsColumn testList errorsList failuresList |
	listEqualizer := Equalizer forX.
	buttonEqualizer := Equalizer forY.
	textEqualizer := Equalizer forX.
	passFailText := self textViewOn: #passFail.
	detailsText := self textViewOn: #details.
	testList := ListModel
							on: self
							items: #tests
							selected: #selectedSuite
							select: #selectedSuite:.
	failuresList := ListModel
									on: self
									items: #failuresList
									selected: #selectedFailureTest
									select: #debugFailureTest:.
	errorsList := ListModel
									on: self
									items: #errorsList
									selected: #selectedErrorTest
									select: #debugErrorTest:.
	testsColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: testList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self refreshButtonLabel
																																		action: [:b| self refreshTests]))).
	failureColumn := Column holding: (OrderedCollection
																		with: (listEqualizer for: failuresList with3DBorder)
																		with: (buttonEqualizer for: (Button labeled: self runButtonLabel
																																		action: [:b| self runTests]))).
	errorColumn := Column holding: (OrderedCollection
																			with: (listEqualizer for: errorsList with3DBorder)
																			with: (buttonEqualizer for: (Button labeled: self runOneButtonLabel
																																			action: [:b| self runOneTest]))).
	resultsRow := Row holding: (OrderedCollection
																with: failureColumn
																with: errorColumn).
	resultsColumn := Column holding: (OrderedCollection
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: passFailText imbeddedVisual))
																			with: (textEqualizer for: (self frameWithBorderAndBackdrop: detailsText imbeddedVisual))
																			with: (textEqualizer for: resultsRow)).
	self updateAll.
	^ApplicationInterceptor
			for: (Row holding: (OrderedCollection
													with: testsColumn
													with: resultsColumn))
			application: self! !

"June 9, 2008 -> 0:48:2"!

(Delta mirrorFor: #TestRunner) removeMethod: #listbox ifAbsent: [] !


"June 9, 2008 -> 0:48:20"!

(Delta mirrorFor: #TestRunner) removeMethod: #resetColor ifAbsent: [] !


"June 9, 2008 -> 0:48:31"!

(Delta mirrorFor: #TestRunner) removeMethod: #runButtonColor ifAbsent: [] !


"June 9, 2008 -> 0:48:52"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
refreshButtonLabel
        ^ 'Refresh'! !

"June 9, 2008 -> 0:49:2"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runButtonLabel
        ^ 'Run All'! !

"June 9, 2008 -> 0:49:10"!

! (Delta mirrorFor: #TestRunner) methodsFor: 'constants' !
runOneButtonLabel
        ^ 'Run'! !

"June 9, 2008 -> 0:51:28"!

(Delta mirrorFor: #TestRunner)
comment: 
'Test runner for SUnit tests. To launch doit on the following:-

	(TestRunner open)'!


"June 9, 2008 -> 0:53:22"!

"System saved" !
"June 10, 2008 -> 10:12:46"!

Delta define: #DoesNotUnderstandFixture as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"June 10, 2008 -> 10:13:40"!

! (Delta mirrorFor: #DoesNotUnderstandFixture) methodsFor: 'error handling' !
doesNotUnderstand: message

	^message! !

"June 10, 2008 -> 10:14:7"!

"System saved" !
"June 11, 2008 -> 21:31:27"!

! (Delta mirrorFor: #DoesNotUnderstandFixture) methodsFor: 'dnu triggers' !
dnuTrigger1

	^self quack! !

"June 11, 2008 -> 21:31:45"!

"System saved" !
"June 14, 2008 -> 22:4:38"!

Delta define: #DoesNotUnderstandTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 14, 2008 -> 22:7:41"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:20"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:34"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownOneArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork.
	self assert: #zork == message selector
			description: 'Wrong selector returned'! !

"June 14, 2008 -> 22:8:37"!

(Delta mirrorFor: #DoesNotUnderstandTest) removeMethod: #testUnknownMethodReturnsResultFromDoesNotUnderstand ifAbsent: [] !


"June 14, 2008 -> 22:9:17"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message args size
			description: 'Wrong number of args'! !

"June 14, 2008 -> 22:9:49"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message arguments size
			description: 'Wrong number of arguments'! !

"June 14, 2008 -> 22:10:25"!

! (Delta mirrorFor: #DoesNotUnderstandTest) methodsFor: 'Testing' !
testUnknownNoArgMethodReturnsResultFromDoesNotUnderstand

	| message |
	message := DoesNotUnderstandFixture new zork: 1.
	self assert: #zork: == message selector
			description: 'Wrong selector returned'.
	self assert: 1 == message arguments size
			description: 'Wrong number of arguments'.
	self assert: 1 == message arguments first
			description: 'Wrong argument returned'! !

"June 14, 2008 -> 22:15:43"!

"System saved" !
"June 15, 2008 -> 18:9:0"!

Delta define: #BlockNLRTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"June 15, 2008 -> 18:10:49"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:12:16"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
nlrWith: value

	self doWith: [^value].
	^2 * value! !

"June 15, 2008 -> 18:12:37"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
doWith: block

	^block value! !

"June 15, 2008 -> 18:14:2"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	1000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:14:12"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	10000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:15:46"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1)
				description: 'Should have returned 1']! !

"June 15, 2008 -> 18:16:42"!

"System saved" !
"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
nlrWith: value with: boolean

	self doWith: [boolean ifTrue: [^value].
							3 * value].
	^2 * value! !

"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		self assert: 1 = (self nlrWith: 1 with: true)
				description: 'Should have returned 1']! !

"June 17, 2008 -> 1:14:5"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:14:36"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	10000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:16:18"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	100000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:16:29"!

! (Delta mirrorFor: #BlockNLRTest) methodsFor: 'Testing' !
testNLRResult

	1000000 timesRepeat: [
		| result |
		result := (self nlrWith: 1 with: true).
		self assert: 1 = result
				description: 'Should have returned 1, but was: ', result printString]! !

"June 17, 2008 -> 1:17:1"!

"System saved" !
"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	[^aValue printString]
		on: Error
		do: [^'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: receiver printString 
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: arg printString 
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	[^aValue printString]
		on: Error
		do: [^'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:42"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: receiver printString 
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: arg printString 
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: ['Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
buildClosedHeader ^ <Visual>

	| selector <Symbol> args <Array[Object]> row <Row[Visual]> |
	
	"Check type of activation"
	self activation isSmalltalk
		ifFalse: [	^(StringGlyph for: 'External activation' painter: self codePainter) asVisual ].

	selector := self activation method enclosingMethod selector.
	args := self activation arguments.
	row := Row[Visual] new.
	
	self activation method isBlockMethod
		ifTrue: [		"Add block parens interspersed with arguments"
							row add: (StringGlyph for: '[' painter: self codePainter) asVisual.
							args do: [ :arg <Object> |
								row add: (StringGlyph for: ':' painter: self selectorPainter) asVisual.
								row add: (self
									buildLabel: (self safePrintString: arg)
									painter: self codePainter
									action: [ (Inspector on: arg) launch ]) ].
							row add: (StringGlyph for: '] in ' painter: self codePainter) asVisual.
							row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
		ifFalse: [	"Add receiver"
							| receiver <Object> |
							receiver := self activation receiver.
							row add: (self
								buildLabel: (self safePrintString: receiver)
								painter: self codePainter
								action: [ (Inspector on: receiver) launch ]).
							row add: (StringGlyph for: '>> ' painter: self codePainter) asVisual.
							"Add selector interspersed with arguments"
							args size = 0
								ifTrue: [		row add: (StringGlyph for: selector painter: self selectorPainter) asVisual ]
								ifFalse: [	| strm <CharacterReadStream> |
													strm := selector readStream.
													args do: [ :arg <Object> |
														row add: (StringGlyph for: (strm upTo: $:), ':' painter: self selectorPainter) asVisual.
														row add: (self
															buildLabel: (self safePrintString: arg)
															painter: self codePainter
															action: [ (Inspector on: arg) launch ]) ]
												]
						].
	^row! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
printString

^1 + 'a'! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'Cannot print instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #ActivationOutliner) methodsFor: 'private' !
safePrintString: aValue

	^[aValue printString]
		on: Error
		do: [:ex|'??instance of ', aValue class name]! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
blockReturn

	|sem|
	sem := Semaphore new.
	[sem signal.
	^nil] fork.
	sem wait! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #StackTraceInspector) methodsFor: 'accessing' !
windowTitle ^ <Str>

	self process processError isNil ifTrue: [^''].
	^self process processError name! !

"August 17, 2008 -> 19:16:43"!

! (Delta mirrorFor: #Test) methodsFor: 'test' !
blockReturn
	[^nil] fork.
	Processor yield! !

"August 17, 2008 -> 19:17:6"!

"System saved" !
"August 24, 2008 -> 9:31:53"!

! (Delta mirrorFor: #Planner) classSide methodsFor: 'add/remove' !
incrementalRemove: c
	"Entry point for retracting a constraint. Remove the given constraint and incrementally update the 
	dataflow graph."
	"Details: Retracting the given constraint may allow some currently unsatisfiable downstream 
	constraint be satisfied. We thus collect a list of unsatisfied downstream constraints and attempt 
	to satisfy each one in turn. This list is sorted by constraint strength, strongest first, as a heuristic 
	for avoiding unnecessarily adding and then overriding weak constraints."
	"Assume: c is satisfied."

	| out unsatisfied |
	out := c output.
	c markUnsatisfied.
	c removeFromGraph.
	unsatisfied := self removePropagateFrom: out.
	unsatisfied do: [: u | self incrementalAdd: u].! !

"August 24, 2008 -> 9:31:56"!

! (Delta mirrorFor: #Planner) classSide methodsFor: 'add/remove' !
incrementalAdd: c
	"Attempt to satisfy the given constraint and, if successful, incrementally update the dataflow graph."
	"Details: If satifying the constraint is successful, it may override a weaker constraint on its output. 
	The algorithm attempts to resatisfy that constraint using some other method. This process is 
	repeated until either a) it reaches a variable that was not previously determined by any constraint 
	or b) it reaches a constraint that is too weak to be satisfied using any of its methods. The variables 
	of constraints that have been processed are marked with a unique mark value so that we know 
	where we've been. This allows the algorithm to avoid getting into an infinite loop even if the 
	constraint graph has an inadvertent cycle."

	| mark overridden |
	mark := self newMark.
	overridden := c satisfy: mark.
	[overridden == nil] whileFalse:
		[overridden := overridden satisfy: mark].! !

"August 24, 2008 -> 9:46:39"!

"System saved" !
"August 25, 2008 -> 0:32:21"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				]}}
			]}}
			"can't happen"
		]}}! !

"August 25, 2008 -> 0:32:41"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
			"can't happen"
		]}}! !

"August 25, 2008 -> 0:34:15"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 25, 2008 -> 0:36:14"!

"System saved" !
"August 25, 2008 -> 0:44:37"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 25, 2008 -> 0:45:31"!

"System saved" !
"August 26, 2008 -> 13:8:9"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 13:12:7"!

"System saved" !
"August 26, 2008 -> 13:18:2"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 13:29:57"!

"System saved" !
"August 26, 2008 -> 13:45:44"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNew2IfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNew2IfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNew2IfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 14:40:35"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 26, 2008 -> 14:40:48"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		Transcript show: err.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 14:41:38"!

! (Delta mirrorFor: #Behavior) methodsFor: 'private' !
primitiveNew ^<Object>

	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			Transcript show: err2.
			VM collectGarbage.
			{{self primitiveNewIfFail: [:err3 <Symbol> |
				"need to expand memory here"
				]}}
			]}}
		]}}! !

"August 26, 2008 -> 16:47:54"!

"System saved" !
"August 27, 2008 -> 13:25:53"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
expand: size

	{{primitiveExpandMemory: (size * self oopSize)}}! !

"August 27, 2008 -> 13:26:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 27, 2008 -> 13:35:11"!

"System saved" !
"August 28, 2008 -> 9:35:0"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize
self halt.
	^{{primitiveOopSize}}! !

"August 28, 2008 -> 9:35:54"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 28, 2008 -> 9:36:45"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{self primitiveOopSize}}! !

"August 28, 2008 -> 9:37:35"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveOopSize}}! !

"August 28, 2008 -> 12:50:18"!

"System saved" !
"August 28, 2008 -> 15:37:37"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'private' !
oopSize

	^{{primitiveSizeOfOop}}! !

"August 28, 2008 -> 15:38:9"!

"System saved" !
"August 28, 2008 -> 15:51:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
deferredGC

	[self collectGarbage] fork! !

"August 28, 2008 -> 15:51:22"!

Delta define: #VM as: (
(Class subclassOf: 'Object' instanceVariables: '') classVariables: 'GCProcess GCSemaphore') !


"August 28, 2008 -> 15:53:25"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
deferredGC

	GCSemaphore := Semaphore new.
	[self collectGarbage.
	GCSemaphore signal] fork! !

"August 28, 2008 -> 16:8:4"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
waitForGC

	GCSemaphore isNil
		ifTrue: [self deferredGC]
		ifFalse:[GCSemaphore wait.
					GCSemaphore := nil]! !

"August 28, 2008 -> 16:17:9"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'garbage collection' !
isGCPending

	^GCSemaphore notNil! !

"August 28, 2008 -> 16:45:57"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err2<Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err3 <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err3 <Symbol> |
																"should not happen"]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err3 <Symbol> |
																"should not happen"]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 16:54:13"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																"should not happen"]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																"should not happen"]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 17:5:51"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 17:17:14"!

! (Delta mirrorFor: #IndexedInstanceVariables) classSide methodsFor: 'private' !
primitiveNew: size <Int> ^<Instance>

	^{{self primitiveIndexedObjectNew: size
			ifFail: [ :err <Symbol> |
					VM scavengeGarbage.
					{{self primitiveIndexedObjectNew: size
							ifFail: [ :err <Symbol> |
									VM isGCPending
										ifTrue: [VM waitForGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	VM expand: (VMMirror on: self) instanceSize + size.
																	VM deferredGC.
																	{{self primitiveIndexedObjectNew: size
																			ifFail: [:err <Symbol> |
																						self error: err]}}]}}]
										ifFalse: [VM expand: (VMMirror on: self) instanceSize + size.
													VM deferredGC.
													{{self primitiveIndexedObjectNew: size
															ifFail: [:err <Symbol> |
																	self error: err]}}]
						]}}
				]}}! !

"August 28, 2008 -> 18:0:1"!

"System saved" !
"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> | 
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		Transcript show: err; cr.
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 18:49:8"!

! (Delta mirrorFor: #Object) classSide methodsFor: 'instance creation' !
new ^<Instance>
	"Create and return an initialized instance of this class."

	"%remove when inlining working:"
	^{{self primitiveNewIfFail: [ :err <Symbol> |
		VM scavengeGarbage.
		{{self primitiveNewIfFail: [:err <Symbol> |
			Transcript show: err; cr.
			VM isGCPending
				ifTrue: [VM waitForGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
								VM expand: (VMMirror on: self) instanceSize.
								VM deferredGC.
								{{self primitiveNewIfFail: [:err <Symbol> |
																		self error: err]}}]}}]
				ifFalse: [VM expand: (VMMirror on: self) instanceSize.
							VM deferredGC.
							{{self primitiveNewIfFail: [:err <Symbol> |
																	self error: err]}}].
			]}}
		]}}
"
	^guaranteed <Instance> (super new)
"! !

"August 28, 2008 -> 19:24:12"!

"System saved" !
"September 8, 2008 -> 9:45:44"!

! (Delta mirrorFor: #RichardsBenchmarks) classSide methodsFor: 'instance creation' !
loop

	|start elapsed count|
start := Time millisecondClockValue.
count := 0.
[(elapsed := Time millisecondClockValue - start) < 1000]
	whileTrue: [
		self new run.
		count := count + 1].
elapsed * 1000.0/ count printOn: Transcript cr; yourself! !

"September 8, 2008 -> 9:45:57"!

"System saved" !
"September 24, 2008 -> 1:24:11"!

Delta define: #SequenceableCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]].
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	"self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]]."
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollectionTest) methodsFor: 'testing' !
testIsSortedBy


	self shouldnt: [#(1 5 3) isSortedBy: [:a :b| a < b]].
	self should: [#(1 3 5) isSortedBy: [:a :b| a < b]]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SequenceableCollection) methodsFor: 'testing' !
isSortedBy: compare <[E,E,^Boolean]> ^<Boolean>
	"Returns true if the receiver is in sorted order, using the specified comparison"

	| last <E> |
	self size < 2
		ifTrue: [ ^true ].
	last := self at: 1.
	2 to: self size do:
		[ :i <Int> | |current|
			(compare value: last value: (current := self at: i))
				ifFalse: [ ^false ].
			last := current].
	^true! !

"September 24, 2008 -> 1:24:12"!

Delta define: #SortedCollectionTest as: (
(Class subclassOf: 'TestCase' instanceVariables: '')) !


"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self shouldnt: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortedCollection
	|r c s index|
	r := Random new.
	1 to: 500 do:
		[:j|	c := Array[Int] new: j.
			1 to: j do:
				[ :i <Int> |
					c at: i put: (r next * (SmallInteger maxVal - 1)) asInteger	].
			"Transcript show: 'c size = '; print: c size; cr."
			self should: [ (c asSortedCollection: [ :i1 <Int> :i2 <Int> | i1 <= i2 ]) isSorted ]
				description: 'collection should be sorted'].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)]! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 2 1)asSortedCollection asArray = #(1 1 2)].! !

"September 24, 2008 -> 1:24:12"!

! (Delta mirrorFor: #SortedCollectionTest) methodsFor: 'testing' !
testSortSimpleCollection

	self should: [#(5 3 1) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 3 5) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 5 3) asSortedCollection asArray = #(1 3 5)].
	self should: [#(1 2 1)asSortedCollection asArray = #(1 1 2)].
	self should: [#(1 2 1 2)asSortedCollection asArray = #(1 1 2 2)].! !

"September 24, 2008 -> 1:38:52"!

"System saved" !
"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class ifFail: failureBlock

	^{{primitiveNew: class
			ifFail: [:e| failureBlock value: e]}}! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self freeSpace > 2 * self survivorSpaceSize
									ifTrue: [self scavengeGarbage
														ifTrue: [self collectGarbage]
														ifFalse: [allocateBlock
																			value: [:e2| self collectGarbage]]]]
						! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
spaceToScavenge

	^self freeSpace > 2 * self survivorSpaceSize					! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self spaceToScavenge
									ifTrue: [self scavengeGarbage
														ifTrue: [self collectGarbage]
														ifFalse: [allocateBlock
																			value: [:e2| self collectGarbage]]]]
						! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
new: class

	|allocateBlock|
	allocateBlock := [:failBlock| self new: class ifFail: failBlock].
	^allocateBlock
			value: [:e| self spaceToScavenge
									ifTrue: [self scavengeAndAllocate: allocateBlock]]! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
scavengeAndAllocate: allocateBlock

	^self scavengeGarbage
			ifTrue: [self collectGarbage.
							allocateBlock
								value: [:e| self expand.
													allocateBlock value: [:e2| self error: e2]]]
			ifFalse: [allocateBlock
								value: [:e3| self collectGarbage.
														allocateBlock
															value: [:e4| self expand.
																				allocateBlock value: [:e5| self error: e5]]]]! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
survivorSpaceSize

	^self smallIntegerAt: #SurvivorSize! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
freeSpace

	^{{freeSpace}}! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
spaceToScavenge

	^self freeSpace > (2 * self survivorSpaceSize)	! !

"September 25, 2008 -> 17:44:24"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'integer flags' !
survivorSpaceSize

	^(self smallIntegerAt: #SurvivorSize) * 1024! !

"September 25, 2008 -> 17:44:34"!

"System saved" !
"September 25, 2008 -> 17:44:57"!

! (Delta mirrorFor: #VM) classSide methodsFor: 'allocation' !
freeSpace

	^{{primitiveFreeSpace}}! !

"September 25, 2008 -> 17:49:9"!

"System saved" !
"September 27, 2008 -> 15:22:51"!

! (Delta mirrorFor: #Method) methodsFor: 'debugging' !
debugInfo

	^{{self primitiveMethodDebugInfo}}! !

"September 27, 2008 -> 15:24:31"!

(Delta mirrorFor: #Method) removeMethod: #debugInfo ifAbsent: [] !


"September 28, 2008 -> 21:33:34"!

"System saved" !