
"September 23, 2009 -> 10:33:0"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 1:36:33"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 22:47:37"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 22:47:38"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name nsmixin')) !


"September 24, 2009 -> 22:52:50"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 24, 2009 -> 23:40:43"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 1:25:59"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:21:18"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
computDependentsOf: inv <Class>
| dependents <Collection[Class]> mir <ClassVMMirror> |
                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
^dependents! !

"September 25, 2009 -> 20:21:33"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
computeDependentsOf: inv <Class>
| dependents <Collection[Class]> mir <ClassVMMirror> |
                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
^dependents! !

"September 25, 2009 -> 20:21:38"!

(Delta mirrorFor: #MixinDeclMirror) removeMethod: #computDependentsOf: ifAbsent: [] !


"September 25, 2009 -> 20:22:22"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := self computeDependentsFor: inv.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"September 25, 2009 -> 20:30:24"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
computeDependentsOf: inv <Class>
| dependents <Collection[Class]> mir <ClassVMMirror> |
                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
^dependents! !

"September 25, 2009 -> 20:31:35"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
computeDependentsOf: inv <Class>
| dependents <Collection[Class]> mir <ClassVMMirror> |
                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
mir name == #Class
	ifTrue: [dependents addAll: (ClassVMMirror on: Object) sortedSubclasses].
^dependents! !

"September 25, 2009 -> 20:32:30"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := self computeDependentsOf: inv.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"September 25, 2009 -> 20:33:1"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:33:3"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:34:10"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 25, 2009 -> 20:57:3"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
computeDependentsOf: inv <Class>
| dependents <Collection[Class]> mir <ClassVMMirror> |
                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
mir name == #Class
	ifTrue: [dependents addAll: (ClassVMMirror on: Object) sortedSubclasses].
^dependents! !

"September 25, 2009 -> 20:57:5"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := self computeDependentsOf: inv.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"September 25, 2009 -> 20:57:22"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 26, 2009 -> 8:36:46"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
computeDependentsOf: inv <Class>
| dependents <Collection[Class]> mir <ClassVMMirror> |
                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
mir name == #Class
	ifTrue: [dependents addAll: ((ClassVMMirror on: Object) sortedSubclasses collect: [:c| c class])].
^dependents! !

"September 26, 2009 -> 8:37:5"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := self computeDependentsOf: inv.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"September 26, 2009 -> 8:37:30"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 26, 2009 -> 9:8:37"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
computeDependentsOf: inv <Class>
| dependents <Collection[Class]> mir <ClassVMMirror> |
                                      
mir := ClassVMMirror on: inv.
dependents := mir sortedSubclasses remove: inv; yourself.
mir name == #Class
	ifTrue: [dependents addAll: (ClassVMMirror on: Object) sortedSubclasses].
^dependents! !

"September 26, 2009 -> 9:8:56"!

! (Delta mirrorFor: #MixinDeclMirror) methodsFor: 'Unclassified' !
prepareInvocation: inv <Class> mixinFormat: mixinFormat <Symbol> 
oldClasses: ocs <OrderedCollection[Class]> newClasses: ncs <OrderedCollection[ClassMirror]> 
ifFail: fb <[Str, ^DoesNotMatter]> ^  <Array[Class|Symbol]>
| 
dependents <Collection[Class]>
a <Array[Class | Symbol]>
mir <ClassVMMirror>
j  <Integer>
formats <VarDict[Class, Symbol]>
sc <ClassVMMirror | ClassMirror>
dm <ClassVMMirror>
formatMightChange <Boolean>
fmt <Symbol> 
|

                                      
mir := ClassVMMirror on: inv.
dependents := self computeDependentsOf: inv.
formats := IdentityDictionary[Class, Symbol] new.
formatMightChange := ocs isEmpty not.
formatMightChange 
	ifTrue:[
				formats at: inv put: nil.
				dependents do:[:d <Class> | formats at: d put: nil].
				fmt := self formatFor: mir mixinFormat: mixinFormat formats: formats ifFail: fb.
				]
	ifFalse:[fmt := mir format].
a := Array[Class | Symbol] new: 3 + (dependents size * 2).
a at: 1 put: inv.
a at: 2 put: fmt. " new format, if legal !!"
sc := ((ocs includes: inv)
			ifTrue:[ncs at: (ocs indexOf: inv ifAbsent:[self error: 'Internal failure in change'])]
			ifFalse:[mir]) superclass.
a at: 3 put: (sc notNil ifTrue:[sc reflectee] ifFalse:[nil]).
j := 4.
dependents do:[: d <Class>  | 
								dm := ClassVMMirror on: d.
								a at: j put: d.
								fmt := formatMightChange 
									ifTrue:[self formatFor: dm mixinFormat: dm mixin format formats: formats ifFail: fb]
									ifFalse:[dm format].
								a at: j + 1 put:  fmt. " new format, if legal !!"
								j := j + 2.
								].                           
^a! !

"September 26, 2009 -> 9:9:17"!

Delta define: #Class as: (
(Class subclassOf: 'ClassDescription' instanceVariables: 'name')) !


"September 26, 2009 -> 11:30:51"!

Delta define: #NewspeakMixin as: (
(Class subclassOf: 'Mixin' instanceVariables: '')) !


"September 26, 2009 -> 11:31:12"!

(Delta mirrorFor: #NewspeakMixin) removeDefinitionIfFail: [] !


"September 26, 2009 -> 11:31:25"!

Delta define: #NewspeakMixin as: (
(Class subclassOf: 'ClassMixin' instanceVariables: '')) !


"September 26, 2009 -> 11:31:33"!

Delta define: #NewspeakMixin as: (
(Class subclassOf: 'ClassMixin' instanceVariables: 'test')) !


"September 26, 2009 -> 11:31:41"!

(Delta mirrorFor: #NewspeakMixin) removeDefinitionIfFail: [] !


"September 26, 2009 -> 11:31:59"!

Delta define: #NewspeakClassMixin as: (
(Class subclassOf: 'ClassMixin' instanceVariables: '')) !


"September 26, 2009 -> 11:32:6"!

Delta define: #NewspeakClassMixin as: (
(Class subclassOf: 'ClassMixin' instanceVariables: 'test')) !


"September 26, 2009 -> 11:32:36"!

Delta define: #NewspeakMetaclassMixin as: (
(Class subclassOf: 'MetaClassMixin' instanceVariables: '')) !


"September 26, 2009 -> 11:32:46"!

Delta define: #NewspeakMetaclassMixin as: (
(Class subclassOf: 'MetaClassMixin' instanceVariables: 'test')) !


"September 26, 2009 -> 12:13:0"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:15:23"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:16:10"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:16:42"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:21:48"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:27:20"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 12:32:43"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 15:36:46"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 15:37:20"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: 'temp')) !


"September 26, 2009 -> 15:53:33"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 15:59:17"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 19:51:24"!

Delta define: #NewspeakMetaclass as: (
(Class subclassOf: 'Metaclass' instanceVariables: '')) !


"September 26, 2009 -> 19:51:39"!

Delta define: #NewspeakMetaclass as: (
(Class subclassOf: 'Metaclass' instanceVariables: 'one two three')) !


"September 26, 2009 -> 20:3:38"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 20:5:15"!

Delta define: #NewspeakMetaclass as: (
(Class subclassOf: 'Metaclass' instanceVariables: 'one two three')) !


"September 26, 2009 -> 20:5:17"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !


"September 26, 2009 -> 20:19:53"!

Delta define: #NewspeakMetaclass as: (
(Class subclassOf: 'Metaclass' instanceVariables: 'one two three')) !


"September 26, 2009 -> 20:19:54"!

Delta define: #NewspeakObject as: (
(Class subclassOf: 'Object' instanceVariables: '')) !

