Class
on:!
86436853!
unclassified!
0:! !
#categories!
unclassified! !
#superclassTypeString!
NewspeakObject! !
#group!
newspeak! !
Newspeak2Grammar_UnarySelectorParser_superInit_new!
86437962!
unclassified!
0! !
#comment!
In the absence of a separate lexer, an ambiguity arises, which this parser deals with.
 The problem is that when parsing a unary expression that is an argument to a keyword
 message, one expects a unary selector, which is an identifer.  However, it may be that the next
 token is actually a keyword, part of the surrounding message. If we aren't actually tokenizing,
 the prefix of the keyword will be misinterpreted as an identifier and hence as another unary
 message being sent to the argument.
 
 Using a lexer solves this but introduces a subtlety around the assignment operator :=. In that case
 if there is no whitespace between a variable name and the assignment, the variable name will
 be tokenized as a keyword rather than as an identifier. The Strongtalk parser, DeltaParser, deals
 with this specially. In the longterm, that is probably the way to go.! !
#revision!
$Revision: 0.0 $! !
parse:inContext:ifError:!
86437496!
unclassified!
0:::! !
#classVariableString!
MixinMetadata_Newspeak2Grammar_UnarySelectorParser EnclosingObjects_Newspeak2Grammar_UnarySelectorParser! !
#instanceVariableString!
 p! !
p:!
86437348!
unclassified!
0:! !
Newspeak2Grammar_UnarySelectorParser_1_init!
86437015!
unclassified!
0! !
p!
86437215!
unclassified!
0! !
new!
86438168!
unclassified!
0! !
